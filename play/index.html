<!DOCTYPE html>
<html lang="en" data-remix-generation="0" data-editor-live="https://smwhr.github.io/binksi">
  <head>
    <title>binksi</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="utf-8">
    <link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAAXNSR0IArs4c6QAAAAxQTFRFAAAAAxmR8+/s3i5SinG4LAAAAAR0Uk5TAP///7MtQIgAAABGSURBVBiVlY9BDgAgCMPY/P+fhQlo9GQTknXxMM0CCivYpA+PcQCXu8RVcxeeBav5K6CC6RDsVajCtiB3HJ5TL99vnv8qTuMLAYu9aKwhAAAAAElFTkSuQmCC">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Press+Start+2P" type="text/css">
    
    <script></script>
    <script>"strict"
const maker = {};
const ui = {};

/**
 * @template TProject
 * @typedef {(project: TProject) => string[]} maker.ManifestFunction
 */

/**
 * @typedef {Object} ResourceData
 * @property {string} type
 * @property {any} data
 */

/**
 * @typedef {Object.<string, ResourceData>} maker.ResourceBundle
 */

/**
 * @template TProject
 * @typedef {Object} maker.ProjectBundle
 * @property {TProject} project
 * @property {maker.ResourceBundle} resources
 */

/**
 * @template TData
 * @template TInstance
 * @typedef {Object} maker.ResourceHandler
 * @property {(data: TData) => Promise<TInstance>} load
 * @property {(instance: TInstance) => Promise<TInstance>} copy
 * @property {(instance: TInstance) => Promise<TData>} save
 */

/** @type {Map<string, maker.ResourceHandler<any, any>>} */
maker.resourceHandlers = new Map();

// add a resource type called "canvas-datauri" that describes how to load a
// canvas rendering context from a datauri, how to copy one, and how to convert
// one back into a datauri
maker.resourceHandlers.set("canvas-datauri", {
    load: async (data) => imageToRendering2D(await loadImage(data)),
    copy: async (instance) => copyRendering2D(instance),
    save: async (instance) => instance.canvas.toDataURL("image/png", 1),
});

maker.resourceHandlers.set("file-datauri", {
    load: async (data) => new File([await fetch(data.uri).then((r) => r.blob())], data.name, { type: data.type }),
    copy: async (instance) => new File([await instance.arrayBuffer()], instance.name, { type: instance.type }),
    save: async (instance) => ({ 
        name: instance.name, 
        uri: await maker.dataURIFromFile(instance), 
        type: instance.type,
    }),
});

maker.ResourceManager = class {
    constructor() {
        this.lastId = 0;
        /** @type {Map<string, { type: string, instance: any }>} */
        this.resources = new Map();
    }

    /**
     * Generate a new unique id for a resource.
     * @returns {string}
     */
    generateId() {
        this.lastId += 1;
        // just next lowest unused number
        while (this.resources.has(this.lastId.toString())) {
            this.lastId += 1;
        }

        return this.lastId.toString();
    }
    
    /**
     * Clear all resources.
     */
    clear() {
        this.resources.clear();
    }

    /**
     * Get the resource instance with the given id.
     * @param {string} id 
     * @returns {any}
     */
    get(id) {
        return this.resources.get(id)?.instance;
    }

    /**
     * Add a resource instance at a specific id.
     * @param {string} id 
     * @param {any} instance 
     * @param {string} type 
     */
    set(id, instance, type) {
        this.resources.set(id, { type, instance });
    }

    /**
     * Add an instance as a new resource and return its new id.
     * @param {any} instance 
     * @param {string} type 
     * @returns {string}
     */
    add(instance, type) {
        const id = this.generateId();
        this.set(id, instance, type);
        return id;
    }

    /**
     * Copy the existing resource with the given id and add it as a new resource.
     * @param {string} id 
     * @returns 
     */
    async fork(id) {
        const source = this.resources.get(id);
        const forkId = this.generateId();
        const instance = await maker.resourceHandlers.get(source.type).copy(source.instance); 
        this.set(forkId, instance, source.type);
        return { id: forkId, instance };
    }

    /**
     * Discard all resources except those at the ids given.
     * @param {Iterable<string>} keepIds 
     */
    prune(keepIds) {
        const ids = new Set(keepIds);

        this.resources.forEach((_, id) => {
            if (!ids.has(id)) this.resources.delete(id);
        });
    }

    /**
     * Copy all resources from another resource manager.
     * @param {maker.ResourceManager} other 
     */
    async copyFrom(other) {
        const tasks = [];
        Array.from(other.resources).forEach(([id, { type, instance }]) => {
            const task = maker.resourceHandlers.get(type)
                         .copy(instance)
                         .then((copy) => this.set(id, copy, type));
            tasks.push(task);
        });

        return Promise.all(tasks);
    }

    /**
     * Save all resources in an object mapping id to type and save data.
     * @param {Iterable<string>} ids 
     * @returns {Promise<maker.ResourceBundle>}
     */
    async save(ids) {
        /** @type {maker.ResourceBundle} */
        const bundle = {};

        const resourceIds = new Set(ids);
        const relevant = Array.from(this.resources)
                         .filter(([id]) => resourceIds.has(id));

        const tasks = [];
        Array.from(relevant).forEach(([id, { type, instance }]) => {
            const task = maker.resourceHandlers.get(type)
                         .save(instance)
                         .then((data) => bundle[id] = { type, data });
            tasks.push(task);
        });

        await Promise.all(tasks);
        return bundle;
    }

    /**
     * Load all resources from the given bundle.
     * @param {maker.ResourceBundle} bundle 
     */
    async load(bundle) {
        const tasks = [];
        Object.entries(bundle).forEach(([id, { type, data }]) => {
            const task = maker.resourceHandlers.get(type)
                         .load(data)
                         .then((instance) => this.set(id, instance, type));
            tasks.push(task);
        });
        return Promise.all(tasks);
    }
}

/**
 * 
 * @template TState
 */
maker.StateManager = class extends EventTarget {
    /**
     * Create a state manager, optionally providing a function that describes
     * how to determine resource dependencies of a given state. 
     * @param {maker.ManifestFunction<TState>} getManifest 
     */
    constructor(getManifest = undefined) {
        super();

        /** @type {maker.ManifestFunction<TState>} */
        this.getManifest = getManifest || (() => []);
        this.resources = new maker.ResourceManager();

        /** @type {TState[]} */
        this.history = [];
        this.index = -1;
        this.historyLimit = 20;
    }

    /**
     * The present state in history.
     */
    get present() {
        return this.history[this.index];
    }

    /**
     * Is there any edit history to undo to?
     */
    get canUndo() {
        return this.index > 0;
    }

    /**
     * Are there any undone edits to redo?
     */
    get canRedo() {
        return this.index < this.history.length - 1;
    }

    /**
     * Replace all state with the project and resources in the given project
     * bundle.
     * @param {maker.ProjectBundle<TState>} bundle
     */
    async loadBundle(bundle) {
        this.history.length = 0;
        this.history.push(bundle.project);
        this.index = 0;
        this.resources.clear();
        await this.resources.load(bundle.resources);

        this.changed();
    }

    /**
     * Replace all state by copying from another state manager.
     * @param {maker.StateManager<TState>} other 
     */
    async copyFrom(other) {
        this.history = COPY(other.history);
        this.index = other.index;
        
        this.resources.clear();
        await this.resources.copyFrom(other.resources);
        
        this.changed();
    }
    
    /**
     * Replace all state by copying just the present and dependent resources
     * from another state manager.
     * @param {maker.StateManager<TState>} other 
     */
    async copyPresentFrom(other) {
        this.history = [COPY(other.present)];
        this.index = 0;
        this.resources.clear();

        // TODO: only copy what's not going to be pruned..
        await this.resources.copyFrom(other.resources);
        this.pruneResources();
        
        this.changed();
    }

    /**
     * Copy the present state and dependent resources into a project bundle.
     * @returns {Promise<maker.ProjectBundle<TState>>}
     */
    async makeBundle() {
        const project = COPY(this.present);
        const resources = await this.resources.save(this.getManifest(this.present));

        return { project, resources };
    }

    /**
     * Save the current state as a checkpoint in history that can be returned to
     * with undo/redo.
     */
    makeCheckpoint() {
        this.history.length = this.index + 1;
        
        const currentData = this.present;

        this.history[this.index] = COPY(currentData);
        this.history.push(currentData);
        
        if (this.index < this.historyLimit) {
            this.index += 1;
        } else {
            // delete earliest history
            this.history.splice(0, 1);
            this.pruneResources();
        }
    }

    /**
     * Dispatch the change event signalling that the present state has been
     * updated.
     */
    changed() {
        this.dispatchEvent(new CustomEvent("change"));
    }

    /**
     * Discard all resources that are no longer required accord to the manifest
     * function.
     */
    pruneResources() {
        this.resources.prune(this.history.flatMap(this.getManifest));
    }

    /**
     * Make a history checkpoint, replace the current state with a forked
     * version via callback, and then dispatch the change event.
     * @param {(data: TState) => Promise} action 
     */
    async makeChange(action) {
        this.makeCheckpoint();
        await action(this.present);
        this.changed();
    }

    /**
     * Revert the state to the previous checkpoint in history.
     */
    undo() {
        if (!this.canUndo) return;
        this.index -= 1;
        this.changed();
    }

    /**
     * Return the state to the most recently undone checkpoint in history.
     */
    redo() {
        if (!this.canRedo) return;
        this.index += 1;
        this.changed();
    }
};

/**
 * Ask the browser to download the given blob as a file with the given name.
 * @param {Blob} blob 
 * @param {string} name
 */
maker.saveAs = function(blob, name) {
    const element = document.createElement("a");
    const url = window.URL.createObjectURL(blob);
    element.href = url;
    element.download = name;
    element.click();
    window.URL.revokeObjectURL(url);
};

/**
 * Open the browser file picker, optionally restricted to files of a given file
 * type pattern and optionally accepting multiple files. 
 * @param {string} accept 
 * @param {boolean} multiple 
 * @returns {Promise<File[]>}
 */
 maker.pickFiles = async function(accept = "*", multiple = false) {
    return new Promise((resolve) => {
        const fileInput = html("input", { type: "file", accept, multiple });
        fileInput.addEventListener("change", () => resolve(Array.from(fileInput.files)));
        fileInput.click();
    });
}

/**
 * Read plain text from a file.
 * @param {File} file 
 * @return {Promise<string>}
 */
maker.textFromFile = async function(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onerror = reject;
        reader.onload = () => resolve(/** @type {string} */ (reader.result));
        reader.readAsText(file); 
    });
}

/**
 * Read image from a file.
 * @param {File} file 
 * @return {Promise<string>}
 */
maker.dataURIFromFile = async function(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onerror = reject;
        reader.onload = () => resolve(/** @type {string} */ (reader.result));
        reader.readAsDataURL(file); 
    });
}

/**
 * Create a DOM for an html page from html source code
 * @param {string} source
 * @returns 
 */
maker.htmlFromText = function(source) {
    const template = document.createElement('template');
    template.innerHTML = source;
    return template.content;
}

/**
 * @param {string} text 
 */
maker.textToBlob = function(text, type = "text/plain") {
    return new Blob([text], { type });
}

/**
 * 
 * @param {ParentNode} html 
 */
maker.bundleFromHTML = function(html, query="#bundle-embed") {
    let json = ONE(query, html)?.textContent;

    const bundle = json ? JSON.parse(json.charCodeAt(0) == 123 ? json : json.substring(1)) : undefined;
    return bundle;
}

class RadioGroupWrapper extends EventTarget {
    /** @param {HTMLInputElement[]} inputs */
    constructor(inputs) {
        super();

        const group = this;
        this.onRadioChange = function() {
            if (!this.checked) return;
            group.dispatchEvent(new CustomEvent("change"));
        }

        this.inputs = [];
        this.replaceInputs(inputs);
    }

    get selectedIndex() {
        return this.inputs.findIndex((button) => button.checked); 
    }

    set selectedIndex(value) {
        this.inputs[value].click();
    }

    get selectedInput() {
        return this.inputs[this.selectedIndex];
    }

    get value() {
        return this.selectedInput?.value;
    }
    
    get valueAsNumber() {
        return parseInt(this.selectedInput?.value ?? "-1", 10);
    }

    setSelectedIndexSilent(value) {
        this.inputs.forEach((input, index) => input.checked = index === value);
    }

    setValueSilent(value) {
        value = value.toString();
        this.inputs.forEach((input) => input.checked = input.value === value);
    }

    /**
     * @param {HTMLElement} element 
     * @param  {...string} values 
     */
    tab(element, ...values) {
        this.addEventListener("change", () => element.hidden = !values.includes(this.value));
    }

    /**
     * @param {HTMLInputElement} radioElement 
     */
    add(radioElement) {
        this.inputs.push(radioElement);
        radioElement.addEventListener("change", this.onRadioChange);
    }

    /**
     * @param {HTMLInputElement} radioElement 
     */
    remove(radioElement) {
        arrayDiscard(this.inputs, radioElement);
        radioElement.removeEventListener("change", this.onRadioChange);
    }

    removeAll() {
        this.inputs.forEach((element) => element.removeEventListener("change", this.onRadioChange));
        this.inputs.length = 0;
    }

    replaceInputs(inputs) {
        this.removeAll();
        inputs.forEach((input) => this.add(input));
    }
}

class CheckboxWrapper extends EventTarget {
    /** @param {HTMLInputElement[]} inputs */
    constructor(inputs) {
        super();
        this.inputs = inputs;

        inputs.forEach((input) => {
            input.addEventListener("change", () => {
                this.setCheckedSilent(input.checked);
                this.dispatchEvent(new CustomEvent("change"));
            });
        });
    }

    get checked() {
        return this.inputs[0].checked; 
    }

    set checked(value) {
        if (this.checked !== value) this.inputs[0].click();
    }

    setCheckedSilent(value) {
        this.inputs.forEach((input) => input.checked = value);
    }
}

class ButtonAction extends EventTarget {
    /** @param {HTMLButtonElement[]} buttons */
    constructor(buttons) {
        super();
        this.buttons = buttons;
        this.disabled = false;

        buttons.forEach((button) => {
            button.addEventListener("click", () => this.invoke());
        });
    }

    get disabled() {
        return this._disabled;
    }

    set disabled(value) {
        this._disabled = value;
        this.buttons.forEach((button) => button.disabled = value);
    }

    invoke(force = false) {
        if (!force && this.disabled) return;
        this.dispatchEvent(new CustomEvent("invoke"));
    }
}

/**
 * Get a wrapper for the radio input elements sharing the given name.
 * @param {string} name
 * @returns {RadioGroupWrapper}
 */
ui.radio = (name) => new RadioGroupWrapper(ALL(`input[type="radio"][name="${name}"]`));

ui.toggle = (name) => new CheckboxWrapper(ALL(`input[type="checkbox"][name="${name}"]`));

/**
 * @param {string} name 
 * @returns {HTMLInputElement}
 */
ui.slider = (name) => ONE(`input[type="range"][name=${name}]`);

/**
 * @param {string} name 
 * @returns {HTMLInputElement | HTMLTextAreaElement}
 */
ui.text = (name) => ONE(`[name=${name}]`);

/** @type {Map<string, ButtonAction>} */
ui.actions = new Map();
/**
 * Get an action linked to all button elements sharing the given name. 
 * Optionally provide a default listener for the action.
 * @param {string} name
 * @param {() => void} listener
 * @returns {ButtonAction}
 */
ui.action = function (name, listener=undefined) {
    const action = new ButtonAction(ALL(`button[name="${name}"]`));
    ui.actions.set(name, action);
    if (listener) action.addEventListener("invoke", listener);
    return action;
}

/**
 * Get the html select element with the given name.
 * @param {string} name
 * @returns {HTMLSelectElement}
 */
ui.select = (name) => ONE(`select[name="${name}"]`);

/**
 * Get a child element matching CSS selector.
 * @param {string} query 
 * @param {ParentNode} element 
 * @returns {HTMLElement}
 */
const ONE = (query, element = undefined) => (element || document).querySelector(query);

/**
 * Get all children elements matching CSS selector.
 * @param {string} query 
 * @param {HTMLElement | Document} element 
 * @returns {HTMLElement[]}
 */
const ALL = (query, element = undefined) => Array.from((element || document).querySelectorAll(query));

/**
 * @template {any} T
 * @param {T[]} array 
 * @param {T} value
 * @returns {boolean}
 */
 function arrayDiscard(array, value) {
    const index = array.indexOf(value);
    if (index >= 0) array.splice(index, 1);
    return index >= 0;
}

ui.PointerDrag = class extends EventTarget {
    /** 
     * @param {MouseEvent} event
     */
    constructor(event, { clickMovementLimit = 5 } = {}) {
        super();
        this.pointerId = event["pointerId"];
        this.clickMovementLimit = 5;
        this.totalMovement = 0;

        this.downEvent = event;
        this.lastEvent = event;

        this.listeners = {
            "pointerup": (event) => {
                if (event.pointerId !== this.pointerId) return;

                this.lastEvent = event;
                this.unlisten();
                this.dispatchEvent(new CustomEvent("up", { detail: event }));
                if (this.totalMovement <= clickMovementLimit) {
                    this.dispatchEvent(new CustomEvent("click", { detail: event }));
                }
            },

            "pointermove": (event) => {
                if (event.pointerId !== this.pointerId) return;

                this.lastEvent = event;
                this.totalMovement += Math.abs(event.movementX);
                this.totalMovement += Math.abs(event.movementY);
                this.dispatchEvent(new CustomEvent("move", { detail: event }));
            }
        }

        document.addEventListener("pointerup", this.listeners.pointerup);
        document.addEventListener("pointermove", this.listeners.pointermove);
    }

    unlisten() {
        document.removeEventListener("pointerup", this.listeners.pointerup);
        document.removeEventListener("pointermove", this.listeners.pointermove);
    }
}

/**
 * Wrap a pointer down event and track its subsequent movement until release.
 * @param {PointerEvent} event 
 * @returns {ui.PointerDrag}
 */
ui.drag = (event) => new ui.PointerDrag(event);

/**
 * @param {HTMLCanvasElement} canvas 
 * @param {MouseEvent} event 
 */
 function mouseEventToCanvasPixelCoords(canvas, event) {
    const bounds = canvas.getBoundingClientRect();
    const [mx, my] = [event.clientX - bounds.x, event.clientY - bounds.y];
    const scale = canvas.width / canvas.clientWidth; 
    const [px, py] = [Math.floor(mx * scale), Math.floor(my * scale)];
    return { x: px, y: py };
}

/**
 * @param {HTMLCanvasElement} canvas 
 * @param {ui.PointerDrag} drag 
 */
function trackCanvasStroke(canvas, drag) {
    const positions = [mouseEventToCanvasPixelCoords(canvas, drag.downEvent)];
    const update = (event) => positions.push(mouseEventToCanvasPixelCoords(canvas, event.detail));
    drag.addEventListener("up", update);
    drag.addEventListener("move", update);
    return positions;
}

// from https://github.com/ai/nanoid/blob/master/non-secure/index.js
const urlAlphabet = 'ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW';
function nanoid(size = 21) {
    let id = '';
    let i = size;
    while (i--) id += urlAlphabet[(Math.random() * 64) | 0];
    return id
}

/**
 * Deep copy an object by serializing it to json and parsing it again.
 * @template T
 * @param {T} object
 * @returns {T}
 */
const COPY = (object) => JSON.parse(JSON.stringify(object));

/**
 * Create an array of zeroes to the given length.
 * @param {number} length 
 * @returns {number[]}
 */
const ZEROES = (length) => Array(length).fill(0);

/**
 * Create an array of a value repeated to the given length.
 * @template T
 * @param {number} length 
 * @param {T} value
 * @returns {T[]}
 */
 const REPEAT = (length, value) => Array(length).fill(value);

/**
 * Create an html element with the given attributes and children.
 * @template {keyof HTMLElementTagNameMap} K
 * @param {K} tagName 
 * @param {*} attributes 
 * @param  {...(Node | string)} children 
 * @returns {HTMLElementTagNameMap[K]}
 */
 function html(tagName, attributes = {}, ...children) {
    const element = /** @type {HTMLElementTagNameMap[K]} */ (document.createElement(tagName)); 
    Object.entries(attributes).forEach(([name, value]) => element.setAttribute(name, value));
    children.forEach((child) => element.append(child));
    return element;
}

/** @param {number} milliseconds */
function sleep(milliseconds) {
    return new Promise(resolve => setTimeout(resolve, milliseconds));
}

/** 
 * @template T
 * @param {IDBRequest<T>} request 
 * @returns {Promise<T>}
 */
 function promisfyRequest(request) {
    return new Promise((resolve, reject) => {
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
    });
}

/** 
 * @param {IDBTransaction} transaction 
 * @returns {Promise}
 */
 function promisfyTransaction(transaction) {
    return new Promise((resolve, reject) => {
        transaction.oncomplete = () => resolve();
        transaction.onabort = () => reject(transaction.error);
        transaction.onerror = () => reject(transaction.error);
    });
}

maker.ProjectStorage = class {
    constructor(appID, generateMeta=undefined) {
        this.appID = appID;
        this.generateMeta = generateMeta;
        this.error = undefined;

        this.openDatabase().then(
            (request) => request.close(),
            (reason) => this.error = reason,
        );
    }

    get available() {
        return this.error === undefined;
    }

    async openDatabase() {
        const request = indexedDB.open(this.appID);
        request.addEventListener("upgradeneeded", () => {
            request.result.createObjectStore("projects");
            request.result.createObjectStore("projects-meta");
        });
        return promisfyRequest(request);
    }

    async stores(mode) {
        const db = await this.openDatabase();
        const transaction = db.transaction(["projects", "projects-meta"], mode);
        const projects = transaction.objectStore("projects");
        const meta = transaction.objectStore("projects-meta");
        return { transaction, projects, meta };
    }

    /**
     * @returns {Promise<any[]>}
     */
    async list() {
        const stores = await this.stores("readonly");
        return promisfyRequest(stores.meta.getAll());
    }

    /**
     * @param {any} projectData 
     * @returns {Promise}
     */
    async save(projectData, key) {
        const meta = { date: (new Date()).toISOString() };
        if (this.generateMeta) Object.assign(meta, this.generateMeta(projectData)); 
    
        const stores = await this.stores("readwrite");
        stores.projects.put(projectData, key);
        stores.meta.put(meta, key);
        return promisfyTransaction(stores.transaction);
    }

    /**
     * @param {string} key
     * @returns {Promise<any>}
     */
    async load(key) {
        const stores = await this.stores("readonly");
        return promisfyRequest(stores.projects.get(key));
    }

    /**
     * @param {string} key
     */
    async delete(key) {
        const stores = await this.stores("readwrite");
        stores.projects.delete(key);
        stores.meta.delete(key);
        return promisfyTransaction(stores.transaction);
    }
}

    </script>
    <script>/**
 * @param {number} width
 * @param {number} height
 * @returns {CanvasRenderingContext2D}
 */
function createRendering2D(width, height) {
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const context = canvas.getContext('2d');
    context.imageSmoothingEnabled = false;
    return context;
}

/**
 * @param {CanvasRenderingContext2D} rendering 
 * @param {string | CanvasGradient | CanvasPattern | undefined} fillStyle
 */
function fillRendering2D(rendering, fillStyle = undefined) {
    if (fillStyle !== undefined) {
        const prevStyle = rendering.fillStyle;
        rendering.fillStyle = fillStyle;
        rendering.fillRect(0, 0, rendering.canvas.width, rendering.canvas.height);
        rendering.fillStyle = prevStyle;
    } else {
        rendering.clearRect(0, 0, rendering.canvas.width, rendering.canvas.height);
    }
}

/**
 * @param {CanvasRenderingContext2D} source
 * @param {CanvasRenderingContext2D} destination
 * @param {{ x: number, y: number, w: number, h: number }} rect
 */
function copyRendering2D(
    source, 
    destination = undefined,
    rect = undefined,
) {
    rect = rect ?? { x: 0, y: 0, w: source.canvas.width, h: source.canvas.height };
    destination = destination || createRendering2D(rect.w, rect.h);
    destination.canvas.width = rect.w;
    destination.canvas.height = rect.h;

    destination.drawImage(
        source.canvas, 
        rect.x, rect.y, rect.w, rect.h,
        0, 0, rect.w, rect.h,
    );

    return destination;
}

/**
 * @param {CanvasRenderingContext2D} rendering 
 * @param {number} width 
 * @param {number} height 
 */
function resizeRendering2D(rendering, width, height) {
    const copy = copyRendering2D(rendering);
    rendering.canvas.width = width;
    rendering.canvas.height = height;
    rendering.drawImage(copy.canvas, 0, 0);
}

/**
 * @param {CanvasRenderingContext2D} rendering 
 */
function invertMask(rendering) {
    withPixels(rendering, (pixels) => {
        for (let i = 0; i < pixels.length; ++i) {
            pixels[i] = 0xFFFFFFFF - pixels[i];
        }
    });
}

/**
 * @param {CanvasRenderingContext2D} rendering 
 * @param {number} dx
 * @param {number} dy
 */
function cycleRendering2D(rendering, dx, dy) {
    const { width, height } = rendering.canvas;
    const sx = -Math.sign(dx);
    const sy = -Math.sign(dy);

    const temp = copyRendering2D(rendering);

    fillRendering2D(rendering);
    rendering.drawImage(temp.canvas, dx,            dy            );
    rendering.drawImage(temp.canvas, dx + width*sx, dy            ); 
    rendering.drawImage(temp.canvas, dx + width*sx, dy + height*sy); 
    rendering.drawImage(temp.canvas, dx,            dy + height*sy); 
}

/**
 * @param {CanvasRenderingContext2D} rendering 
 */
function mirrorRendering2D(rendering) {
    const prevComposite = rendering.globalCompositeOperation;
    rendering.globalCompositeOperation = "copy";
    rendering.scale(-1, 1);
    rendering.drawImage(rendering.canvas, -rendering.canvas.width, 0);
    rendering.globalCompositeOperation = prevComposite;
}

/**
 * @param {CanvasRenderingContext2D} rendering 
 */
 function flipRendering2D(rendering) {
    const prevComposite = rendering.globalCompositeOperation;
    rendering.globalCompositeOperation = "copy";
    rendering.scale(1, -1);
    rendering.drawImage(rendering.canvas, 0, -rendering.canvas.height);
    rendering.globalCompositeOperation = prevComposite;
}

/**
 * @param {CanvasRenderingContext2D} rendering 
 * @param {number} turns
 */
 function turnRendering2D(rendering, turns=1) {
    const { width, height } = rendering.canvas;
    const prevComposite = rendering.globalCompositeOperation;

    rendering.globalCompositeOperation = "copy";
    rendering.setTransform(1, 0, 0, 1, width/2, height/2);
    rendering.rotate(turns * Math.PI / 2);
    rendering.drawImage(rendering.canvas, -width/2, -height/2);
    rendering.globalCompositeOperation = prevComposite;
}

/**
 * @callback pixelsAction
 * @param {Uint32Array} pixels
 */

/**
 * @param {CanvasRenderingContext2D} rendering 
 * @param {pixelsAction} action 
 */
function withPixels(rendering, action) {
    const imageData = rendering.getImageData(0, 0, rendering.canvas.width, rendering.canvas.height);
    action(new Uint32Array(imageData.data.buffer));
    rendering.putImageData(imageData, 0, 0);
}

/**
 * @param {CanvasRenderingContext2D} mask 
 * @param {string} style 
 * @param {CanvasRenderingContext2D} destination 
 */
function recolorMask(mask, style, destination = undefined) {
    const recolored = copyRendering2D(mask, destination);
    recolored.globalCompositeOperation = "source-in";
    fillRendering2D(recolored, style);
    return recolored;
}

/**
 * @param {number} x0 
 * @param {number} y0 
 * @param {number} x1 
 * @param {number} y1 
 * @param {(x: number, y: number) => void} plot 
 */
// adapted from https://stackoverflow.com/a/34267311
function lineplot(x0, y0, x1, y1, plot) {
    x0 |= 0; y0 |= 0; x1 |= 0; y1 |= 0;

    const steep = Math.abs(y1 - y0) > Math.abs(x1 - x0);
    if (steep) [x0, y0, x1, y1] = [y0, x0, y1, x1];

    const dx = Math.abs(x1 - x0);
    const dy = Math.abs(y1 - y0);
    const ystep = Math.sign(y1 - y0);
    const xstep = Math.sign(x1 - x0);

    let err = Math.floor(dx / 2);
    let y = y0;

    if (dx === 0 && dy === 0) {
        plot(x0, y0);
    }

    for (let x = x0; x != (x1 + xstep); x += xstep) {
        plot(steep ? y : x, steep ? x : y);
        err -= dy;
        if (err < 0) {
            y += ystep;
            err += dx;
        }
    }
}

/**
 * @param {CanvasRenderingContext2D} rendering 
 * @param {number} x 
 * @param {number} y 
 * @param {number} color
 */
function floodfill(rendering, x, y, color, tolerance = 5) {
    const [width, height] = [rendering.canvas.width, rendering.canvas.height];
    withPixels(rendering, pixels => {
        const queue = [[x, y]];
        const done = new Array(width * height);
        const initial = pixels[y * width + x];

        const ir = initial >>>  0 & 0xFF;
        const ig = initial >>>  8 & 0xFF;
        const ib = initial >>> 16 & 0xFF;

        function enqueue(x, y) {
            const within = x >= 0 && y >= 0 && x < width && y < height;

            if (within && !done[y * width + x]) {
                const pixel = pixels[y * width + x];

                const pr = pixel >>>  0 & 0xFF;
                const pg = pixel >>>  8 & 0xFF;
                const pb = pixel >>> 16 & 0xFF;
                const dist = Math.abs(pr - ir) + Math.abs(pg - ig) + Math.abs(pb - ib);
                
                if (dist <= tolerance) queue.push([x, y]);
            }
        }

        while (queue.length > 0) {
            const [x, y] = queue.pop();
            pixels[y * width + x] = color;
            done[y * width + x] = true;

            enqueue(x - 1, y);
            enqueue(x + 1, y);
            enqueue(x, y - 1);
            enqueue(x, y + 1);
        }
    });
};

/**
 * @param {CanvasRenderingContext2D} rendering 
 * @param {number} x 
 * @param {number} y 
 * @param {number} color
 * @returns {CanvasRenderingContext2D}
 */
 function floodfillOutput(rendering, x, y, color) {
    const [width, height] = [rendering.canvas.width, rendering.canvas.height];
    const output = createRendering2D(width, height);
    withPixels(rendering, srcPixels =>
    withPixels(output, dstPixels => {
        const queue = [[x, y]];
        const done = new Array(width * height);
        const initial = srcPixels[y * width + x];

        function enqueue(x, y) {
            const within = x >= 0 && y >= 0 && x < width && y < height;

            if (within && srcPixels[y * width + x] === initial && !done[y * width + x]) {
                queue.push([x, y]);
            }
        }

        while (queue.length > 0) {
            const [x, y] = queue.pop();
            dstPixels[y * width + x] = color;
            done[y * width + x] = true;

            enqueue(x - 1, y);
            enqueue(x + 1, y);
            enqueue(x, y - 1);
            enqueue(x, y + 1);
        }
    }));
    return output;
};

/**
 * @param {{r:number,g:number,b:number}} rgb 
 */
function rgbToHex(rgb) {
    const packed = (0xFF000000 + (rgb.r << 16) + (rgb.g << 8) + (rgb.b << 0));
    return "#" + packed.toString(16).substr(-6);
}

/**
 * @param {string} hex 
 * @param {number} alpha
 */
function hexToUint32(hex, alpha = undefined) {
    if (hex.charAt(0) === '#') hex = hex.substring(1);
    if (alpha === undefined && hex.length === 8) alpha = parseInt(hex.substr(6, 2), 16);
    if (alpha === undefined) alpha = 255;
    hex = hex.substr(4, 2) + hex.substr(2, 2) + hex.substr(0, 2);
    return (parseInt(hex, 16) | (alpha << 24)) >>> 0;
}

/**
 * @param {number} number
 * @param {string} prefix 
 */
function numberToHex(number, prefix = '#') {
    number = (number | 0xff000000) >>> 0;
    let hex = number.toString(16).substring(2, 8);
    hex = hex.substr(4, 2) + hex.substr(2, 2) + hex.substr(0, 2);
    return prefix + hex;
}

const MASK_PALETTE = {
    '_': hexToUint32('#000000', 0),
    default: hexToUint32('#FFFFFF', 255),
};

/**
 * @param {string} text 
 * @param {Record<string, number>} palette 
 * @returns {CanvasRenderingContext2D}
 */
function textToRendering2D(text, palette = MASK_PALETTE) {
    text = text.trim();
    const lines = text.split('\n').map((line) => [...line.trim()]);

    const width = lines[0].length;
    const height = lines.length;

    const rendering = createRendering2D(width, height);
    withPixels(rendering, (pixels) => {
        lines.forEach((line, y) => line.forEach((char, x) => {
            const color = palette[char];
            pixels[y * width + x] = color !== undefined ? color : palette.default;
        }));
    });

    return rendering;
}

/**
 * @param {{ h: number, s: number, v: number }} hsv
 */
function HSVToRGB(hsv) {
    const { h, s, v } = hsv;
    let r, g, b;
    const i = Math.floor(h * 6);
    const f = h * 6 - i;
    const p = (1 - s);
    const q = (1 - f * s);
    const t = (1 - (1 - f) * s);
    switch (i % 6) {
        case 0: r = 1, g = t, b = p; break;
        case 1: r = q, g = 1, b = p; break;
        case 2: r = p, g = 1, b = t; break;
        case 3: r = p, g = q, b = 1; break;
        case 4: r = t, g = p, b = 1; break;
        case 5: r = 1, g = p, b = q; break;
    }

    r *= v * 255;
    g *= v * 255;
    b *= v * 255;

    return { r, g, b };
}

/**
 * @param {{ r: number, g: number, b: number }} rgb
 */
function RGBToHSV(rgb) {
    const { r, g, b } = rgb;
    var max = Math.max(r, g, b), min = Math.min(r, g, b),
        d = max - min,
        h,
        s = (max === 0 ? 0 : d / max),
        v = max / 255;

    switch (max) {
        case min: h = 0; break;
        case r: h = (g - b) + d * (g < b ? 6: 0); h /= 6 * d; break;
        case g: h = (b - r) + d * 2; h /= 6 * d; break;
        case b: h = (r - g) + d * 4; h /= 6 * d; break;
    }

    return { h, s, v };
}

function HSVToCone(hsv) {
    const a = Math.PI * hsv.h;
    const r = hsv.s * .5 * hsv.v;
    const x = Math.cos(a) * r;
    const y = Math.sin(a) * r;
    return { x, y, z: hsv.v };
}


function uint32ToRGB(uint32) {
    return {
        r: uint32 >>>  0 & 0xFF,
        g: uint32 >>>  8 & 0xFF,
        b: uint32 >>> 16 & 0xFF,
        uint32,
    };
}

function hexToRGB(hex) {
    if (hex.charAt(0) === '#') hex = hex.substring(1);
    return {
        b: parseInt(hex.substr(4, 2), 16),
        g: parseInt(hex.substr(2, 2), 16),
        r: parseInt(hex.substr(0, 2), 16),
        uint32: hexToUint32(hex),
    };
}

function RGBToUint32(rgb) {
    return rgb.r | rgb.g << 8 | rgb.b << 16 | 0xFF << 24;
}

/**
 * @param {CanvasRenderingContext2D} rendering 
 * @param {string[]} palette 
 */
function recolorToPalette(rendering, palette) {
    const paletteConverted = palette.map((hex) => { 
        const cone = HSVToCone(RGBToHSV(hexToRGB(hex)));
        const uint32 = hexToUint32(hex);
        return { ...cone, uint32 };
    });
    const mapping = new Map();

    function chooseColor(uint32) {
        const alpha = (uint32 >>> 24) < 16;
        if (alpha) return 0;

        const existing = mapping.get(uint32);
        if (existing) return existing;

        const actual = HSVToCone(RGBToHSV(uint32ToRGB(uint32)));
        let bestSqrDistance = Infinity;
        let best = paletteConverted[0];

        for (let candidate of paletteConverted) {
            const dx = Math.abs(actual.x - candidate.x);
            const dy = Math.abs(actual.y - candidate.y);
            const dz = Math.abs(actual.z - candidate.z);
            const sqrDistance = dx*dx + dy*dy + dz*dz;
            
            if (sqrDistance < bestSqrDistance) {
                bestSqrDistance = sqrDistance;
                best = candidate;
            }
        }

        mapping.set(uint32, best.uint32);
        return best.uint32;
    }

    withPixels(rendering, (pixels) => {
        for (let i = 0; i < pixels.length; ++i) {
            pixels[i] = chooseColor(pixels[i]);
        }
    });
}

/** 
 * Copy image contents to a new canvas rendering context.
 * @param {HTMLImageElement} image 
 */
function imageToRendering2D(image) {
    const rendering = createRendering2D(image.naturalWidth, image.naturalHeight);
    rendering.drawImage(image, 0, 0);
    return rendering;
}

/**
 * Create an html image from a given src (probably a datauri).
 * @param {string} src
 * @returns {Promise<HTMLImageElement>}
 */
async function loadImage(src) {
    return new Promise((resolve, reject) => {
        const image = document.createElement("img");
        image.addEventListener("load", () => resolve(image));
        image.addEventListener("error", reject);
        image.src = src;
    });
}

/**
 * In the given rendering, replace every instance of a color in the prev palette
 * with the corresponding color in the next palette, ignoring colors that don't
 * appear. This is broken in firefox because colors are not stored exactly. 
 * @param {CanvasRenderingContext2D} rendering 
 * @param {string[]} prev 
 * @param {string[]} next 
 */
 function swapPalette(rendering, prev, next) {
    const mapping = new Map();
    prev.forEach((pixel, index) => mapping.set(prev[index], next[index]));

    withPixels(rendering, (pixels) => {
        for (let i = 0; i < pixels.length; ++i) {
            pixels[i] = mapping.get(pixels[i]) || pixels[i];
        }
    });
}

/**
 * Replace every color in the given rendering. Each existing color is matched
 * to the closest color in the prev palette and replaced with the corresponding
 * color in the next palette. 
 * @param {CanvasRenderingContext2D} rendering 
 * @param {number[]} prev 
 * @param {number[]} next 
 */
function swapPaletteSafe(rendering, prev, next) {
    const mapping = new Map();
    for (let i = 0; i < prev.length; ++i) {
        mapping.set(prev[i], next[i % next.length]);
    }

    function addMissing(prevPixel) {
        let bestDistance = Infinity;
        let bestNextPixel = next[0];

        const pr = prevPixel >>>  0 & 0xFF;
        const pg = prevPixel >>>  8 & 0xFF;
        const pb = prevPixel >>> 16 & 0xFF;

        for (let i = 0; i < prev.length; ++i) {
            const target = prev[i];
            const tr = target >>>  0 & 0xFF;
            const tg = target >>>  8 & 0xFF;
            const tb = target >>> 16 & 0xFF;

            const dist = Math.abs(pr - tr) 
                       + Math.abs(pg - tg) 
                       + Math.abs(pb - tb);

            if (dist < bestDistance) {
                bestDistance = dist;
                bestNextPixel = next[i];
            }
        }

        mapping.set(prevPixel, bestNextPixel);
        return bestNextPixel;
    }

    withPixels(rendering, (pixels) => {
        for (let i = 0; i < pixels.length; ++i) {
            const prev = pixels[i];
            pixels[i] = mapping.get(prev) ?? addMissing(prev);
        }
    });
}

/**
 * @param {HTMLCanvasElement} canvas 
 */
async function canvasToBlob(canvas) {
    return new Promise((resolve) => canvas.toBlob(resolve));
}

    </script>
    <script>/**
 * @typedef {Object} Vector2
 * @property {number} x
 * @property {number} y
 */

/**
 * @typedef {Object} Rect
 * @property {number} x
 * @property {number} y
 * @property {number} width
 * @property {number} height
 */

/**
 * @param {number} min 
 * @param {number} max 
 */
 function range(min, max) {
    return Array.from(new Array(max-min+1), (x, i) => i + min);
}

/**
 * @typedef {Object} BlitsyFontCharacter
 * @property {number} codepoint
 * @property {CanvasImageSource} image
 * @property {number} spacing
 */

/**
 * @typedef {Object} BlitsyFont
 * @property {string} name
 * @property {number} lineHeight
 * @property {Map<number, BlitsyFontCharacter>} characters
 */

/**
 * @typedef {Object} BlitsyGlyph
 * @property {HTMLCanvasElement} image
 * @property {Vector2} position
 * @property {Vector2} offset
 * @property {boolean} hidden
 * @property {string} fillStyle
 * @property {Map<string, any>} styles
 */

/**
 * @typedef {Object} BlitsyTextRenderOptions
 * @property {BlitsyFont} font
 * @property {number} lineCount
 * @property {number} lineWidth
 */

/** @typedef {BlitsyGlyph[]} BlitsyPage */

/** @param {HTMLScriptElement} script */
async function loadBasicFont(script) {
    const atlasdata = script.innerHTML;
    const charWidth = parseInt(script.getAttribute("data-char-width"), 10);
    const charHeight = parseInt(script.getAttribute("data-char-height"), 10);
    const indexes = parseRuns(script.getAttribute("data-runs"));

    const atlas = await loadImage(atlasdata);
    const cols = atlas.naturalWidth / charWidth;

    const font = {
        name: "font",
        lineHeight: charHeight,
        characters: new Map(),
    };

    indexes.forEach((codepoint, i) => {
        const col = i % cols;
        const row = Math.floor(i / cols);

        const rect = { 
            x: col * charWidth, 
            y: row * charHeight, 
            width: charWidth, 
            height: charHeight,
        };

        const image = copyImageRect(atlas, rect).canvas;
        font.characters.set(codepoint, { codepoint, image, spacing: charWidth });
    });

    return font;
}

/** @param {string} data */
function parseRuns(data) {
    const runs = data.split(",").map((run) => {
        const [start, end] = run.split("-").map((index) => parseInt(index, 10));
        return [ start, end ?? start ];
    });
    const indexes = [];
    runs.forEach(([min, max]) => indexes.push(...range(min, max)));
    return indexes;
}

/**
 * @param {CanvasImageSource} source 
 * @param {Rect} rect 
 */
function copyImageRect(source, rect) {
    const rendering = createRendering2D(rect.width, rect.height);
    rendering.drawImage(source, rect.x, rect.y, rect.width, rect.height, 0, 0, rect.width, rect.height);
    return rendering;
}

/**
 * @param {BlitsyFont} font 
 * @param {string} char 
 */
function getFontChar(font, char) {
    const codepoint = char.codePointAt(0);
    return font.characters.get(codepoint);
}

/** 
 * @param {BlitsyPage} page 
 * @param {number} width
 * @param {number} height
 * @param {number} ox
 * @param {number} oy
 */
function renderPage(page, width, height, ox = 0, oy = 0)
{
    const result = createRendering2D(width, height);
    const buffer = createRendering2D(width, height);

    for (const glyph of page)
    {
        if (glyph.hidden) continue;

        // padding + position + offset
        const x = ox + glyph.position.x + glyph.offset.x;
        const y = oy + glyph.position.y + glyph.offset.y;
        
        // draw tint layer
        result.fillStyle = glyph.fillStyle;
        result.fillRect(x, y, glyph.image.width, glyph.image.height);
        
        // draw text layer
        buffer.drawImage(glyph.image, x, y);
    }

    // draw text layer in tint color
    result.globalCompositeOperation = 'destination-in';
    result.drawImage(buffer.canvas, 0, 0);

    return result;
}

const defaultStyleHandler = (styles, style) => {
    if (style.substr(0, 1) === "+") {
        styles.set(style.substring(1), true);
    } else if (style.substr(0, 1) === "-") {
        styles.delete(style.substring(1));
    } else if (style.includes("=")) {
        const [key, val] = style.split(/\s*=\s*/);
        styles.set(key, val);
    }
}

/**
 * @param {string} script 
 * @param {BlitsyTextRenderOptions} options 
 * @param {*} styleHandler 
 * @returns {BlitsyPage[]}
 */
function scriptToPages(script, options, styleHandler = defaultStyleHandler) {
    const tokens = tokeniseScript(script);
    const commands = tokensToCommands(tokens);
    return commandsToPages(commands, options, styleHandler);
}

function tokeniseScript(script) {
    const tokens = [];
    let buffer = "";
    let braceDepth = 0;

    function openBrace() {
        if (braceDepth === 0) flushBuffer();
        braceDepth += 1;
    }

    function closeBrace() {
        if (braceDepth === 1) flushBuffer();
        braceDepth -= 1;
    }

    function newLine() {
        flushBuffer();
        tokens.push(["markup", "el"]);
    }

    function flushBuffer() {
        if (buffer.length === 0) return;
        const type = braceDepth > 0 ? "markup" : "text";
        tokens.push([type, buffer]);
        buffer = "";
    }

    const actions = {
        "{": openBrace,
        "}": closeBrace,
        "\n": newLine,
    }

    for (const char of script) {
        if (char in actions)
            actions[char]();
        else
            buffer += char;
    }

    flushBuffer();

    return tokens;
}

function textBufferToCommands(buffer) {
    const chars = Array.from(buffer);
    return chars.map((char) => ({ type: "glyph", char, breakable: char === " " }));
}

function markupBufferToCommands(buffer) {
    if (buffer === "ep") return [{ type: "break", target: "page" }];
    if (buffer === "el") return [{ type: "break", target: "line" }];
    else                 return [{ type: "style", style: buffer }];
}

/** @param {any[]} tokens */
function tokensToCommands(tokens) {
    const handlers = {
        "text": textBufferToCommands,
        "markup": markupBufferToCommands,
    };

    const tokenToCommands = ([type, buffer]) => handlers[type](buffer); 
    return tokens.flatMap(tokenToCommands);
}

/**
 * @param {*} commands 
 * @param {BlitsyTextRenderOptions} options 
 * @param {*} styleHandler 
 */
function commandsToPages(commands, options, styleHandler) {
    commandsBreakLongSpans(commands, options);

    const styles = new Map();
    const pages = [];
    let page = [];
    let currLine = 0;

    function newPage() {
        pages.push(page);
        page = [];
        currLine = 0;
    }

    function endPage() { 
        do { endLine(); } while (currLine % options.lineCount !== 0)
    }

    function endLine() {
        currLine += 1;
        if (currLine === options.lineCount) newPage();
    }

    function doBreak(target) {
             if (target === "line") endLine();
        else if (target === "page") endPage(); 
    }

    function findNextBreakIndex() {
        let width = 0;

        for (let i = 0; i < commands.length; ++i) {
            const command = commands[i];
            if (command.type === "break") return i;
            if (command.type === "style") continue;

            width += computeLineWidth(options.font, command.char);
            // if we overshot, look backward for last possible breakable glyph
            if (width > options.lineWidth) {
                const result = find(commands, i, -1, command => command.type === "glyph" && command.breakable);
                if (result) return result[1];
            }
        };
    }

    function addGlyph(command, offset) {
        const char = getFontChar(options.font, command.char) ?? getFontChar(options.font, "?");
        const position = { x: offset, y: currLine * (options.font.lineHeight + 4) };
        const glyph = { 
            image: char.image,
            position,
            offset: { x: 0, y: 0 },
            hidden: true,
            fillStyle: "white",
            styles: new Map(styles.entries()),
        };

        page.push(glyph);
        return char.spacing;
    }

    function generateGlyphLine(commands) {
        let offset = 0;
        for (const command of commands) {
            if (command.type === "glyph") {
                offset += addGlyph(command, offset);
            } else if (command.type === "style") {
                styleHandler(styles, command.style);
            }
        }
    }

    let index;
    
    while ((index = findNextBreakIndex()) !== undefined) {
        generateGlyphLine(commands.slice(0, index));
        commands = commands.slice(index);

        const command = commands[0];
        if (command.type === "break") {
            doBreak(command.target);
            commands.shift();
        } else {
            if (command.type === "glyph" && command.char === " ") {
                commands.shift();
            }
            endLine();
        }
    }

    generateGlyphLine(commands);
    endPage();

    return pages;
}

/**
 * Find spans of unbreakable commands that are too long to fit within a page 
 * width and amend those spans so that breaking permitted in all positions. 
 * @param {*} commands
 * @param {BlitsyTextRenderOptions} options
 */
function commandsBreakLongSpans(commands, options) {
    const canBreak = (command) => command.type === "break" 
                               || (command.type === "glyph" && command.breakable); 

    const spans = filterToSpans(commands, canBreak);

    for (const span of spans) {
        const glyphs = span.filter(command => command.type === "glyph");
        const charWidths = glyphs.map(command => computeLineWidth(options.font, command.char));
        const spanWidth = charWidths.reduce((x, y) => x + y, 0);

        if (spanWidth > options.lineWidth) {
            for (const command of glyphs) command.breakable = true;
        }
    }
}

/**
 * @param {BlitsyFont} font 
 * @param {string} line 
 */
function computeLineWidth(font, line) {
    const chars = Array.from(line).map((char) => getFontChar(font, char));
    const widths = chars.map((char) => char ? char.spacing : 0);
    return widths.reduce((a, b) => a + b);
}

/**
 * Segment the given array into contiguous runs of elements that are not 
 * considered breakable.
 */
function filterToSpans(array, breakable) {
    const spans = [];
    let buffer = [];

    array.forEach((element, index) => {
        if (!breakable(element, index)) {
            buffer.push(element);
        } else if (buffer.length > 0) {
            spans.push(buffer);
            buffer = [];
        }
    });

    if (buffer.length > 0) {
        spans.push(buffer);
    }

    return spans;
}

function find(array, start, step, predicate) {
    for (let i = start; 0 <= i && i < array.length; i += step) {
        if (predicate(array[i], i)) return [array[i], i];
    }
}

    </script>
    <script>/**
 * @typedef {Object} DialoguePage
 * @property {BlitsyPage} glyphs
 * @property {Partial<DialogueOptions>} options
 */

/**
 * @typedef {Object} DialogueOptions
 * @property {*} font
 * @property {number} anchorX
 * @property {number} anchorY
 * @property {number} lines
 * @property {number} lineGap
 * @property {number} lineWidth
 * @property {number} padding
 * @property {number} glyphRevealDelay
 * @property {string} backgroundColor
 * @property {string} panelColor
 * @property {string} textColor
 */

const DIALOGUE_DEFAULTS = {
    anchorX: 0.5,
    anchorY: 0.5,

    lines: 2,
    lineGap: 4,
    padding: 8,

    glyphRevealDelay: .05,

    backgroundColor: undefined,
    panelColor: "#000000",
    textColor: "#FFFFFF",
};

const CONT_ICON_DATA = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAGCAYAAAD68A/GAAAAAXNSR0IArs4c6QAAADNJREFUCJmNzrENACAMA0E/++/8NAhRBEg6yyc5SePUoNqwDICnWP04ww1tWOHfUqqf1UwGcw4T9WFhtgAAAABJRU5ErkJggg==";
const STOP_ICON_DATA = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAGCAYAAAD68A/GAAAAAXNSR0IArs4c6QAAACJJREFUCJljZICC/////2fAAhgZGRn////PwIRNEhsYCgoBIkQHCf7H+yAAAAAASUVORK5CYII="

class DialoguePlayback extends EventTarget {
    constructor(width, height) {
        super();
        this.dialogueRendering = createRendering2D(width, height);

        /** @type {DialoguePage[]} */
        this.queuedPages = [];
        this.pagesSeen = 0;
        
        this.options = {};

        // an awaitable that generates a new promise that resolves once no dialogue is active
        /** @type {PromiseLike<void>} */
        this.waiter = {
            then: (resolve, reject) => {
                if (this.empty) {
                    resolve();
                } else {
                    return wait(this, "empty").then(resolve, reject);
                }
            },
        }

        this.clear();
    }

    get empty() {
        return this.currentPage === undefined;
    }

    async load() {
        this.contIcon = imageToRendering2D(await loadImage(CONT_ICON_DATA));
        this.stopIcon = imageToRendering2D(await loadImage(STOP_ICON_DATA));
    }

    clear() {
        this.queuedPages = [];
        this.pagesSeen = 0;

        this.setPage(undefined);
    }

    /** @param {DialoguePage} page */
    setPage(page) {
        const prev = this.currentPage;
        this.currentPage = page;
        this.pageTime = 0;
        this.showGlyphCount = 0;
        this.showGlyphElapsed = 0;
        this.pageGlyphCount = page ? page.glyphs.length : 0;

        this.dispatchEvent(new CustomEvent("next-page", { detail: { prev, next: page } }));

        if (page === undefined) {
            this.dispatchEvent(new CustomEvent("empty"));
        }
    }

    /**
     * @param {string} script 
     * @param {Partial<DialogueOptions>} options 
     * @returns {Promise}
     */
    async queue(script, options={}) {
        const { font, lines } = this.getOptions(options);
        const lineWidth = options.lineWidth ||192;

        script = parseFakedown(script);
        const glyphPages = scriptToPages(script, { font, lineWidth, lineCount: lines });
        const pages = glyphPages.map((glyphs) => ({ glyphs, options }));
        this.queuedPages.push(...pages);
        
        if (this.empty) this.moveToNextPage();
    
        const last = pages[pages.length - 1];
        return new Promise((resolve) => {
            const onNextPage = (event) => {
                const { prev, next } = event.detail;
                if (prev === last) {
                    this.removeEventListener("next-page", onNextPage);
                    resolve();
                }
            };

            this.addEventListener("next-page", onNextPage);
        });
    }

    /** @param {number} dt */
    update(dt) {
        if (this.empty) return;

        this.pageTime += dt;
        this.showGlyphElapsed += dt;

        this.applyStyle();

        const options = this.getOptions(this.currentPage.options);

        while (this.showGlyphElapsed > options.glyphRevealDelay && this.showGlyphCount < this.pageGlyphCount) {
            this.showGlyphElapsed -= options.glyphRevealDelay;
            this.revealNextChar();
            this.applyStyle();
        }
    }

    render() {
        const options = this.getOptions(this.currentPage.options);
        const height = options.padding * 2 
                     + (options.font.lineHeight + options.lineGap) * options.lines;
        const width = (options.lineWidth || 192) + 16;

        fillRendering2D(this.dialogueRendering, options.backgroundColor);
        
        const { width: displayWidth, height: displayHeight } = this.dialogueRendering.canvas;
        const spaceX = displayWidth - width;
        const spaceY = displayHeight - height;
        const margin = options.noMargin ? 0 : Math.ceil(Math.min(spaceX, spaceY) / 2);

        const minX = margin;
        const maxX = displayWidth - margin;

        const minY = margin;
        const maxY = displayHeight - margin;

        const x = Math.floor(minX + (maxX - minX - width ) * options.anchorX);
        const y = Math.floor(minY + (maxY - minY - height) * options.anchorY);

        this.dialogueRendering.fillStyle = options.panelColor;
        this.dialogueRendering.fillRect(x, y, width, height);
        
        this.applyStyle();
        const render = renderPage(
            this.currentPage.glyphs, 
            width, height, 
            options.padding, options.padding,
        );
        this.dialogueRendering.drawImage(render.canvas, x, y);

        if (this.showGlyphCount === this.pageGlyphCount) {
            const prompt = this.queuedPages.length > 0 
                         ? this.contIcon 
                         : this.stopIcon;
            this.dialogueRendering.drawImage(
                recolorMask(prompt, options.textColor).canvas, 
                x+width-options.padding-prompt.canvas.width, 
                y+height-options.lineGap-prompt.canvas.height,
            );
        }
    }

    getOptions(options) {
        return Object.assign({}, DIALOGUE_DEFAULTS, this.options, options);
    }

    revealNextChar() {
        if (this.empty) return;

        this.showGlyphCount = Math.min(this.showGlyphCount + 1, this.pageGlyphCount);
        this.currentPage.glyphs.forEach((glyph, i) => {
            if (i < this.showGlyphCount) glyph.hidden = false;
        });
    }

    revealAll() {
        if (this.empty) return;

        this.showGlyphCount = this.currentPage.glyphs.length;
        this.revealNextChar();
    }

    cancel() {
        this.queuedPages.length = 0;
        this.currentPage = undefined;
    }

    skip() {
        if (this.empty) return;
        
        if (this.showGlyphCount === this.pageGlyphCount) {
            this.moveToNextPage();
        } else {
            this.showGlyphCount = this.pageGlyphCount;
            this.currentPage.glyphs.forEach((glyph) => glyph.hidden = false);
        }
    }

    moveToNextPage() {
        const nextPage = this.queuedPages.shift();
        this.pagesSeen += 1;
        this.setPage(nextPage);
    }

    applyStyle() {
        if (this.empty) return;

        const currentGlyph = this.currentPage.glyphs[this.showGlyphCount];
        const options = this.getOptions(this.currentPage.options);

        if (currentGlyph) {
            if (currentGlyph.styles.has("delay")) {
                this.showCharTime = parseFloat(currentGlyph.styles.get("delay"));
            } else {
                this.showCharTime = this.currentPage.options.glyphRevealDelay;
            }
        }

        this.currentPage.glyphs.forEach((glyph, i) => {
            glyph.fillStyle = glyph.styles.get("clr") ?? options.textColor;

            if (glyph.styles.has("r"))
                glyph.hidden = false;
            if (glyph.styles.has("shk")) 
                glyph.offset = { x: getRandomInt(-1, 2), y: getRandomInt(-1, 2) };
            if (glyph.styles.has("wvy"))
                glyph.offset.y = (Math.sin(i + this.pageTime * 5) * 3) | 0;
            if (glyph.styles.has("rbw")) {
                const h = Math.abs(Math.sin(performance.now() / 600 - i / 8));
                glyph.fillStyle = rgbToHex(HSVToRGB({ h, s: 1, v: 1 }));
            }
        });
    }
}

/**
 * @param {EventTarget} target 
 * @param {string} event 
 * @returns 
 */
 async function wait(target, event) {
    return new Promise((resolve) => {
        target.addEventListener(event, resolve, { once: true });
    });
}

/**
 * Return a random integer at least min and below max. Why is that the normal
 * way to do random ints? I have no idea.
 * @param {number} min 
 * @param {number} max 
 * @returns {number}
 */
 function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min)) + min;
}

    </script>
    <script>// browser saves will be stored under the id "bipsi"
const storage = new maker.ProjectStorage("bipsi");

// type definitions for the structure of bipsi project data. useful for the
// code editor, ignored by the browser 
/**
 * @typedef {Object} BipsiDataSettings
 * @property {string} title
 */

/**
 * @typedef {Object} BipsiDataEventField
 * @property {string} key
 * @property {string} type
 * @property {any} data
 */

/**
 * @typedef {Object} BipsiDataEvent
 * @property {number} id
 * @property {number[]} position
 * @property {BipsiDataEventField[]} fields
 */

/**
 * @typedef {Object} BipsiDataRoom
 * @property {number} id
 * @property {number} palette
 * @property {number[][]} tilemap
 * @property {number[][]} backmap
 * @property {number[][]} foremap
 * @property {number[][]} wallmap
 * @property {BipsiDataEvent[]} events
 */

/**
 * @typedef {Object} BipsiDataTile
 * @property {number} id
 * @property {number[]} frames
 */

/**
 * @typedef {Object} BipsiDataProject
 * @property {BipsiDataRoom[]} rooms
 * @property {string[][]} palettes
 * @property {string} tileset
 * @property {BipsiDataTile[]} tiles
 */

/**
 * @typedef {Object} BipsiDataLocation 
 * @property {number} room
 * @property {number[]} position
 */

/**
 * Return a list of resource ids that a particular bipsi project depends on. 
 * @param {BipsiDataProject} data 
 * @returns {string[]}
 */
function getManifest(data) {
    // all embedded files
    const files = allEvents(data)
        .flatMap((event) => event.fields)
        .filter((field) => field.type === "file")
        .map((field) => field.data);

    // + tileset
    return [data.tileset, ...files];
}

const constants = {
    tileSize: 8,
    roomSize: 16,
    frameInterval: 400,

    tileset: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAAjUlEQVR42u3XMQ4AEBAEwPv/p2kUIo5ScmYqQWU3QsSkDbu5TFBHVoDTfqemAFQKfy3BOs7WKBT+HLQCfBB+dgPcHnoKULAIp7ECfFoA30AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOCFDjCu5xlD93/uAAAAAElFTkSuQmCC",

    wallTile: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAAXNSR0IArs4c6QAAAAlQTFRFAAAA////AAAAc8aDcQAAAAN0Uk5TAP//RFDWIQAAADlJREFUGJVlj0EOACAIw2D/f7QmLAa7XeyaKFgVkfSjum1M9xhDeN24+pjdbVYPwSt8lGMDcnV+DjlaUACpjVBfxAAAAABJRU5ErkJggg==",
    eventTile: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAAXNSR0IArs4c6QAAAAlQTFRFAAAA////AAAAc8aDcQAAAAN0Uk5TAP//RFDWIQAAACVJREFUGJVjYMAATCgAJMCIBCACCHmYAFz3AAugOwzd6eieQwMAdfAA3XvBXggAAAAASUVORK5CYII=",
    startTile: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAAXNSR0IArs4c6QAAAAZQTFRFAAAA////pdmf3QAAAAJ0Uk5TAP9bkSK1AAAAJUlEQVQYlWNgwACMKAC7ALJqnALIqkEETD8lAhiGEnIHIb+gAQBFEACBGFbz9wAAAABJRU5ErkJggg==",

    colorwheelMargin: 12,
}
const TEMP_128 = createRendering2D(128, 128);
const TEMP_256 = createRendering2D(256, 256);

/**
 * @param {HTMLCanvasElement} tileset 
 * @param {number} index 
 */
function getTileCoords(tileset, index) {
    const size = constants.tileSize;
    const columns = tileset.width / size;

    return {
        x: size * (index % columns),
        y: size * Math.floor(index / columns),
        size,
    }
}

/**
 * @param {CanvasRenderingContext2D} tileset 
 * @param {number} tileIndex 
 * @param {CanvasRenderingContext2D} destination 
 * @returns {CanvasRenderingContext2D}
 */
function copyTile(tileset, tileIndex, destination = undefined) {
    const { x, y, size } = getTileCoords(tileset.canvas, tileIndex);
    const tile = copyRendering2D(tileset, destination, { x, y, w: size, h: size });
    return tile;
}

/**
 * @param {CanvasRenderingContext2D} tileset 
 * @param {number} tileIndex
 * @param {CanvasRenderingContext2D} tile 
 */
function drawTile(tileset, tileIndex, tile) {
    const { x, y, size } = getTileCoords(tileset.canvas, tileIndex);
    tileset.clearRect(x, y, size, size);
    tileset.drawImage(tile.canvas, x, y);
}

/**
 * @param {BipsiDataTile[]} tiles 
 * @param {number} frame 
 * @returns {Map<number, number>} 
 */
function makeTileToFrameMap(tiles, frame) {
    /** @type {[number, number][]} */
    return new Map(tiles.map((tile) => [
        tile.id, 
        tile.frames[frame] ?? tile.frames[0],
    ]));
}

/**
 * @param {CanvasRenderingContext2D} destination
 * @param {CanvasRenderingContext2D} tileset 
 * @param {Map<number, number>} tileToFrame 
 * @param {string[]} palette 
 * @param {{ tilemap: number[][], backmap: number[][], foremap: number[][] }} layer 
 */
function drawTilemapLayer(destination, tileset, tileToFrame, palette, { tilemap, backmap, foremap }) {
    drawRecolorLayer(destination, (backg, color, tiles) => {
        for (let ty = 0; ty < 16; ++ty) {
            for (let tx = 0; tx < 16; ++tx) {
                const back = backmap[ty][tx];
                const fore = foremap[ty][tx];
                const tileIndex = tilemap[ty][tx];
                
                const frameIndex = tileToFrame.get(tileIndex);
                const { x, y, size } = getTileCoords(tileset.canvas, frameIndex);

                if (tileIndex === 0) continue;

                backg.fillStyle = palette[back];
                backg.fillRect(tx * size, ty * size, size, size);

                color.fillStyle = palette[fore];
                color.fillRect(tx * size, ty * size, size, size);

                tiles.drawImage(
                    tileset.canvas,
                    x, y, size, size, 
                    tx * size, ty * size, size, size,
                );
            }
        }
    });
}

/**
 * @param {CanvasRenderingContext2D} destination 
 * @param {CanvasRenderingContext2D} tileset 
 * @param {Map<number, number>} tileToFrame 
 * @param {string[]} palette 
 * @param {BipsiDataEvent[]} events 
 */
function drawEventLayer(destination, tileset, tileToFrame, palette, events) {
    const [background, foreground, highlight] = palette;

    drawRecolorLayer(destination, (backg, color, tiles) => {
        events.forEach((event) => {
            const [tx, ty] = event.position;
            const graphicField = oneField(event, "graphic", "tile");
            if (graphicField) {
                const frameIndex = tileToFrame.get(graphicField.data) ?? 0;
                const { x, y, size } = getTileCoords(tileset.canvas, frameIndex);
    
                if (background && !eventIsTagged(event, "transparent")) {
                    backg.fillStyle = background;
                    backg.fillRect(tx * size, ty * size, size, size);
                }

                color.fillStyle = highlight;
                color.fillRect(tx * size, ty * size, size, size);

                tiles.drawImage(
                    tileset.canvas,
                    x, y, size, size, 
                    tx * size, ty * size, size, size,
                );
            }
        });
    });
}

/**
 * @param {CanvasRenderingContext2D} rendering 
 * @param {string[]} palette 
 * @param {BipsiDataRoom} room 
 */
 function drawRoomThumbnail(rendering, palette, room) {
    const [background, foreground, highlight] = palette;
    for (let y = 0; y < 16; ++y) {
        for (let x = 0; x < 16; ++x) {
            const color = room.wallmap[y][x] === 1 ? foreground : background;
            rendering.fillStyle = color;
            rendering.fillRect(x, y, 1, 1);
        }
    }

    rendering.fillStyle = highlight;
    room.events.forEach((event) => {
        const [x, y] = event.position;
        rendering.fillRect(x, y, 1, 1);
    });
}

/**
 * @param {any[][]} map 
 * @param {number} dx 
 * @param {number} dy 
 */
function cycleMap(map, dx, dy) {
    const x = dx > 0 ? dx : 16 + dx;
    const y = dy > 0 ? dy : 16 + dy;
    
    map.push(...map.splice(0, y));
    map.forEach((row) => {
        row.push(...row.splice(0, x));
    });
}

/**
 * @param {BipsiDataEvent[]} events 
 * @param {number} dx
 * @param {number} dy 
 */
function cycleEvents(events, dx, dy) {
    events.forEach((event) => {
        event.position[0] = (event.position[0] + 16 + dx) % 16;
        event.position[1] = (event.position[1] + 16 + dy) % 16;
    });
}

/**
 * @param {BipsiDataEvent[]} events 
 * @param {number} x
 * @param {number} y 
 */
function getEventsAt(events, x, y, ignore=undefined) {
    return events.filter((event) => event.position[0] === x 
                                 && event.position[1] === y 
                                 && event !== ignore);
}

/**
 * @template {{id: number}} T
 * @param {T[]} items 
 * @param {number} id 
 * @returns {T}
 */
function getById(items, id) {
    return items.find((item) => item.id === id);
}

/** 
 * @param {BipsiDataProject} data 
 * @param {number} id
 */
function getRoomById(data, id) {
    return getById(data.rooms, id);
}

/** 
 * @param {BipsiDataProject} data 
 * @param {number} id
 */
function getEventById(data, id) {
    return getById(allEvents(data), id);
}

/** 
 * @param {BipsiDataProject} data 
 * @param {number} id
 */
function getTileById(data, id) {
    return getById(data.tiles, id);
}

/**
 * @param {BipsiDataTile[]} tiles
 */
function findFreeFrame(tiles) {
    const frames = new Set(tiles.flatMap((tile) => tile.frames));
    const max = Math.max(...frames);

    for (let i = 0; i < max; ++i) {
        if (!frames.has(i)) return i;
    }

    return max + 1;
}

/**
 * @param {{id: number}[]} items 
 * @returns {number}
 */
function nextId(items) {
    const max = Math.max(0, ...items.map((item) => item.id ?? 0));
    return max + 1;
}

/** @param {BipsiDataProject} data */
const nextRoomId = (data) => nextId(data.rooms);

/** @param {BipsiDataProject} data */
const nextTileId = (data) => nextId(data.tiles);

/** @param {BipsiDataProject} data */
const nextEventId = (data) => nextId(data.rooms.flatMap((room) => room.events));

/**
 * @param {CanvasRenderingContext2D} tileset 
 * @param {BipsiDataTile[]} tiles
 */
function resizeTileset(tileset, tiles) {
    const maxFrame = Math.max(...tiles.flatMap((tile) => tile.frames));
    const size = 8
    const cols = 16;
    const rows = Math.ceil((maxFrame + 1) / cols);
    resizeRendering2D(tileset, cols * size, rows * size);
}

    </script>
    <script>/**
 * Use inline style to resize canvas to fit its parent, preserving the aspect
 * ratio of its internal dimensions.
 * @param {HTMLCanvasElement} canvas 
 */
 function fitCanvasToParent(canvas) {
    const [tw, th] = [canvas.parentElement.clientWidth, canvas.parentElement.clientHeight];
    const [sw, sh] = [tw / canvas.width, th / canvas.height];
    let scale = Math.min(sw, sh);
    if (canvas.width * scale > 512) scale = Math.floor(scale); 

    canvas.style.setProperty("width", `${canvas.width * scale}px`);
    canvas.style.setProperty("height", `${canvas.height * scale}px`);
}

// async equivalent of Function constructor
const AsyncFunction = Object.getPrototypeOf(async function(){}).constructor

/**
 * @param {any} message 
 * @param {string} origin 
 */
function postMessageParent(message, origin) {
    const target = window.parent ?? window.opener;
    target?.postMessage(message, origin);
}

/**
 * @param {BipsiDataEvent} event 
 * @param {string} key 
 */
function eventIsTagged(event, key) {
    return oneField(event, key, "tag") !== undefined;
}

/**
 * @param {BipsiDataRoom} room
 * @param {number} x 
 * @param {number} y 
 */
function cellIsSolid(room, x, y) {
    const wall = room.wallmap[y][x] > 0;
    const solid = getEventsAt(room.events, x, y).some((event) => eventIsTagged(event, "solid"));
    return solid || wall;
}

/**
 * 
 * @param {BipsiDataEvent} event 
 * @param {string} name 
 * @param {string} type 
 */
function allFields(event, name, type=undefined) {
    return event.fields.filter((field) => field.key === name && field.type === (type ?? field.type));
}

/**
 * 
 * @param {BipsiDataEvent} event
 */
 function allTags(event) {
    return event.fields.filter((field) => field.type === "tag").map((field) => field.key);
}

/**
 * 
 * @param {BipsiDataEvent} event 
 * @param {string} name 
 * @param {string} type 
 */
function oneField(event, name, type=undefined) {
    return event.fields.find((field) => field.key === name && field.type === (type ?? field.type));
}

/**
 * @param {BipsiDataProject} data 
 */
function allEvents(data) {
    return data.rooms.flatMap((room) => room.events);
}

/**
 * @param {BipsiDataProject} data 
 * @param {BipsiDataEvent} event 
 */
function roomFromEvent(data, event) {
    return data.rooms.find((room) => room.events.includes(event));
}

/**
 * @param {BipsiDataProject} data 
 * @param {BipsiDataLocation} location 
 * @returns {BipsiDataEvent?}
 */
function getEventAtLocation(data, location) {
    const room = data.rooms.find((room) => room.id === location.room);
    
    const [x, y] = location.position;
    const [event] = getEventsAt(room.events, x, y);
    return event;
} 

/**
 * @param {BipsiDataProject} data 
 * @param {BipsiDataEvent} event 
 * @returns {BipsiDataLocation}
 */
function getLocationOfEvent(data, event) {
    const room = roomFromEvent(data, event);
    return { room: room.id, position: [...event.position] };
}

/**
 * @param {BipsiDataProject} data 
 * @param {BipsiDataEvent} event 
 * @param {BipsiDataLocation} location
 */
function moveEvent(data, event, location) {
    const room = data.rooms.find((room) => room.id === location.room);
    
    if (!room) throw Error("NO ROOM WITH ID " + location.room);
    
    removeEvent(data, event);
    room.events.push(event);
    event.position = [...location.position];
}

/**
 * @param {BipsiDataProject} data 
 * @param {number} eventId 
 * @param {BipsiDataLocation} location
 */
function moveEventById(data, eventId, location) {
    const event = findEventById(data, eventId);
    moveEvent(data, event, location);
}

/**
 * @param {BipsiDataProject} data 
 * @param {BipsiDataEvent} event
 */
function removeEvent(data, event) {
    const prevRoom = roomFromEvent(data, event);
    arrayDiscard(prevRoom.events, event);
}

function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
}

/**
 * @param {BipsiDataProject} data
 * @param {number} eventId
 */
function findEventById(data, eventId) {
    return allEvents(data).filter((event) => event.id === eventId)[0];
}

function findEventsByTag(data, tag) {
    return allEvents(data).filter((event) => eventIsTagged(event, tag));
}

function findEventByTag(data, tag) {
    return allEvents(data).filter((event) => eventIsTagged(event, tag))[0];
}

/**
 * @param {BipsiDataEvent} event 
 */
function allEventTags(event) {
    return event.fields.filter((field) => field.type === "tag").map((field) => field.key);
}

const ERROR_STYLE = {
    glyphRevealDelay: 0,
    lines: 8,
    panelColor: "#FF0000",
    textColor: "#FFFFFF",

    anchorX: .5, anchorY: .5,
}

const BEHAVIOUR_PAGE_COLOR = `
let color = FIELD(EVENT, "page-color", "text");
if (color) {
    SET_CSS("--page-color", color);
}
`;

const BEHAVIOUR_IMAGES = `
let background = FIELD_OR_LIBRARY("background");
if (background) {
    SHOW_IMAGE("BACKGROUND", background, 1, 0, 0);
} else if (IS_TAGGED(EVENT, "clear-background")) {
    HIDE_IMAGE("BACKGROUND");
}

let foreground = FIELD_OR_LIBRARY("foreground");
if (foreground) {
    SHOW_IMAGE("FOREGROUND", foreground, 2, 0, 0);
} else if (IS_TAGGED(EVENT, "clear-foreground")) {
    HIDE_IMAGE("FOREGROUND");
}

let overlay = FIELD_OR_LIBRARY("overlay");
if (overlay) {
    SHOW_IMAGE("OVERLAY", overlay, 3, 0, 0);
} else if (IS_TAGGED(EVENT, "clear-overlay")) {
    HIDE_IMAGE("OVERLAY");
}
`;

const BEHAVIOUR_MUSIC = `
let music = FIELD_OR_LIBRARY("music");

if (music) {
    PLAY_MUSIC(music);
} else if (IS_TAGGED(EVENT, "stop-music")) {
    STOP_MUSIC();
}
`;

const BEHAVIOUR_TITLE = `
let title = FIELD(EVENT, "title", "dialogue");
if (title) {
    await TITLE(title);
}
`;

const BEHAVIOUR_DIALOGUE = `
let id = FIELD(EVENT, "say-shared-id", "text") ?? "SAY-ITERATORS/" + EVENT_ID(EVENT);
let mode = FIELD(EVENT, "say-mode", "text") ?? "cycle";
let say = SAMPLE(id, mode, FIELDS(EVENT, "say", "dialogue"));
if (say) {
    const sayStyle = FIELD(EVENT, "say-style", "json");
    await SAY(say, sayStyle);
}
`;

const BEHAVIOUR_EXIT = `
let destination = FIELD(EVENT, "exit", "location");
if (destination) {
    MOVE(AVATAR, destination);
}
`;

const BEHAVIOUR_REMOVE = `
if (IS_TAGGED(EVENT, "one-time")) {
    REMOVE(EVENT);
}
`;

const BEHAVIOUR_ENDING = `
let ending = FIELD(EVENT, "ending", "dialogue");
if (ending !== undefined) {
    if (ending.length > 0) {
        await TITLE(ending);
    }
    RESTART();
}
`;

const BEHAVIOUR_SET_AVATAR = `
let graphic = FIELD(EVENT, "set-avatar", "tile");
if (graphic) {
    SET_GRAPHIC(AVATAR, graphic);
}
`;

const BEHAVIOUR_TOUCH_LOCATION = `
let location = FIELD(EVENT, "touch-location", "location");
let event = location ? EVENT_AT(location) : undefined;
if (event) {
    TOUCH(event);
}
`;

const BEHAVIOUR_ADD_BEHAVIOUR = `
ADD_BEHAVIOURS(...FIELDS(EVENT, "add-behaviour", "javascript"));
ADD_BEHAVIOURS(...FIELDS(EVENT, "add-behavior", "javascript"));
`;

const STANDARD_SCRIPTS = [
    BEHAVIOUR_PAGE_COLOR,
    BEHAVIOUR_IMAGES,
    BEHAVIOUR_MUSIC,
    BEHAVIOUR_TITLE,
    BEHAVIOUR_DIALOGUE,
    BEHAVIOUR_EXIT,
    BEHAVIOUR_REMOVE,
    BEHAVIOUR_ENDING, 
    BEHAVIOUR_SET_AVATAR,
    BEHAVIOUR_TOUCH_LOCATION,
    BEHAVIOUR_ADD_BEHAVIOUR,
];

const BACKG_PAGE = createRendering2D(128, 128); 
const COLOR_PAGE = createRendering2D(128, 128);
const TILES_PAGE = createRendering2D(128, 128);

function drawRecolorLayer(destination, render) {
    fillRendering2D(BACKG_PAGE);
    fillRendering2D(COLOR_PAGE);
    fillRendering2D(TILES_PAGE);

    render(BACKG_PAGE, COLOR_PAGE, TILES_PAGE);

    COLOR_PAGE.globalCompositeOperation = "destination-in";
    COLOR_PAGE.drawImage(TILES_PAGE.canvas, 0, 0);
    COLOR_PAGE.globalCompositeOperation = "source-over";
    destination.drawImage(BACKG_PAGE.canvas, 0, 0);
    destination.drawImage(COLOR_PAGE.canvas, 0, 0);
}

class BipsiPlayback extends EventTarget {
    constructor(font) {
        super();
        // home for data of the project we're playing
        this.stateManager = new maker.StateManager(getManifest);
        this.stateBackup = new maker.StateManager(getManifest);
        // final composite of any graphics
        this.rendering = createRendering2D(256, 256);

        this.font = font;
        this.dialoguePlayback = new DialoguePlayback(256, 256);
        this.dialoguePlayback.options.font = font;

        this.time = 0;
        this.frameCount = 0;
        
        this.ready = false;
        this.busy = false;
        this.error = false;

        this.objectURLs = new Map();
        this.imageElements = new Map();

        this.music = document.createElement("audio");
        this.music.loop = true;
        this.autoplay = false;

        this.variables = new Map();
        this.images = new Map();

        this.extra_behaviours = [];
        
        this.choiceExpected = false;
        this.story = undefined
    }

    async init() {
        await this.dialoguePlayback.load();
    }

    async initWithStory(story){
        await this.init()
        this.story = story;
    }

    /** @type {BipsiDataProject} */
    get data() {
        return this.stateManager.present;
    }

    async backup() {
        await this.stateBackup.copyFrom(this.stateManager);
    }

    /**
     * @param {maker.StateManager<BipsiDataProject>} stateManager 
     */
    async copyFrom(stateManager) {
        this.clear();
        await this.stateManager.copyFrom(stateManager);
        await this.backup();
    }

    /**
     * @param {maker.ProjectBundle<BipsiDataProject>} bundle
     */
    async loadBundle(bundle) {
        this.clear();
        await this.stateManager.loadBundle(bundle);
        await this.backup();
    }

    clear() {
        this.ready = false;
        this.error = false;
        this.ended = false;
        this.dialoguePlayback.clear();
        this.variables.clear();

        this.music.removeAttribute("src");
        this.music.pause();
        this.images.clear();
        this.extra_behaviours.length = 0;
        this.imageElements.clear();
        this.objectURLs.forEach((url) => URL.revokeObjectURL(url));
    }

    getFileObjectURL(id) {
        const url = this.objectURLs.get(id) 
                 ?? URL.createObjectURL(this.stateManager.resources.get(id));
        this.objectURLs.set(id, url);
        return url;
    } 

    async getFileImageElement(id) {
        const image = this.imageElements.get(id) ?? await loadImage(this.getFileObjectURL(id));
        this.imageElements.set(id, image);
        return image;
    }

    async restart() {
        this.clear();
        await this.stateManager.copyFrom(this.stateBackup);
        this.start();
    }

    async start() {
        // player avatar is event tagged "is-player" at the beginning of the game
        const avatar = findEventByTag(this.data, "is-player");
        if (avatar === undefined) {
            this.showError("NO EVENT WITH is-player TAG FOUND");
            return;
        }

        // move avatar to last event (render on top)
        const room = roomFromEvent(this.data, avatar);
        moveEvent(this.data, avatar, { room: room.id, position: [...avatar.position] });

        this.avatarId = avatar.id;
        this.libraryId = findEventByTag(this.data, "is-library")?.id;
        this.ready = true;

        const setup = findEventByTag(this.data, "is-setup");
        if (setup) await this.touch(setup);

        // game starts by running the touch behaviour of the player avatar
        //await this.touch(avatar);
        await this.continueStory(avatar);
    }

    async spawnAt(target, event){
        let targetEvent = findEventByTag(this.data, target);
        if(targetEvent){
            let targetLocation = getLocationOfEvent(this.data, targetEvent);
            let spawnedEvent = findEventByTag(this.data, event);
            if(targetLocation && spawnedEvent){
                await moveEvent(this.data, spawnedEvent, targetLocation);
            }
        }
    }

    async sayWithPortrait(text, character, sentiment, options){
        const characterEvent = findEventByTag(this.data, character);
        let portraitShown = false;
        if(characterEvent){
            const sentimentImageId =  oneField(characterEvent, sentiment, "file")?.data
                                   || oneField(characterEvent, "neutral", "file")?.data
            if(sentimentImageId){
                await this.showImage("portrait", sentimentImageId, 3, 104, 102);
                portraitShown = true;
            }
        }
        await this.say(text, options);
        if(portraitShown){
            await this.hideImage("portrait");
        }
    }

    async continueStory(EVENT){
        const story = this.story;
        const AVATAR = findEventByTag(this.data, "is-player");
        const sayStyle = oneField(EVENT, "say-style", "json")?.data 
                        || oneField(AVATAR, "say-style", "json")?.data 
                        || {};

        while(story.canContinue) {
            // Get ink to generate the next paragraph
            var paragraphText = this.story.Continue().trim();
            var tags = story.currentTags;

            if(paragraphText.length > 0){
                const matchSpawn = paragraphText.trim().match(/SPAWN_AT\(([^),\s]*)([\s]*,[\s]*([^)]*)*)*\)/)
                if( matchSpawn ){
                    const target = matchSpawn[1];
                    const event = matchSpawn[3] || "is-player";
                    await this.spawnAt(target.trim(), event.trim());
                }else if(tags.includes("TITLE")){
                    await this.title(paragraphText);
                }else{
                    
                    const portrait = tags.find(t => t.match(/[a-zA-Z0-9]*-[a-zA-Z0-9]*/))
                    if(portrait){
                        const matchPortrait = portrait.match(/([a-zA-Z0-9]*)-([a-zA-Z0-9]*)/);
                        const character = matchPortrait[1];
                        const sentiment = matchPortrait[2];
                        await this.sayWithPortrait(paragraphText, character, sentiment, sayStyle)
                    }else{
                        await this.say(paragraphText, sayStyle);
                    }
                    
                }
            }
        }

        const choices = this.story.currentChoices;

        const autoChoice = choices.find( (choice) => choice.text.startsWith("auto:"))
        if(autoChoice !== undefined){
            story.ChooseChoiceIndex(autoChoice.index)
            return await this.continueStory(EVENT);
        }

        const dialogChoices = choices.filter( (choice) => {
            if(choice.text.startsWith("auto:")) return false;
            if(choice.text.startsWith("tag:")) return false;
            return true;
        })

        const continueStory = this.continueStory.bind(this)

        if(dialogChoices.length > 0){
            const availableArrows = [
                ["ArrowUp", ""],
                ["ArrowDown", ""],
                ["ArrowLeft", ""],
                ["ArrowRight", ""]
            ];
            this.choiceExpected = true;
            const dialogChoicesTexts = [];
            const playback = this;

            const choiceEvents = new Map();
            
            dialogChoices.forEach(function(choice) {
                const [arrowEvent, glyph] = availableArrows.shift();
                if(arrowEvent){
                    dialogChoicesTexts.push(`${glyph} ${choice.text}`);
                    choiceEvents.set(arrowEvent,  () => {
                        console.log(`Making choice ${choice.index}`)
                        story.ChooseChoiceIndex(choice.index);
                    });
                }
            });
            //always display choices at the bottom
            this.say(dialogChoicesTexts.join("\n"), {
                ...sayStyle, 
                ...{"noMargin": true,
                    "anchorX": 0, "anchorY": 1, lineWidth: 40*6,
                    "lines": dialogChoicesTexts.length,
                    }
                })
            const listenToChoice = (event) =>{
                const choiceAction = choiceEvents.get(event.detail)
                if(choiceAction){
                    choiceAction();
                    playback.proceed();
                    playback.removeEventListener('choice', listenToChoice);
                    playback.choiceExpected = false;
                    continueStory(EVENT);
                }
            }
            console.log(`We have ${choiceEvents.size} events to listen to`)
            this.addEventListener("choice", listenToChoice);
        }else{
            this.choiceExpected = false
        }
    }

    update(dt) {
        if (!this.ready) return;

        // tile animation
        this.time += dt;
        while (this.time >= .400) {
            this.frameCount += 1;
            this.time -= .4;
        }

        // dialogue animation
        this.dialoguePlayback.update(dt);
        
        // rerender
        this.render();
    }

    render() {
        // find avatar, current room, current palette
        const avatar = getEventById(this.data, this.avatarId);
        const room = roomFromEvent(this.data, avatar);
        const palette = this.getActivePalette();
        const [background] = palette;
        const tileset = this.stateManager.resources.get(this.data.tileset);

        // find current animation frame for each tile
        const frame = this.frameCount % 2;
        const tileToFrame = makeTileToFrameMap(this.data.tiles, frame);

        // sort images
        const images = Array.from(this.images.values());
        images.sort((a, b) => a.layer - b.layer);
        const images_below_all    = images.filter((image) => image.layer < 1);
        const images_below_events = images.filter((image) => image.layer >= 1 && image.layer < 2);
        const images_above_events = images.filter((image) => image.layer >= 2 && image.layer < 3);
        const images_above_all    = images.filter((image) => image.layer >= 3);

        fillRendering2D(this.rendering);
        fillRendering2D(TEMP_128, background);
        images_below_all.forEach(({ image, x, y }) => TEMP_128.drawImage(image, x, y));
        drawTilemapLayer(TEMP_128, tileset, tileToFrame, palette, room);
        images_below_events.forEach(({ image, x, y }) => TEMP_128.drawImage(image, x, y));
        drawEventLayer(TEMP_128, tileset, tileToFrame, palette, room.events);
        images_above_events.forEach(({ image, x, y }) => TEMP_128.drawImage(image, x, y));

        // upscale tilemaps to display area
        this.rendering.drawImage(TEMP_128.canvas, 0, 0, 256, 256);

        // render dialogue box if necessary
        if (!this.dialoguePlayback.empty) {
            // change default dialogue position based on avatar position
            const top = avatar.position[1] >= 8;
            this.dialoguePlayback.options.anchorY = top ? 0 : 1;

            // redraw dialogue and copy to display area
            this.dialoguePlayback.render();
            this.rendering.drawImage(this.dialoguePlayback.dialogueRendering.canvas, 0, 0);
        }
        
        fillRendering2D(TEMP_128);
        images_above_all.forEach(({ image, x, y }) => TEMP_128.drawImage(image, x, y));
        this.rendering.drawImage(TEMP_128.canvas, 0, 0, 256, 256);

        if (this.ended) {
            fillRendering2D(this.rendering);
        }

        // signal, to anyone listening, that rendering happened
        this.dispatchEvent(new CustomEvent("render"));
    }

    end() {
        this.ended = true;
    }

    log(...data) {
        this.dispatchEvent(new CustomEvent("log", { detail: data }));
        window.parent.postMessage({ type: "log", data });
    }

    setVariable(key, value) {
        this.variables.set(key, value);
        this.sendVariables();
    }

    sendVariables() {
        try {
            window.parent.postMessage({ type: "variables", data: this.variables });
        } catch (e) {
            this.log("> CAN'T TRACK VARIABLES (COMPLEX VALUE)");
        }
    }

    async proceed() {
        if (!this.ready) return;

        if (this.ended) {
            this.restart();
        }

        this.dialoguePlayback.skip();

        if (this.autoplay) {
            this.music.play();
            this.autoplay = false;
        }
    }

    async title(script, options={}) {
        const [background] = this.getActivePalette();
        options = { anchorY: .5, backgroundColor: background, ...options };
        return this.say(script, options);
    }

    async say(script, options={}) {
        this.log(`> SAYING "${script}"`);
        script = replaceVariables(script, this.variables);
        await this.dialoguePlayback.queue(script, options);
    }

    async move(dx, dy) {
        if (this.ended) this.proceed();
        if (!this.ready || !this.dialoguePlayback.empty || this.busy || this.ended) return;

        this.busy = true;

        const avatar = getEventById(this.data, this.avatarId);
        const room = roomFromEvent(this.data, avatar);

        // determine move destination
        const [px, py] = avatar.position;
        const [tx, ty] = [px+dx, py+dy];

        // is the movement stopped by the room edge or solid cells?
        const bounded = tx < 0 || tx >= 16 || ty < 0 || ty >= 16;
        const blocked = bounded ? false : cellIsSolid(room, tx, ty);

        // if not, then update avatar position
        if (!blocked && !bounded) avatar.position = [tx, ty];

        // find if there's an event that should be touched. prefer an event at
        // the cell the avatar tried to move into but settle for the cell 
        // they're already standing on otherwise
        const [fx, fy] = avatar.position;
        const [event0] = getEventsAt(room.events, tx, ty, avatar);
        const [event1] = getEventsAt(room.events, fx, fy, avatar);
        const event = event0 ?? event1;

        // if there was such an event, touch it
        if (event) await this.touch(event);

        this.busy = false;
    }

    eventDebugInfo(event) {
        const tags = allEventTags(event).join(", ");
        const info = tags.length > 0 ? `(tags: ${tags}) ` : "";
        return `${info}@ ${event.position}`;
    }

    /**
     * @param {BipsiDataEvent} event 
     */
    async touch(event) {
        this.log(`> TOUCHING EVENT ${this.eventDebugInfo(event)}`);

        const touch = oneField(event, "touch", "javascript")?.data;

        const tags = allTags(event);

        // do we have a choice that can be triggered by this event ?
        const choices = this.story.currentChoices
        const taggedChoice = choices.find(choice => {
            if(choice.text.substr(0,4) == "tag:"){
                const tagvalue = choice.text.substr(4).trim();
                if(tags.includes(tagvalue)) return true
                return false;
            }
            return false;
        })

        if (touch !== undefined) {
            await this.runJS(event, touch);
        }else if(taggedChoice !== undefined){
            this.story.ChooseChoiceIndex(taggedChoice.index)
            await this.continueStory(event);
        } else {
            await standardEventTouch(this, event);
        }
    }

    async runJS(event, js) {
        const defines = generateScriptingDefines(this, event);
        const names = Object.keys(defines).join(", ");
        const preamble = `const { ${names} } = COMMANDS;\n`;

        try {
            const script = new AsyncFunction("COMMANDS", preamble + js);
            await script(defines);
        } catch (e) {
            const long = `> SCRIPT ERROR "${e}"\n---\n${js}\n---`;
            this.log(long);

            const error = `SCRIPT ERROR:\n${e}`;
            this.showError(error);
        }
    }

    playMusic(src) {
        const playing = !this.music.paused;
        this.music.src = src;
        this.autoplay = true;
        if (playing) this.music.play();
    }

    stopMusic() {
        this.music.pause();
        this.autoplay = false;
    }

    setBackground(image) {
        this.background = image;
    }
    
    async showImage(imageID, fileID, layer, x, y) {
        const image = await this.getFileImageElement(fileID);
        this.images.set(imageID, { image, layer, x, y });
    }

    hideImage(imageID) {
        this.images.delete(imageID);
    }

    showError(text) {
        this.error = true;
        this.dialoguePlayback.clear();
        this.dialoguePlayback.queue(text, ERROR_STYLE);
        this.dialoguePlayback.skip();
        this.dialoguePlayback.render();
        this.rendering.drawImage(this.dialoguePlayback.dialogueRendering.canvas, 0, 0);
        this.dispatchEvent(new CustomEvent("render"));
    }

    getActivePalette() {
        const avatar = getEventById(this.data, this.avatarId);
        const room = roomFromEvent(this.data, avatar);
        const palette = this.data.palettes[room.palette];
        return palette;
    }
}

/**
 * @param {BipsiPlayback} playback 
 * @param {BipsiDataEvent} event 
 * @returns {Promise}
 */
async function standardEventTouch(playback, event) {
    for (let script of STANDARD_SCRIPTS) {
        await playback.runJS(event, script);
    }

    for (let script of playback.extra_behaviours) {
        await playback.runJS(event, script);
    }
}

function sample(playback, id, type, values) {
    let iterator = playback.variables.get(id);

    if (iterator === undefined) {
        iterator = ITERATOR_FUNCS[type](values);
        playback.variables.set(id, iterator);
    }

    return iterator.next()?.value;
}

const ITERATOR_FUNCS = {
    "shuffle": makeShuffleIterator,
    "cycle": makeCycleIterator,
    "sequence": makeSequenceIterator,
}

function* makeShuffleIterator(values) {
    values = [...values];
    while (values.length > 0) {
        shuffleArray(values);
        for (let value of values) {
            yield value;
        }
    }
}

function* makeCycleIterator(values) {
    values = [...values];
    while (values.length > 0) {
        for (let value of values) {
            yield value;
        }
    }
}

function* makeSequenceIterator(values) {
    values = [...values];
    for (let value of values) {
        yield value;
    }
    while (values.length > 0) {
        yield values[values.length - 1];
    }
}

/**
 * @param {BipsiPlayback} playback 
 * @param {BipsiDataEvent} event 
 * @returns {Promise}
 */
async function runEventRemove(playback, event) {
    if (eventIsTagged(event, "one-time")) {
        removeEvent(playback.data, event);
    }
}

function fakedownToTag(text, fd, tag) {
    const pattern = new RegExp(`${fd}([^${fd}]+)${fd}`, 'g');
    return text.replace(pattern, `{+${tag}}$1{-${tag}}`);
}

function parseFakedown(text) {
    text = fakedownToTag(text, '##', 'shk');
    text = fakedownToTag(text, '~~', 'wvy');
    text = fakedownToTag(text, '==', 'rbw');
    text = fakedownToTag(text, '__', 'r');
    return text;
}

/**
 * @param {BipsiDataEvent} event 
 * @param {string} name 
 * @param {string?} type 
 */
function clearFields(event, name, type=undefined) {
    const fields = allFields(event, name, type);
    fields.forEach((field) => arrayDiscard(event.fields, field));
}

/**
 * @param {BipsiDataEvent} event 
 * @param {string} name 
 * @param {string} type 
 * @param {any[]} values
 */
function replaceFields(event, name, type, ...values) {
    clearFields(event, name, type);
    values.forEach((value) => {
        event.fields.push({
            key: name,
            type,
            data: value,
        });
    });
}

function replace(format) {
    const values = Array.prototype.slice.call(arguments, 1);
    return format.replace(/\[\s*(\d+)\s*\]/g, (match, index) => values[index] ?? match);
};

function replaceVariables(text, variables) {
    return text.replace(/\[\[([^\]]+)\]\]/g, (match, key) => variables.get(key) ?? match);
}

const WALK_DIRECTIONS = {
    "L": [-1,  0],
    "R": [ 1,  0],
    "U": [ 0, -1],
    "D": [ 0,  1],
    "<": [-1,  0],
    ">": [ 1,  0],
    "^": [ 0, -1],
    "v": [ 0,  1],
}

/**
 * @param {BipsiPlayback} playback 
 * @param {BipsiDataEvent} event 
 */
function generateScriptingDefines(playback, event) {
    // edit here to add new scripting functions
    const defines = {};
    
    defines.PLAYBACK = playback;
    defines.AVATAR = getEventById(playback.data, playback.avatarId);
    defines.LIBRARY = getEventById(playback.data, playback.libraryId);
    defines.EVENT = event;
    defines.PALETTE = playback.getActivePalette();

    defines.DO_STANDARD = () => standardEventTouch(playback, event);

    defines.SET_FIELDS = (event, name, type, ...values) => replaceFields(event, name, type, ...values);
    defines.FIELD = (event, name, type=undefined) => oneField(event, name, type)?.data;
    defines.FIELDS = (event, name, type=undefined) => allFields(event, name, type).map((field) => field.data);
    
    defines.IS_TAGGED = (event, name) => eventIsTagged(event, name);
    defines.TAG = (event, name) => replaceFields(event, name, "tag", true);
    defines.UNTAG = (event, name) => clearFields(event, name, "tag");

    defines.SET_GRAPHIC = (event, tile) => replaceFields(event, "graphic", "tile", tile);

    defines.WALK = async (event, sequence, delay=.4, wait=.4) => {
        const dirs = Array.from(sequence);
        for (const dir of dirs) {
            if (dir === ".") {
                await sleep(wait * 1000);
            } else {
                let [x, y] = event.position;
                const [dx, dy] = WALK_DIRECTIONS[dir];
                x = Math.max(0, Math.min(15, x + dx));
                y = Math.max(0, Math.min(15, y + dy));
                event.position = [x, y];
                await sleep(delay * 1000);
            }
        }
    };
    defines.MOVE = (event, location) => moveEvent(playback.data, event, location);
    defines.REMOVE = (event) => removeEvent(playback.data, event);

    defines.TOUCH = (event) => playback.touch(event);
    defines.EVENT_AT = (location) => getEventAtLocation(playback.data, location);
    defines.LOCATION_OF = (event) => getLocationOfEvent(playback.data, event);
    defines.FIND_EVENTS = (tag) => findEventsByTag(playback.data, tag); 
    defines.FIND_EVENT = (tag) => findEventByTag(playback.data, tag); 

    defines.GET = (key, fallback=undefined) => playback.variables.get(key) ?? fallback;
    defines.SET = (key, value) => playback.setVariable(key, value);

    defines.EVENT_ID = (event) => event.id;

    defines.TEXT_REPLACE = (text, ...values) => replace(text, ...values);

    defines.SAY = async (dialogue, options) => playback.say(dialogue, options);
    defines.SAY_FIELD = async (name, options) => {
        let text = oneField(event, name, "dialogue")?.data ?? `[FIELD MISSING: ${name}]`;
        await playback.say(text, options);
    }

    defines.TITLE = async (dialogue, options) => playback.title(dialogue, options);
    defines.DIALOGUE = playback.dialoguePlayback.waiter;
    defines.DIALOG = defines.DIALOGUE;

    defines.LOG = (...data) => playback.log(...data);
    defines.DELAY = async (seconds) => sleep(seconds * 1000);

    defines.RESTART = () => playback.end();

    defines.SAMPLE = (id, type, ...values) => sample(playback, id, type, ...values);
    defines.SET_CSS = (name, value) => ONE(":root").style.setProperty(name, value);

    defines.RUN_JS = (script, event=defines.EVENT) => playback.runJS(event, script);
    defines.ADD_BEHAVIOURS = (...scripts) => playback.extra_behaviours.push(...scripts);
    
    defines.PLAY_MUSIC = (file) => playback.playMusic(playback.getFileObjectURL(file));
    defines.STOP_MUSIC = () => playback.stopMusic();

    defines.SHOW_IMAGE = (id, file, layer, x, y) => playback.showImage(id, file, layer, x, y);
    defines.HIDE_IMAGE = (id) => playback.hideImage(id);

    defines.FILE_TEXT = (file) => playback.stateManager.resources.get(file).text();

    defines.FIELD_OR_LIBRARY = (field, event=defines.EVENT) => {
        let file = oneField(event, field, "file")?.data;
        let name = oneField(event, field, "text")?.data;

        if (!file && name && defines.LIBRARY) {
            file = oneField(defines.LIBRARY, name, "file")?.data;
        } else if (!file && defines.LIBRARY) {
            file = oneField(defines.LIBRARY, field, "file")?.data;
        }

        return file;
    };

    defines.POST = (message, origin="*") => postMessageParent(message, origin);

    //binksi
    defines.STORY = playback.story;
    defines.SET_INK_VAR = (field, value) => playback.story.variablesState.$(field, value);
    defines.GET_INK_VAR = (field) => playback.story.variablesState.$(field);
    defines.DIVERT_TO = (knot_name) => {
        playback.story.ChoosePathString(knot_name);
        return playback.continueStory(event);
    }

    return defines;
}

    </script>
    <script>/**
 * @param {CanvasRenderingContext2D} destination 
 * @param {CanvasRenderingContext2D} tileset 
 * @param {Map<number, number>} tileToFrame 
 * @param {string[]} palette 
 * @param {BipsiDataRoom} room
 */
 function drawRoomPreview(destination, tileset, tileToFrame, palette, room) {
    const [background] = palette;

    fillRendering2D(destination, background);
    drawTilemapLayer(destination, tileset, tileToFrame, palette, room);
    drawEventLayer(destination, tileset, tileToFrame, palette, room.events);

    room.events.forEach((event) => {
        const [x, y] = event.position;

        destination.fillStyle = "white";
        destination.globalAlpha = .5;
        destination.fillRect(
            x * 8 + 1, y * 8 + 1, 
            6, 6,
        );
    });
    destination.globalAlpha = 1;
}

/**
 * @param {CanvasRenderingContext2D} destination 
 * @param {BipsiPlayback} playback 
 * @param {number} roomId 
 */
function drawRoomPreviewPlayback(destination, playback, roomId) {
    const tileset = playback.stateManager.resources.get(playback.data.tileset);
    const room = getRoomById(playback.data, roomId);
    const palette = playback.data.palettes[room.palette];
    const tileToFrame = makeTileToFrameMap(playback.data.tiles, 0);
    drawRoomPreview(destination, tileset, tileToFrame, palette, room);
}

/**
 * @param {CanvasRenderingContext2D} destination 
 * @param {BipsiPlayback} playback 
 * @param {number} roomId 
 */
 function drawRoomThumbPlayback(destination, playback, roomId) {
    const room = getRoomById(playback.data, roomId);
    const palette = playback.data.palettes[room.palette];
    drawRoomThumbnail(destination, palette, room);
}

async function generateRoomPreviewURL(destination, playback, roomId) {
    drawRoomPreviewPlayback(destination, playback, roomId);
    URL.createObjectURL(await canvasToBlob(destination.canvas));
}

/**
 * @param {BipsiPlayback} playback
 * @returns {[string, number][]}
 */
function recordFrames(playback) {
    const frames = [];
    const temp = createRendering2D(512, 512);

    playback.update(.4);
    temp.drawImage(playback.rendering.canvas, 0, 0, 512, 512);
    frames.push([temp.canvas.toDataURL(), 400]);
    playback.update(.4);
    temp.drawImage(playback.rendering.canvas, 0, 0, 512, 512);
    frames.push([temp.canvas.toDataURL(), 400]);
    
    return frames;
}

    </script>
    <script>!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).inkjs={})}(this,function(a){"use strict";function P(t){return(P="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function m(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}function u(t,e,n){return e&&i(t.prototype,e),n&&i(t,n),t}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&o(t,e)}function r(t){return(r=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function o(t,e){return(o=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function l(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch(t){return!1}}function h(t,e,n){return(h=l()?Reflect.construct:function(t,e,n){var i=[null];i.push.apply(i,e);var r=new(Function.bind.apply(t,i));return n&&o(r,n.prototype),r}).apply(null,arguments)}function c(t){var i="function"==typeof Map?new Map:void 0;return(c=function(t){if(null===t||(e=t,-1===Function.toString.call(e).indexOf("[native code]")))return t;var e;if("function"!=typeof t)throw new TypeError("Super expression must either be null or a function");if(void 0!==i){if(i.has(t))return i.get(t);i.set(t,n)}function n(){return h(t,arguments,r(this).constructor)}return n.prototype=Object.create(t.prototype,{constructor:{value:n,enumerable:!1,writable:!0,configurable:!0}}),o(n,t)})(t)}function f(t,e){return!e||"object"!=typeof e&&"function"!=typeof e?function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t):e}function v(n){var i=l();return function(){var t,e=r(n);return f(this,i?(t=r(this).constructor,Reflect.construct(e,arguments,t)):e.apply(this,arguments))}}function S(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){var n=t&&("undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"]);if(null==n)return;var i,r,a=[],s=!0,o=!1;try{for(n=n.call(t);!(s=(i=n.next()).done)&&(a.push(i.value),!e||a.length!==e);s=!0);}catch(t){o=!0,r=t}finally{try{s||null==n.return||n.return()}finally{if(o)throw r}}return a}(t,e)||p(t,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function d(t){return function(t){if(Array.isArray(t))return y(t)}(t)||function(t){if("undefined"!=typeof Symbol&&null!=t[Symbol.iterator]||null!=t["@@iterator"])return Array.from(t)}(t)||p(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function p(t,e){if(t){if("string"==typeof t)return y(t,e);var n=Object.prototype.toString.call(t).slice(8,-1);return"Object"===n&&t.constructor&&(n=t.constructor.name),"Map"===n||"Set"===n?Array.from(t):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?y(t,e):void 0}}function y(t,e){(null==e||e>t.length)&&(e=t.length);for(var n=0,i=new Array(e);n<e;n++)i[n]=t[n];return i}function pt(t,e){var n="undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(!n){if(Array.isArray(t)||(n=p(t))||e&&t&&"number"==typeof t.length){n&&(t=n);var i=0,r=function(){};return{s:r,n:function(){return i>=t.length?{done:!0}:{done:!1,value:t[i++]}},e:function(t){throw t},f:r}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var a,s=!0,o=!1;return{s:function(){n=n.call(t)},n:function(){var t=n.next();return s=t.done,t},e:function(t){o=!0,a=t},f:function(){try{s||null==n.return||n.return()}finally{if(o)throw a}}}}var t,e,k,n,O=function(){function s(){var t,e,n,i,r;m(this,s),this._components=[],this._componentsString=null,this._isRelative=!1,"string"==typeof arguments[0]?(t=arguments[0],this.componentsString=t):arguments[0]instanceof s.Component&&arguments[1]instanceof s?(e=arguments[0],n=arguments[1],this._components.push(e),this._components=this._components.concat(n._components)):arguments[0]instanceof Array&&(i=arguments[0],r=!!arguments[1],this._components=this._components.concat(i),this._isRelative=r)}return u(s,[{key:"isRelative",get:function(){return this._isRelative}},{key:"componentCount",get:function(){return this._components.length}},{key:"head",get:function(){return 0<this._components.length?this._components[0]:null}},{key:"tail",get:function(){return 2<=this._components.length?new s(this._components.slice(1,this._components.length)):s.self}},{key:"length",get:function(){return this._components.length}},{key:"lastComponent",get:function(){var t=this._components.length-1;return 0<=t?this._components[t]:null}},{key:"containsNamedComponent",get:function(){for(var t=0,e=this._components.length;t<e;t++)if(!this._components[t].isIndex)return!0;return!1}},{key:"GetComponent",value:function(t){return this._components[t]}},{key:"PathByAppendingPath",value:function(t){for(var e=new s,n=0,i=0;i<t._components.length&&t._components[i].isParent;++i)n++;for(var r=0;r<this._components.length-n;++r)e._components.push(this._components[r]);for(var a=n;a<t._components.length;++a)e._components.push(t._components[a]);return e}},{key:"componentsString",get:function(){return null==this._componentsString&&(this._componentsString=this._components.join("."),this.isRelative&&(this._componentsString="."+this._componentsString)),this._componentsString},set:function(t){if(this._components.length=0,this._componentsString=t,null!=this._componentsString&&""!=this._componentsString){"."==this._componentsString[0]&&(this._isRelative=!0,this._componentsString=this._componentsString.substring(1));var e,n=pt(this._componentsString.split("."));try{for(n.s();!(e=n.n()).done;){var i=e.value;/^(\-|\+)?([0-9]+|Infinity)$/.test(i)?this._components.push(new s.Component(parseInt(i))):this._components.push(new s.Component(i))}}catch(t){n.e(t)}finally{n.f()}}}},{key:"toString",value:function(){return this.componentsString}},{key:"Equals",value:function(t){if(null==t)return!1;if(t._components.length!=this._components.length)return!1;if(t.isRelative!=this.isRelative)return!1;for(var e=0,n=t._components.length;e<n;e++)if(!t._components[e].Equals(this._components[e]))return!1;return!0}},{key:"PathByAppendingComponent",value:function(t){var e,n=new s;return(e=n._components).push.apply(e,d(this._components)),n._components.push(t),n}}],[{key:"self",get:function(){var t=new s;return t._isRelative=!0,t}}]),s}();function g(t,e){if(!t)throw void 0!==e&&console.warn(e),console.trace&&console.trace(),new Error("")}function yt(t,e){return t instanceof e?t:null}function mt(t,e){if(t instanceof e)return t;throw new Error("".concat(t," is not of type ").concat(e))}function C(t){return t.hasValidName&&t.name?t:null}function b(t){return void 0===t?null:t}function _(t){return"object"===P(t)&&"function"==typeof t.Equals}O.parentId="^",t=O=O||{},e=function(){function e(t){m(this,e),this.index=-1,this.name=null,"string"==typeof t?this.name=t:this.index=t}return u(e,[{key:"isIndex",get:function(){return 0<=this.index}},{key:"isParent",get:function(){return this.name==t.parentId}},{key:"toString",value:function(){return this.isIndex?this.index.toString():this.name}},{key:"Equals",value:function(t){return null!=t&&t.isIndex==this.isIndex&&(this.isIndex?this.index==t.index:this.name==t.name)}}],[{key:"ToParent",value:function(){return new e(t.parentId)}}]),e}(),t.Component=e,(n=k=k||{}).AssertType=function(t,e,n){g(t instanceof e,n)},n.Assert=g;var w=function(){s(e,c(Error));var t=v(e);function e(){return m(this,e),t.apply(this,arguments)}return e}();function gt(t){throw new w("".concat(t," is null or undefined"))}var T=function(){function t(){m(this,t),this.parent=null,this._debugMetadata=null,this._path=null}return u(t,[{key:"debugMetadata",get:function(){return null===this._debugMetadata&&this.parent?this.parent.debugMetadata:this._debugMetadata},set:function(t){this._debugMetadata=t}},{key:"ownDebugMetadata",get:function(){return this._debugMetadata}},{key:"DebugLineNumberOfPath",value:function(t){if(null===t)return null;var e=this.rootContentContainer;if(e){var n=e.ContentAtPath(t).obj;if(n){var i=n.debugMetadata;if(null!==i)return i.startLineNumber}}return null}},{key:"path",get:function(){if(null==this._path)if(null==this.parent)this._path=new O;else{for(var t=[],e=this,n=yt(e.parent,Ot);null!==n;){var i=C(e);null!=i&&i.hasValidName?t.unshift(new O.Component(i.name)):t.unshift(new O.Component(n.content.indexOf(e))),n=yt((e=n).parent,Ot)}this._path=new O(t)}return this._path}},{key:"ResolvePath",value:function(t){if(null===t)return gt("path");if(t.isRelative){var e=yt(this,Ot);return null===e&&(k.Assert(null!==this.parent,"Can't resolve relative path because we don't have a parent"),e=yt(this.parent,Ot),k.Assert(null!==e,"Expected parent to be a container"),k.Assert(t.GetComponent(0).isParent),t=t.tail),null===e?gt("nearestContainer"):e.ContentAtPath(t)}var n=this.rootContentContainer;return null===n?gt("contentContainer"):n.ContentAtPath(t)}},{key:"ConvertPathToRelative",value:function(t){for(var e=this.path,n=Math.min(t.length,e.length),i=-1,r=0;r<n;++r){var a=e.GetComponent(r),s=t.GetComponent(r);if(!a.Equals(s))break;i=r}if(-1==i)return t;for(var o=e.componentCount-1-i,u=[],l=0;l<o;++l)u.push(O.Component.ToParent());for(var h=i+1;h<t.componentCount;++h)u.push(t.GetComponent(h));return new O(u,!0)}},{key:"CompactPathString",value:function(t){var e=null,n=null;return e=t.isRelative?(n=t.componentsString,this.path.PathByAppendingPath(t).componentsString):(n=this.ConvertPathToRelative(t).componentsString,t.componentsString),n.length<e.length?n:e}},{key:"rootContentContainer",get:function(){for(var t=this;t.parent;)t=t.parent;return yt(t,Ot)}},{key:"Copy",value:function(){throw Error("Not Implemented: Doesn't support copying")}},{key:"SetChild",value:function(t,e,n){t[e]&&(t[e]=null),t[e]=n,t[e]&&(t[e].parent=this)}}]),t}(),St=function(){function e(t){m(this,e),t=void 0!==t?t.toString():"",this.string=t}return u(e,[{key:"Length",get:function(){return this.string.length}},{key:"Append",value:function(t){null!==t&&(this.string+=t)}},{key:"AppendLine",value:function(t){void 0!==t&&this.Append(t),this.string+="\n"}},{key:"AppendFormat",value:function(t){for(var e=arguments.length,n=new Array(1<e?e-1:0),i=1;i<e;i++)n[i-1]=arguments[i];this.string+=t.replace(/{(\d+)}/g,function(t,e){return void 0!==n[e]?n[e]:t})}},{key:"toString",value:function(){return this.string}}]),e}(),kt=function(){function i(){var t,e,n;m(this,i),this.originName=null,this.itemName=null,void 0!==arguments[1]?(t=arguments[0],e=arguments[1],this.originName=t,this.itemName=e):arguments[0]&&(n=arguments[0].toString().split("."),this.originName=n[0],this.itemName=n[1])}return u(i,[{key:"isNull",get:function(){return null==this.originName&&null==this.itemName}},{key:"fullName",get:function(){return(null!==this.originName?this.originName:"?")+"."+this.itemName}},{key:"toString",value:function(){return this.fullName}},{key:"Equals",value:function(t){return t instanceof i&&(t.itemName==this.itemName&&t.originName==this.originName)}},{key:"copy",value:function(){return new i(this.originName,this.itemName)}},{key:"serialized",value:function(){return JSON.stringify({originName:this.originName,itemName:this.itemName})}}],[{key:"Null",get:function(){return new i(null,null)}},{key:"fromSerializedKey",value:function(t){var e=JSON.parse(t);if(!i.isLikeInkListItem(e))return i.Null;return new i(e.originName,e.itemName)}},{key:"isLikeInkListItem",value:function(t){return"object"===P(t)&&(!(!t.hasOwnProperty("originName")||!t.hasOwnProperty("itemName"))&&(("string"==typeof t.originName||null===typeof t.originName)&&("string"==typeof t.itemName||null===typeof t.itemName)))}}]),i}(),Ct=function(){s(l,c(Map));var o=v(l);function l(){var t,e,n=arguments;if(m(this,l),(t=o.call(this,n[0]instanceof l?n[0]:[])).origins=null,t._originNames=[],arguments[0]instanceof l){var i=arguments[0];t._originNames=i.originNames,null!==i.origins&&(t.origins=i.origins.slice())}else if("string"==typeof arguments[0]){var r=arguments[0],a=arguments[1];if(t.SetInitialOriginName(r),null===a.listDefinitions)return f(t,gt("originStory.listDefinitions"));var s=a.listDefinitions.TryListGetDefinition(r,null);if(!s.exists)throw new Error("InkList origin could not be found in story when constructing new list: "+r);if(null===s.result)return f(t,gt("def.result"));t.origins=[s.result]}else{"object"===P(arguments[0])&&arguments[0].hasOwnProperty("Key")&&arguments[0].hasOwnProperty("Value")&&(e=arguments[0],t.Add(e.Key,e.Value))}return t}return u(l,[{key:"AddItem",value:function(t){if(t instanceof kt){var e=t;if(null==e.originName)return void this.AddItem(e.itemName);if(null===this.origins)return gt("this.origins");var n,i=pt(this.origins);try{for(i.s();!(n=i.n()).done;){var r=n.value;if(r.name==e.originName){var a=r.TryGetValueForItem(e,0);if(a.exists)return void this.Add(e,a.result);throw new Error("Could not add the item "+e+" to this list because it doesn't exist in the original list definition in ink.")}}}catch(t){i.e(t)}finally{i.f()}throw new Error("Failed to add item to list because the item was from a new list definition that wasn't previously known to this list. Only items from previously known lists can be used, so that the int value can be found.")}var s=t,o=null;if(null===this.origins)return gt("this.origins");var u,l=pt(this.origins);try{for(l.s();!(u=l.n()).done;){var h=u.value;if(null===s)return gt("itemName");if(h.ContainsItemWithName(s)){if(null!=o)throw new Error("Could not add the item "+s+" to this list because it could come from either "+h.name+" or "+o.name);o=h}}}catch(t){l.e(t)}finally{l.f()}if(null==o)throw new Error("Could not add the item "+s+" to this list because it isn't known to any list definitions previously associated with this list.");var c=new kt(o.name,s),f=o.ValueForItem(c);this.Add(c,f)}},{key:"ContainsItemNamed",value:function(t){var e,n=pt(this);try{for(n.s();!(e=n.n()).done;){var i=S(e.value,1)[0];if(kt.fromSerializedKey(i).itemName==t)return!0}}catch(t){n.e(t)}finally{n.f()}return!1}},{key:"ContainsKey",value:function(t){return this.has(t.serialized())}},{key:"Add",value:function(t,e){var n=t.serialized();if(this.has(n))throw new Error("The Map already contains an entry for ".concat(t));this.set(n,e)}},{key:"Remove",value:function(t){return this.delete(t.serialized())}},{key:"Count",get:function(){return this.size}},{key:"originOfMaxItem",get:function(){if(null==this.origins)return null;var e=this.maxItem.Key.originName,n=null;return this.origins.every(function(t){return t.name!=e||(n=t,!1)}),n}},{key:"originNames",get:function(){if(0<this.Count){null==this._originNames&&0<this.Count?this._originNames=[]:(this._originNames||(this._originNames=[]),this._originNames.length=0);var t,e=pt(this);try{for(e.s();!(t=e.n()).done;){var n=S(t.value,1)[0],i=kt.fromSerializedKey(n);if(null===i.originName)return gt("item.originName");this._originNames.push(i.originName)}}catch(t){e.e(t)}finally{e.f()}}return this._originNames}},{key:"SetInitialOriginName",value:function(t){this._originNames=[t]}},{key:"SetInitialOriginNames",value:function(t){this._originNames=null==t?null:t.slice()}},{key:"maxItem",get:function(){var t,e={Key:kt.Null,Value:0},n=pt(this);try{for(n.s();!(t=n.n()).done;){var i=S(t.value,2),r=i[0],a=i[1],s=kt.fromSerializedKey(r);(e.Key.isNull||a>e.Value)&&(e={Key:s,Value:a})}}catch(t){n.e(t)}finally{n.f()}return e}},{key:"minItem",get:function(){var t,e={Key:kt.Null,Value:0},n=pt(this);try{for(n.s();!(t=n.n()).done;){var i=S(t.value,2),r=i[0],a=i[1],s=kt.fromSerializedKey(r);(e.Key.isNull||a<e.Value)&&(e={Key:s,Value:a})}}catch(t){n.e(t)}finally{n.f()}return e}},{key:"inverse",get:function(){var t=new l;if(null!=this.origins){var e,n=pt(this.origins);try{for(n.s();!(e=n.n()).done;){var i,r=pt(e.value.items);try{for(r.s();!(i=r.n()).done;){var a=S(i.value,2),s=a[0],o=a[1],u=kt.fromSerializedKey(s);this.ContainsKey(u)||t.Add(u,o)}}catch(t){r.e(t)}finally{r.f()}}}catch(t){n.e(t)}finally{n.f()}}return t}},{key:"all",get:function(){var t=new l;if(null!=this.origins){var e,n=pt(this.origins);try{for(n.s();!(e=n.n()).done;){var i,r=pt(e.value.items);try{for(r.s();!(i=r.n()).done;){var a=S(i.value,2),s=a[0],o=a[1],u=kt.fromSerializedKey(s);t.set(u.serialized(),o)}}catch(t){r.e(t)}finally{r.f()}}}catch(t){n.e(t)}finally{n.f()}}return t}},{key:"Union",value:function(t){var e,n=new l(this),i=pt(t);try{for(i.s();!(e=i.n()).done;){var r=S(e.value,2),a=r[0],s=r[1];n.set(a,s)}}catch(t){i.e(t)}finally{i.f()}return n}},{key:"Intersect",value:function(t){var e,n=new l,i=pt(this);try{for(i.s();!(e=i.n()).done;){var r=S(e.value,2),a=r[0],s=r[1];t.has(a)&&n.set(a,s)}}catch(t){i.e(t)}finally{i.f()}return n}},{key:"Without",value:function(t){var e,n=new l(this),i=pt(t);try{for(i.s();!(e=i.n()).done;){var r=S(e.value,1)[0];n.delete(r)}}catch(t){i.e(t)}finally{i.f()}return n}},{key:"Contains",value:function(t){var e,n=pt(t);try{for(n.s();!(e=n.n()).done;){var i=S(e.value,1)[0];if(!this.has(i))return!1}}catch(t){n.e(t)}finally{n.f()}return!0}},{key:"GreaterThan",value:function(t){return 0!=this.Count&&(0==t.Count||this.minItem.Value>t.maxItem.Value)}},{key:"GreaterThanOrEquals",value:function(t){return 0!=this.Count&&(0==t.Count||this.minItem.Value>=t.minItem.Value&&this.maxItem.Value>=t.maxItem.Value)}},{key:"LessThan",value:function(t){return 0!=t.Count&&(0==this.Count||this.maxItem.Value<t.minItem.Value)}},{key:"LessThanOrEquals",value:function(t){return 0!=t.Count&&(0==this.Count||this.maxItem.Value<=t.maxItem.Value&&this.minItem.Value<=t.minItem.Value)}},{key:"MaxAsList",value:function(){return 0<this.Count?new l(this.maxItem):new l}},{key:"MinAsList",value:function(){return 0<this.Count?new l(this.minItem):new l}},{key:"ListWithSubRange",value:function(t,e){if(0==this.Count)return new l;var n=this.orderedItems,i=0,r=Number.MAX_SAFE_INTEGER;Number.isInteger(t)?i=t:t instanceof l&&0<t.Count&&(i=t.minItem.Value),Number.isInteger(e)?r=e:t instanceof l&&0<t.Count&&(r=e.maxItem.Value);var a=new l;a.SetInitialOriginNames(this.originNames);var s,o=pt(n);try{for(o.s();!(s=o.n()).done;){var u=s.value;u.Value>=i&&u.Value<=r&&a.Add(u.Key,u.Value)}}catch(t){o.e(t)}finally{o.f()}return a}},{key:"Equals",value:function(t){if(t instanceof l==!1)return!1;if(t.Count!=this.Count)return!1;var e,n=pt(this);try{for(n.s();!(e=n.n()).done;){var i=S(e.value,1)[0];if(!t.has(i))return!1}}catch(t){n.e(t)}finally{n.f()}return!0}},{key:"orderedItems",get:function(){var t,e=new Array,n=pt(this);try{for(n.s();!(t=n.n()).done;){var i=S(t.value,2),r=i[0],a=i[1],s=kt.fromSerializedKey(r);e.push({Key:s,Value:a})}}catch(t){n.e(t)}finally{n.f()}return e.sort(function(t,e){return null===t.Key.originName?gt("x.Key.originName"):null===e.Key.originName?gt("y.Key.originName"):t.Value==e.Value?t.Key.originName.localeCompare(e.Key.originName):t.Value<e.Value?-1:t.Value>e.Value?1:0}),e}},{key:"toString",value:function(){for(var t=this.orderedItems,e=new St,n=0;n<t.length;n++){0<n&&e.Append(", ");var i=t[n].Key;if(null===i.itemName)return gt("item.itemName");e.Append(i.itemName)}return e.toString()}},{key:"valueOf",value:function(){return NaN}}],[{key:"FromString",value:function(t,e){var n,i=null===(n=e.listDefinitions)||void 0===n?void 0:n.FindSingleItemListWithName(t);if(i)return null===i.value?gt("listValue.value"):new l(i.value);throw new Error("Could not find the InkListItem from the string '"+t+"' to create an InkList because it doesn't exist in the original list definition in ink.")}}]),l}(),bt=function(){s(i,c(Error));var n=v(i);function i(t){var e;return m(this,i),(e=n.call(this,t)).useEndLineNumber=!1,e.message=t,e.name="StoryException",e}return i}();function E(t,e,n){if(null===t)return{result:n,exists:!1};var i=t.get(e);return void 0===i?{result:n,exists:!1}:{result:i,exists:!0}}var N,A,I=function(){s(e,T);var t=v(e);function e(){return m(this,e),t.apply(this,arguments)}return u(e,[{key:"Copy",value:function(){return mt(e.Create(this),T)}},{key:"BadCastException",value:function(t){return new bt("Can't cast "+this.valueObject+" from "+this.valueType+" to "+t)}}],[{key:"Create",value:function(t,e){if(e){if(e===N.Int&&Number.isInteger(Number(t)))return new wt(Number(t));if(e===N.Float&&!isNaN(t))return new F(Number(t))}return"boolean"==typeof t?new x(Boolean(t)):"string"==typeof t?new Tt(String(t)):Number.isInteger(Number(t))?new wt(Number(t)):isNaN(t)?t instanceof O?new Et(mt(t,O)):t instanceof Ct?new Pt(mt(t,Ct)):null:new F(Number(t))}}]),e}(),_t=function(){s(i,I);var n=v(i);function i(t){var e;return m(this,i),(e=n.call(this)).value=t,e}return u(i,[{key:"valueObject",get:function(){return this.value}},{key:"toString",value:function(){return null===this.value?gt("Value.value"):this.value.toString()}}]),i}(),x=function(){s(n,_t);var e=v(n);function n(t){return m(this,n),e.call(this,t||!1)}return u(n,[{key:"isTruthy",get:function(){return Boolean(this.value)}},{key:"valueType",get:function(){return N.Bool}},{key:"Cast",value:function(t){if(null===this.value)return gt("Value.value");if(t==this.valueType)return this;if(t==N.Int)return new wt(this.value?1:0);if(t==N.Float)return new F(this.value?1:0);if(t==N.String)return new Tt(this.value?"true":"false");throw this.BadCastException(t)}},{key:"toString",value:function(){return this.value?"true":"false"}}]),n}(),wt=function(){s(n,_t);var e=v(n);function n(t){return m(this,n),e.call(this,t||0)}return u(n,[{key:"isTruthy",get:function(){return 0!=this.value}},{key:"valueType",get:function(){return N.Int}},{key:"Cast",value:function(t){if(null===this.value)return gt("Value.value");if(t==this.valueType)return this;if(t==N.Bool)return new x(0!==this.value);if(t==N.Float)return new F(this.value);if(t==N.String)return new Tt(""+this.value);throw this.BadCastException(t)}}]),n}(),F=function(){s(n,_t);var e=v(n);function n(t){return m(this,n),e.call(this,t||0)}return u(n,[{key:"isTruthy",get:function(){return 0!=this.value}},{key:"valueType",get:function(){return N.Float}},{key:"Cast",value:function(t){if(null===this.value)return gt("Value.value");if(t==this.valueType)return this;if(t==N.Bool)return new x(0!==this.value);if(t==N.Int)return new wt(this.value);if(t==N.String)return new Tt(""+this.value);throw this.BadCastException(t)}}]),n}(),Tt=function(){s(i,_t);var n=v(i);function i(t){var e;return m(this,i),(e=n.call(this,t||""))._isNewline="\n"==e.value,e._isInlineWhitespace=!0,null===e.value?f(e,gt("Value.value")):(0<e.value.length&&e.value.split("").every(function(t){return" "==t||"\t"==t||(e._isInlineWhitespace=!1)}),e)}return u(i,[{key:"valueType",get:function(){return N.String}},{key:"isTruthy",get:function(){return null===this.value?gt("Value.value"):0<this.value.length}},{key:"isNewline",get:function(){return this._isNewline}},{key:"isInlineWhitespace",get:function(){return this._isInlineWhitespace}},{key:"isNonWhitespace",get:function(){return!this.isNewline&&!this.isInlineWhitespace}},{key:"Cast",value:function(t){if(t==this.valueType)return this;if(t==N.Int){var e=function(t,e){var n=1<arguments.length&&void 0!==e?e:0,i=parseInt(t);return Number.isNaN(i)?{result:n,exists:!1}:{result:i,exists:!0}}(this.value);if(e.exists)return new wt(e.result);throw this.BadCastException(t)}if(t!=N.Float)throw this.BadCastException(t);var n=function(t,e){var n=1<arguments.length&&void 0!==e?e:0,i=parseFloat(t);return Number.isNaN(i)?{result:n,exists:!1}:{result:i,exists:!0}}(this.value);if(n.exists)return new F(n.result);throw this.BadCastException(t)}}]),i}(),Et=function(){s(n,_t);var e=v(n);function n(t){return m(this,n),e.call(this,t)}return u(n,[{key:"valueType",get:function(){return N.DivertTarget}},{key:"targetPath",get:function(){return null===this.value?gt("Value.value"):this.value},set:function(t){this.value=t}},{key:"isTruthy",get:function(){throw new Error("Shouldn't be checking the truthiness of a divert target")}},{key:"Cast",value:function(t){if(t==this.valueType)return this;throw this.BadCastException(t)}},{key:"toString",value:function(){return"DivertTargetValue("+this.targetPath+")"}}]),n}(),W=function(){s(r,_t);var i=v(r);function r(t){var e,n=1<arguments.length&&void 0!==arguments[1]?arguments[1]:-1;return m(this,r),(e=i.call(this,t))._contextIndex=n,e}return u(r,[{key:"contextIndex",get:function(){return this._contextIndex},set:function(t){this._contextIndex=t}},{key:"variableName",get:function(){return null===this.value?gt("Value.value"):this.value},set:function(t){this.value=t}},{key:"valueType",get:function(){return N.VariablePointer}},{key:"isTruthy",get:function(){throw new Error("Shouldn't be checking the truthiness of a variable pointer")}},{key:"Cast",value:function(t){if(t==this.valueType)return this;throw this.BadCastException(t)}},{key:"toString",value:function(){return"VariablePointerValue("+this.variableName+")"}},{key:"Copy",value:function(){return new r(this.variableName,this.contextIndex)}}]),r}(),Pt=function(){s(r,_t);var i=v(r);function r(t,e){var n;return m(this,r),n=i.call(this,null),t||e?t instanceof Ct?n.value=new Ct(t):t instanceof kt&&"number"==typeof e&&(n.value=new Ct({Key:t,Value:e})):n.value=new Ct,n}return u(r,[{key:"isTruthy",get:function(){return null===this.value?gt("this.value"):0<this.value.Count}},{key:"valueType",get:function(){return N.List}},{key:"Cast",value:function(t){if(null===this.value)return gt("Value.value");if(t==N.Int){var e=this.value.maxItem;return e.Key.isNull?new wt(0):new wt(e.Value)}if(t==N.Float){var n=this.value.maxItem;return n.Key.isNull?new F(0):new F(n.Value)}if(t==N.String){var i=this.value.maxItem;return i.Key.isNull?new Tt(""):new Tt(i.Key.toString())}if(t==this.valueType)return this;throw this.BadCastException(t)}}],[{key:"RetainListOriginsForAssignment",value:function(t,e){var n=yt(t,r),i=yt(e,r);return i&&null===i.value?gt("newList.value"):n&&null===n.value?gt("oldList.value"):void(n&&i&&0==i.value.Count&&i.value.SetInitialOriginNames(n.value.originNames))}}]),r}();(A=N=N||{})[A.Bool=-1]="Bool",A[A.Int=0]="Int",A[A.Float=1]="Float",A[A.List=2]="List",A[A.String=3]="String",A[A.DivertTarget=4]="DivertTarget",A[A.VariablePointer=5]="VariablePointer";var V,L,R=function(){function e(){m(this,e),this.obj=null,this.approximate=!1}return u(e,[{key:"correctObj",get:function(){return this.approximate?null:this.obj}},{key:"container",get:function(){return this.obj instanceof Ot?this.obj:null}},{key:"copy",value:function(){var t=new e;return t.obj=this.obj,t.approximate=this.approximate,t}}]),e}(),Ot=function(){s(g,T);var e=v(g);function g(){var t;return m(this,g),(t=e.apply(this,arguments)).name="",t._content=[],t.namedContent=new Map,t.visitsShouldBeCounted=!1,t.turnIndexShouldBeCounted=!1,t.countingAtStartOnly=!1,t._pathToFirstLeafContent=null,t}return u(g,[{key:"hasValidName",get:function(){return null!=this.name&&0<this.name.length}},{key:"content",get:function(){return this._content},set:function(t){this.AddContent(t)}},{key:"namedOnlyContent",get:function(){var t,e=new Map,n=pt(this.namedContent);try{for(n.s();!(t=n.n()).done;){var i=S(t.value,2),r=i[0],a=mt(i[1],T);e.set(r,a)}}catch(t){n.e(t)}finally{n.f()}var s,o=pt(this.content);try{for(o.s();!(s=o.n()).done;){var u=C(s.value);null!=u&&u.hasValidName&&e.delete(u.name)}}catch(t){o.e(t)}finally{o.f()}return 0==e.size&&(e=null),e},set:function(t){var e=this.namedOnlyContent;if(null!=e){var n,i=pt(e);try{for(i.s();!(n=i.n()).done;){var r=S(n.value,1)[0];this.namedContent.delete(r)}}catch(t){i.e(t)}finally{i.f()}}if(null!=t){var a,s=pt(t);try{for(s.s();!(a=s.n()).done;){var o=C(S(a.value,2)[1]);null!=o&&this.AddToNamedContentOnly(o)}}catch(t){s.e(t)}finally{s.f()}}}},{key:"countFlags",get:function(){var t=0;return this.visitsShouldBeCounted&&(t|=g.CountFlags.Visits),this.turnIndexShouldBeCounted&&(t|=g.CountFlags.Turns),this.countingAtStartOnly&&(t|=g.CountFlags.CountStartOnly),t==g.CountFlags.CountStartOnly&&(t=0),t},set:function(t){var e=t;0<(e&g.CountFlags.Visits)&&(this.visitsShouldBeCounted=!0),0<(e&g.CountFlags.Turns)&&(this.turnIndexShouldBeCounted=!0),0<(e&g.CountFlags.CountStartOnly)&&(this.countingAtStartOnly=!0)}},{key:"pathToFirstLeafContent",get:function(){return null==this._pathToFirstLeafContent&&(this._pathToFirstLeafContent=this.path.PathByAppendingPath(this.internalPathToFirstLeafContent)),this._pathToFirstLeafContent}},{key:"internalPathToFirstLeafContent",get:function(){for(var t=[],e=this;e instanceof g;)0<e.content.length&&(t.push(new O.Component(0)),e=e.content[0]);return new O(t)}},{key:"AddContent",value:function(t){if(t instanceof Array){var e,n=pt(t);try{for(n.s();!(e=n.n()).done;){var i=e.value;this.AddContent(i)}}catch(t){n.e(t)}finally{n.f()}}else{var r=t;if(this._content.push(r),r.parent)throw new Error("content is already in "+r.parent);(r.parent=this).TryAddNamedContent(r)}}},{key:"TryAddNamedContent",value:function(t){var e=C(t);null!=e&&e.hasValidName&&this.AddToNamedContentOnly(e)}},{key:"AddToNamedContentOnly",value:function(t){k.AssertType(t,T,"Can only add Runtime.Objects to a Runtime.Container"),(mt(t,T).parent=this).namedContent.set(t.name,t)}},{key:"ContentAtPath",value:function(t,e,n){var i=1<arguments.length&&void 0!==e?e:0,r=2<arguments.length&&void 0!==n?n:-1;-1==r&&(r=t.length);var a=new R;a.approximate=!1;for(var s=this,o=this,u=i;u<r;++u){var l=t.GetComponent(u);if(null==s){a.approximate=!0;break}var h=s.ContentWithPathComponent(l);if(null==h){a.approximate=!0;break}s=yt(o=h,g)}return a.obj=o,a}},{key:"InsertContent",value:function(t,e){if((this.content[e]=t).parent)throw new Error("content is already in "+t.parent);(t.parent=this).TryAddNamedContent(t)}},{key:"AddContentsOfContainer",value:function(t){this.content=this.content.concat(t.content);var e,n=pt(t.content);try{for(n.s();!(e=n.n()).done;){var i=e.value;(i.parent=this).TryAddNamedContent(i)}}catch(t){n.e(t)}finally{n.f()}}},{key:"ContentWithPathComponent",value:function(t){if(t.isIndex)return 0<=t.index&&t.index<this.content.length?this.content[t.index]:null;if(t.isParent)return this.parent;if(null===t.name)return gt("component.name");var e=E(this.namedContent,t.name,null);return e.exists?mt(e.result,T):null}},{key:"BuildStringOfHierarchy",value:function(t,e,n){var i;if(0==arguments.length)return i=new St,this.BuildStringOfHierarchy(i,0,null),i.toString();i=t;var r=e,a=n;function s(){for(var t=0;t<4*r;++t)i.Append(" ")}s(),i.Append("["),this.hasValidName&&i.AppendFormat(" ({0})",this.name),this==a&&i.Append("  <---"),i.AppendLine(),r++;for(var o=0;o<this.content.length;++o){var u=this.content[o];u instanceof g?u.BuildStringOfHierarchy(i,r,a):(s(),u instanceof Tt?(i.Append('"'),i.Append(u.toString().replace("\n","\\n")),i.Append('"')):i.Append(u.toString())),o!=this.content.length-1&&i.Append(","),u instanceof g||u!=a||i.Append("  <---"),i.AppendLine()}var l,h=new Map,c=pt(this.namedContent);try{for(c.s();!(l=c.n()).done;){var f=S(l.value,2),v=f[0],d=f[1];0<=this.content.indexOf(mt(d,T))||h.set(v,d)}}catch(t){c.e(t)}finally{c.f()}if(0<h.size){s(),i.AppendLine("-- named: --");var p,y=pt(h);try{for(y.s();!(p=y.n()).done;){var m=S(p.value,2)[1];k.AssertType(m,g,"Can only print out named Containers"),m.BuildStringOfHierarchy(i,r,a),i.AppendLine()}}catch(t){y.e(t)}finally{y.f()}}r--,s(),i.Append("]")}}]),g}();V=Ot=Ot||{},(L=V.CountFlags||(V.CountFlags={}))[L.Visits=1]="Visits",L[L.Turns=2]="Turns",L[L.CountStartOnly=4]="CountStartOnly";var j,D,Nt,B,G=function(){s(e,T);var t=v(e);function e(){return m(this,e),t.apply(this,arguments)}return u(e,[{key:"toString",value:function(){return"Glue"}}]),e}(),At=function(){s(i,T);var n=v(i);function i(){var t,e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:i.CommandType.NotSet;return m(this,i),(t=n.call(this))._commandType=e,t}return u(i,[{key:"commandType",get:function(){return this._commandType}},{key:"Copy",value:function(){return new i(this.commandType)}},{key:"toString",value:function(){return this.commandType.toString()}}],[{key:"EvalStart",value:function(){return new i(i.CommandType.EvalStart)}},{key:"EvalOutput",value:function(){return new i(i.CommandType.EvalOutput)}},{key:"EvalEnd",value:function(){return new i(i.CommandType.EvalEnd)}},{key:"Duplicate",value:function(){return new i(i.CommandType.Duplicate)}},{key:"PopEvaluatedValue",value:function(){return new i(i.CommandType.PopEvaluatedValue)}},{key:"PopFunction",value:function(){return new i(i.CommandType.PopFunction)}},{key:"PopTunnel",value:function(){return new i(i.CommandType.PopTunnel)}},{key:"BeginString",value:function(){return new i(i.CommandType.BeginString)}},{key:"EndString",value:function(){return new i(i.CommandType.EndString)}},{key:"NoOp",value:function(){return new i(i.CommandType.NoOp)}},{key:"ChoiceCount",value:function(){return new i(i.CommandType.ChoiceCount)}},{key:"Turns",value:function(){return new i(i.CommandType.Turns)}},{key:"TurnsSince",value:function(){return new i(i.CommandType.TurnsSince)}},{key:"ReadCount",value:function(){return new i(i.CommandType.ReadCount)}},{key:"Random",value:function(){return new i(i.CommandType.Random)}},{key:"SeedRandom",value:function(){return new i(i.CommandType.SeedRandom)}},{key:"VisitIndex",value:function(){return new i(i.CommandType.VisitIndex)}},{key:"SequenceShuffleIndex",value:function(){return new i(i.CommandType.SequenceShuffleIndex)}},{key:"StartThread",value:function(){return new i(i.CommandType.StartThread)}},{key:"Done",value:function(){return new i(i.CommandType.Done)}},{key:"End",value:function(){return new i(i.CommandType.End)}},{key:"ListFromInt",value:function(){return new i(i.CommandType.ListFromInt)}},{key:"ListRange",value:function(){return new i(i.CommandType.ListRange)}},{key:"ListRandom",value:function(){return new i(i.CommandType.ListRandom)}}]),i}();j=At=At||{},(D=j.CommandType||(j.CommandType={}))[D.NotSet=-1]="NotSet",D[D.EvalStart=0]="EvalStart",D[D.EvalOutput=1]="EvalOutput",D[D.EvalEnd=2]="EvalEnd",D[D.Duplicate=3]="Duplicate",D[D.PopEvaluatedValue=4]="PopEvaluatedValue",D[D.PopFunction=5]="PopFunction",D[D.PopTunnel=6]="PopTunnel",D[D.BeginString=7]="BeginString",D[D.EndString=8]="EndString",D[D.NoOp=9]="NoOp",D[D.ChoiceCount=10]="ChoiceCount",D[D.Turns=11]="Turns",D[D.TurnsSince=12]="TurnsSince",D[D.Random=13]="Random",D[D.SeedRandom=14]="SeedRandom",D[D.VisitIndex=15]="VisitIndex",D[D.SequenceShuffleIndex=16]="SequenceShuffleIndex",D[D.StartThread=17]="StartThread",D[D.Done=18]="Done",D[D.End=19]="End",D[D.ListFromInt=20]="ListFromInt",D[D.ListRange=21]="ListRange",D[D.ListRandom=22]="ListRandom",D[D.ReadCount=23]="ReadCount",D[D.TOTAL_VALUES=24]="TOTAL_VALUES",(B=Nt=Nt||{})[B.Tunnel=0]="Tunnel",B[B.Function=1]="Function",B[B.FunctionEvaluationFromGame=2]="FunctionEvaluationFromGame";var It=function(){function e(){m(this,e),this.container=null,this.index=-1,2===arguments.length&&(this.container=arguments[0],this.index=arguments[1])}return u(e,[{key:"Resolve",value:function(){return this.index<0?this.container:null==this.container?null:0==this.container.content.length?this.container:this.index>=this.container.content.length?null:this.container.content[this.index]}},{key:"isNull",get:function(){return null==this.container}},{key:"path",get:function(){return this.isNull?null:0<=this.index?this.container.path.PathByAppendingComponent(new O.Component(this.index)):this.container.path}},{key:"toString",value:function(){return this.container?"Ink Pointer -> "+this.container.path.toString()+" -- index "+this.index:"Ink Pointer (null)"}},{key:"copy",value:function(){return new e(this.container,this.index)}}],[{key:"StartOf",value:function(t){return new e(t,0)}},{key:"Null",get:function(){return new e(null,-1)}}]),e}(),xt=function(){s(i,T);var n=v(i);function i(t){var e;return m(this,i),(e=n.call(this))._targetPath=null,e._targetPointer=It.Null,e.variableDivertName=null,e.pushesToStack=!1,e.stackPushType=0,e.isExternal=!1,e.externalArgs=0,e.isConditional=!1,e.pushesToStack=!1,void 0!==t&&(e.pushesToStack=!0,e.stackPushType=t),e}return u(i,[{key:"targetPath",get:function(){var t;return null==this._targetPath||!this._targetPath.isRelative||(t=this.targetPointer.Resolve())&&(this._targetPath=t.path),this._targetPath},set:function(t){this._targetPath=t,this._targetPointer=It.Null}},{key:"targetPointer",get:function(){if(this._targetPointer.isNull){var t=this.ResolvePath(this._targetPath).obj;if(null===this._targetPath)return gt("this._targetPath");if(null===this._targetPath.lastComponent)return gt("this._targetPath.lastComponent");if(this._targetPath.lastComponent.isIndex){if(null===t)return gt("targetObj");this._targetPointer.container=t.parent instanceof Ot?t.parent:null,this._targetPointer.index=this._targetPath.lastComponent.index}else this._targetPointer=It.StartOf(t instanceof Ot?t:null)}return this._targetPointer.copy()}},{key:"targetPathString",get:function(){return null==this.targetPath?null:this.CompactPathString(this.targetPath)},set:function(t){this.targetPath=null==t?null:new O(t)}},{key:"hasVariableTarget",get:function(){return null!=this.variableDivertName}},{key:"Equals",value:function(t){var e=t;return e instanceof i&&this.hasVariableTarget==e.hasVariableTarget&&(this.hasVariableTarget?this.variableDivertName==e.variableDivertName:null===this.targetPath?gt("this.targetPath"):this.targetPath.Equals(e.targetPath))}},{key:"toString",value:function(){if(this.hasVariableTarget)return"Divert(variable: "+this.variableDivertName+")";if(null==this.targetPath)return"Divert(null)";var t=new St,e=this.targetPath.toString();return t.Append("Divert"),this.isConditional&&t.Append("?"),this.pushesToStack&&(this.stackPushType==Nt.Function?t.Append(" function"):t.Append(" tunnel")),t.Append(" -> "),t.Append(this.targetPathString),t.Append(" ("),t.Append(e),t.Append(")"),t.toString()}}]),i}(),M=function(){s(i,T);var n=v(i);function i(){var t,e=!(0<arguments.length&&void 0!==arguments[0])||arguments[0];return m(this,i),(t=n.call(this))._pathOnChoice=null,t.hasCondition=!1,t.hasStartContent=!1,t.hasChoiceOnlyContent=!1,t.isInvisibleDefault=!1,t.onceOnly=!0,t.onceOnly=e,t}return u(i,[{key:"pathOnChoice",get:function(){var t;return null==this._pathOnChoice||!this._pathOnChoice.isRelative||(t=this.choiceTarget)&&(this._pathOnChoice=t.path),this._pathOnChoice},set:function(t){this._pathOnChoice=t}},{key:"choiceTarget",get:function(){return null===this._pathOnChoice?gt("ChoicePoint._pathOnChoice"):this.ResolvePath(this._pathOnChoice).container}},{key:"pathStringOnChoice",get:function(){return null===this.pathOnChoice?gt("ChoicePoint.pathOnChoice"):this.CompactPathString(this.pathOnChoice)},set:function(t){this.pathOnChoice=new O(t)}},{key:"flags",get:function(){var t=0;return this.hasCondition&&(t|=1),this.hasStartContent&&(t|=2),this.hasChoiceOnlyContent&&(t|=4),this.isInvisibleDefault&&(t|=8),this.onceOnly&&(t|=16),t},set:function(t){this.hasCondition=0<(1&t),this.hasStartContent=0<(2&t),this.hasChoiceOnlyContent=0<(4&t),this.isInvisibleDefault=0<(8&t),this.onceOnly=0<(16&t)}},{key:"toString",value:function(){return null===this.pathOnChoice?gt("ChoicePoint.pathOnChoice"):"Choice: -> "+this.pathOnChoice.toString()}}]),i}(),Ft=function(){s(i,T);var n=v(i);function i(){var t,e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:null;return m(this,i),(t=n.call(this)).pathForCount=null,t.name=e,t}return u(i,[{key:"containerForCount",get:function(){return null===this.pathForCount?null:this.ResolvePath(this.pathForCount).container}},{key:"pathStringForCount",get:function(){return null===this.pathForCount?null:this.CompactPathString(this.pathForCount)},set:function(t){this.pathForCount=null===t?null:new O(t)}},{key:"toString",value:function(){return null!=this.name?"var("+this.name+")":"read_count("+this.pathStringForCount+")"}}]),i}(),Wt=function(){s(r,T);var i=v(r);function r(t,e){var n;return m(this,r),(n=i.call(this)).variableName=t||null,n.isNewDeclaration=!!e,n.isGlobal=!1,n}return u(r,[{key:"toString",value:function(){return"VarAssign to "+this.variableName}}]),r}(),Vt=function(){s(e,T);var t=v(e);function e(){return m(this,e),t.apply(this,arguments)}return e}(),Lt=function(){s(f,T);var r=v(f);function f(){var t,e,n,i;return m(this,f),(t=r.call(this))._name=null,t._numberOfParameters=0,t._prototype=null,t._isPrototype=!1,t._operationFuncs=null,0===arguments.length?f.GenerateNativeFunctionsIfNecessary():1===arguments.length?(e=arguments[0],f.GenerateNativeFunctionsIfNecessary(),t.name=e):2===arguments.length&&(n=arguments[0],i=arguments[1],t._isPrototype=!0,t.name=n,t.numberOfParameters=i),t}return u(f,[{key:"name",get:function(){return null===this._name?gt("NativeFunctionCall._name"):this._name},set:function(t){this._name=t,this._isPrototype||(null===f._nativeFunctions?gt("NativeFunctionCall._nativeFunctions"):this._prototype=f._nativeFunctions.get(this._name)||null)}},{key:"numberOfParameters",get:function(){return this._prototype?this._prototype.numberOfParameters:this._numberOfParameters},set:function(t){this._numberOfParameters=t}},{key:"Call",value:function(t){if(this._prototype)return this._prototype.Call(t);if(this.numberOfParameters!=t.length)throw new Error("Unexpected number of parameters");var e,n=!1,i=pt(t);try{for(i.s();!(e=i.n()).done;){var r=e.value;if(r instanceof Vt)throw new bt('Attempting to perform operation on a void value. Did you forget to "return" a value from a function you called here?');r instanceof Pt&&(n=!0)}}catch(t){i.e(t)}finally{i.f()}if(2==t.length&&n)return this.CallBinaryListOperation(t);var a=this.CoerceValuesToSingleType(t),s=a[0].valueType;return s==N.Int||s==N.Float||s==N.String||s==N.DivertTarget||s==N.List?this.CallType(a):null}},{key:"CallType",value:function(t){var e=mt(t[0],_t),n=e.valueType,i=e,r=t.length;if(2!=r&&1!=r)throw new Error("Unexpected number of parameters to NativeFunctionCall: "+t.length);if(null===this._operationFuncs)return gt("NativeFunctionCall._operationFuncs");var a=this._operationFuncs.get(n);if(!a){var s=N[n];throw new bt("Cannot perform operation "+this.name+" on "+s)}if(2==r){var o=mt(t[1],_t),u=a;if(null===i.value||null===o.value)return gt("NativeFunctionCall.Call BinaryOp values");var l=u(i.value,o.value);return _t.Create(l)}var h=a;if(null===i.value)return gt("NativeFunctionCall.Call UnaryOp value");var c=h(i.value);return this.name===f.Int?_t.Create(c,N.Int):this.name===f.Float?_t.Create(c,N.Float):_t.Create(c,e.valueType)}},{key:"CallBinaryListOperation",value:function(t){if(("+"==this.name||"-"==this.name)&&t[0]instanceof Pt&&t[1]instanceof wt)return this.CallListIncrementOperation(t);var e=mt(t[0],_t),n=mt(t[1],_t);if(!("&&"!=this.name&&"||"!=this.name||e.valueType==N.List&&n.valueType==N.List)){if(null===this._operationFuncs)return gt("NativeFunctionCall._operationFuncs");var i=this._operationFuncs.get(N.Int);if(null===i)return gt("NativeFunctionCall.CallBinaryListOperation op");var r=function(t){if("boolean"==typeof t)return t;throw new Error("".concat(t," is not a boolean"))}(i(e.isTruthy?1:0,n.isTruthy?1:0));return new x(r)}if(e.valueType==N.List&&n.valueType==N.List)return this.CallType([e,n]);throw new bt("Can not call use "+this.name+" operation on "+N[e.valueType]+" and "+N[n.valueType])}},{key:"CallListIncrementOperation",value:function(t){var e=mt(t[0],Pt),n=mt(t[1],wt),i=new Ct;if(null===e.value)return gt("NativeFunctionCall.CallListIncrementOperation listVal.value");var r,a=pt(e.value);try{for(a.s();!(r=a.n()).done;){var s=S(r.value,2),o=s[0],u=s[1],l=kt.fromSerializedKey(o);if(null===this._operationFuncs)return gt("NativeFunctionCall._operationFuncs");var h=this._operationFuncs.get(N.Int);if(null===n.value)return gt("NativeFunctionCall.CallListIncrementOperation intVal.value");var c=h(u,n.value),f=null;if(null===e.value.origins)return gt("NativeFunctionCall.CallListIncrementOperation listVal.value.origins");var v,d,p=pt(e.value.origins);try{for(p.s();!(v=p.n()).done;){var y=v.value;if(y.name==l.originName){f=y;break}}}catch(t){p.e(t)}finally{p.f()}null==f||(d=f.TryGetItemWithValue(c,kt.Null)).exists&&i.Add(d.result,c)}}catch(t){a.e(t)}finally{a.f()}return new Pt(i)}},{key:"CoerceValuesToSingleType",value:function(t){var e,n=N.Int,i=null,r=pt(t);try{for(r.s();!(e=r.n()).done;){var a=mt(e.value,_t);a.valueType>n&&(n=a.valueType),a.valueType==N.List&&(i=yt(a,Pt))}}catch(t){r.e(t)}finally{r.f()}var s=[];if(N[n]==N[N.List]){var o,u=pt(t);try{for(u.s();!(o=u.n()).done;){var l=mt(o.value,_t);if(l.valueType==N.List)s.push(l);else{if(l.valueType!=N.Int){var h=N[l.valueType];throw new bt("Cannot mix Lists and "+h+" values in this operation")}var c=parseInt(l.valueObject);if(null===(i=mt(i,Pt)).value)return gt("NativeFunctionCall.CoerceValuesToSingleType specialCaseList.value");var f=i.value.originOfMaxItem;if(null===f)return gt("NativeFunctionCall.CoerceValuesToSingleType list");var v=f.TryGetItemWithValue(c,kt.Null);if(!v.exists)throw new bt("Could not find List item with the value "+c+" in "+f.name);var d=new Pt(v.result,c);s.push(d)}}}catch(t){u.e(t)}finally{u.f()}}else{var p,y=pt(t);try{for(y.s();!(p=y.n()).done;){var m=mt(p.value,_t).Cast(n);s.push(m)}}catch(t){y.e(t)}finally{y.f()}}return s}},{key:"AddOpFuncForType",value:function(t,e){null==this._operationFuncs&&(this._operationFuncs=new Map),this._operationFuncs.set(t,e)}},{key:"toString",value:function(){return'Native "'+this.name+'"'}}],[{key:"CallWithName",value:function(t){return new f(t)}},{key:"CallExistsWithName",value:function(t){return this.GenerateNativeFunctionsIfNecessary(),this._nativeFunctions.get(t)}},{key:"Identity",value:function(t){return t}},{key:"GenerateNativeFunctionsIfNecessary",value:function(){null==this._nativeFunctions&&(this._nativeFunctions=new Map,this.AddIntBinaryOp(this.Add,function(t,e){return t+e}),this.AddIntBinaryOp(this.Subtract,function(t,e){return t-e}),this.AddIntBinaryOp(this.Multiply,function(t,e){return t*e}),this.AddIntBinaryOp(this.Divide,function(t,e){return Math.floor(t/e)}),this.AddIntBinaryOp(this.Mod,function(t,e){return t%e}),this.AddIntUnaryOp(this.Negate,function(t){return-t}),this.AddIntBinaryOp(this.Equal,function(t,e){return t==e}),this.AddIntBinaryOp(this.Greater,function(t,e){return e<t}),this.AddIntBinaryOp(this.Less,function(t,e){return t<e}),this.AddIntBinaryOp(this.GreaterThanOrEquals,function(t,e){return e<=t}),this.AddIntBinaryOp(this.LessThanOrEquals,function(t,e){return t<=e}),this.AddIntBinaryOp(this.NotEquals,function(t,e){return t!=e}),this.AddIntUnaryOp(this.Not,function(t){return 0==t}),this.AddIntBinaryOp(this.And,function(t,e){return 0!=t&&0!=e}),this.AddIntBinaryOp(this.Or,function(t,e){return 0!=t||0!=e}),this.AddIntBinaryOp(this.Max,function(t,e){return Math.max(t,e)}),this.AddIntBinaryOp(this.Min,function(t,e){return Math.min(t,e)}),this.AddIntBinaryOp(this.Pow,function(t,e){return Math.pow(t,e)}),this.AddIntUnaryOp(this.Floor,f.Identity),this.AddIntUnaryOp(this.Ceiling,f.Identity),this.AddIntUnaryOp(this.Int,f.Identity),this.AddIntUnaryOp(this.Float,function(t){return t}),this.AddFloatBinaryOp(this.Add,function(t,e){return t+e}),this.AddFloatBinaryOp(this.Subtract,function(t,e){return t-e}),this.AddFloatBinaryOp(this.Multiply,function(t,e){return t*e}),this.AddFloatBinaryOp(this.Divide,function(t,e){return t/e}),this.AddFloatBinaryOp(this.Mod,function(t,e){return t%e}),this.AddFloatUnaryOp(this.Negate,function(t){return-t}),this.AddFloatBinaryOp(this.Equal,function(t,e){return t==e}),this.AddFloatBinaryOp(this.Greater,function(t,e){return e<t}),this.AddFloatBinaryOp(this.Less,function(t,e){return t<e}),this.AddFloatBinaryOp(this.GreaterThanOrEquals,function(t,e){return e<=t}),this.AddFloatBinaryOp(this.LessThanOrEquals,function(t,e){return t<=e}),this.AddFloatBinaryOp(this.NotEquals,function(t,e){return t!=e}),this.AddFloatUnaryOp(this.Not,function(t){return 0==t}),this.AddFloatBinaryOp(this.And,function(t,e){return 0!=t&&0!=e}),this.AddFloatBinaryOp(this.Or,function(t,e){return 0!=t||0!=e}),this.AddFloatBinaryOp(this.Max,function(t,e){return Math.max(t,e)}),this.AddFloatBinaryOp(this.Min,function(t,e){return Math.min(t,e)}),this.AddFloatBinaryOp(this.Pow,function(t,e){return Math.pow(t,e)}),this.AddFloatUnaryOp(this.Floor,function(t){return Math.floor(t)}),this.AddFloatUnaryOp(this.Ceiling,function(t){return Math.ceil(t)}),this.AddFloatUnaryOp(this.Int,function(t){return Math.floor(t)}),this.AddFloatUnaryOp(this.Float,f.Identity),this.AddStringBinaryOp(this.Add,function(t,e){return t+e}),this.AddStringBinaryOp(this.Equal,function(t,e){return t===e}),this.AddStringBinaryOp(this.NotEquals,function(t,e){return!(t===e)}),this.AddStringBinaryOp(this.Has,function(t,e){return t.includes(e)}),this.AddStringBinaryOp(this.Hasnt,function(t,e){return!t.includes(e)}),this.AddListBinaryOp(this.Add,function(t,e){return t.Union(e)}),this.AddListBinaryOp(this.Subtract,function(t,e){return t.Without(e)}),this.AddListBinaryOp(this.Has,function(t,e){return t.Contains(e)}),this.AddListBinaryOp(this.Hasnt,function(t,e){return!t.Contains(e)}),this.AddListBinaryOp(this.Intersect,function(t,e){return t.Intersect(e)}),this.AddListBinaryOp(this.Equal,function(t,e){return t.Equals(e)}),this.AddListBinaryOp(this.Greater,function(t,e){return t.GreaterThan(e)}),this.AddListBinaryOp(this.Less,function(t,e){return t.LessThan(e)}),this.AddListBinaryOp(this.GreaterThanOrEquals,function(t,e){return t.GreaterThanOrEquals(e)}),this.AddListBinaryOp(this.LessThanOrEquals,function(t,e){return t.LessThanOrEquals(e)}),this.AddListBinaryOp(this.NotEquals,function(t,e){return!t.Equals(e)}),this.AddListBinaryOp(this.And,function(t,e){return 0<t.Count&&0<e.Count}),this.AddListBinaryOp(this.Or,function(t,e){return 0<t.Count||0<e.Count}),this.AddListUnaryOp(this.Not,function(t){return 0==t.Count?1:0}),this.AddListUnaryOp(this.Invert,function(t){return t.inverse}),this.AddListUnaryOp(this.All,function(t){return t.all}),this.AddListUnaryOp(this.ListMin,function(t){return t.MinAsList()}),this.AddListUnaryOp(this.ListMax,function(t){return t.MaxAsList()}),this.AddListUnaryOp(this.Count,function(t){return t.Count}),this.AddListUnaryOp(this.ValueOfList,function(t){return t.maxItem.Value}),this.AddOpToNativeFunc(this.Equal,2,N.DivertTarget,function(t,e){return t.Equals(e)}),this.AddOpToNativeFunc(this.NotEquals,2,N.DivertTarget,function(t,e){return!t.Equals(e)}))}},{key:"AddOpToNativeFunc",value:function(t,e,n,i){if(null===this._nativeFunctions)return gt("NativeFunctionCall._nativeFunctions");var r=this._nativeFunctions.get(t);r||(r=new f(t,e),this._nativeFunctions.set(t,r)),r.AddOpFuncForType(n,i)}},{key:"AddIntBinaryOp",value:function(t,e){this.AddOpToNativeFunc(t,2,N.Int,e)}},{key:"AddIntUnaryOp",value:function(t,e){this.AddOpToNativeFunc(t,1,N.Int,e)}},{key:"AddFloatBinaryOp",value:function(t,e){this.AddOpToNativeFunc(t,2,N.Float,e)}},{key:"AddFloatUnaryOp",value:function(t,e){this.AddOpToNativeFunc(t,1,N.Float,e)}},{key:"AddStringBinaryOp",value:function(t,e){this.AddOpToNativeFunc(t,2,N.String,e)}},{key:"AddListBinaryOp",value:function(t,e){this.AddOpToNativeFunc(t,2,N.List,e)}},{key:"AddListUnaryOp",value:function(t,e){this.AddOpToNativeFunc(t,1,N.List,e)}}]),f}();Lt.Add="+",Lt.Subtract="-",Lt.Divide="/",Lt.Multiply="*",Lt.Mod="%",Lt.Negate="_",Lt.Equal="==",Lt.Greater=">",Lt.Less="<",Lt.GreaterThanOrEquals=">=",Lt.LessThanOrEquals="<=",Lt.NotEquals="!=",Lt.Not="!",Lt.And="&&",Lt.Or="||",Lt.Min="MIN",Lt.Max="MAX",Lt.Pow="POW",Lt.Floor="FLOOR",Lt.Ceiling="CEILING",Lt.Int="INT",Lt.Float="FLOAT",Lt.Has="?",Lt.Hasnt="!?",Lt.Intersect="^",Lt.ListMin="LIST_MIN",Lt.ListMax="LIST_MAX",Lt.All="LIST_ALL",Lt.Count="LIST_COUNT",Lt.ValueOfList="LIST_VALUE",Lt.Invert="LIST_INVERT",Lt._nativeFunctions=null;var J=function(){s(i,T);var n=v(i);function i(t){var e;return m(this,i),(e=n.call(this)).text=t.toString()||"",e}return u(i,[{key:"toString",value:function(){return"# "+this.text}}]),i}(),U=function(){s(n,T);var e=v(n);function n(){var t;return m(this,n),(t=e.apply(this,arguments)).text="",t.index=0,t.threadAtGeneration=null,t.sourcePath="",t.targetPath=null,t.isInvisibleDefault=!1,t.originalThreadIndex=0,t}return u(n,[{key:"pathStringOnChoice",get:function(){return null===this.targetPath?gt("Choice.targetPath"):this.targetPath.toString()},set:function(t){this.targetPath=new O(t)}}]),n}(),q=function(){function n(t,e){m(this,n),this._name=t||"",this._items=null,this._itemNameToValues=e||new Map}return u(n,[{key:"name",get:function(){return this._name}},{key:"items",get:function(){if(null==this._items){this._items=new Map;var t,e=pt(this._itemNameToValues);try{for(e.s();!(t=e.n()).done;){var n=S(t.value,2),i=n[0],r=n[1],a=new kt(this.name,i);this._items.set(a.serialized(),r)}}catch(t){e.e(t)}finally{e.f()}}return this._items}},{key:"ValueForItem",value:function(t){if(!t.itemName)return 0;var e=this._itemNameToValues.get(t.itemName);return void 0!==e?e:0}},{key:"ContainsItem",value:function(t){return!!t.itemName&&(t.originName==this.name&&this._itemNameToValues.has(t.itemName))}},{key:"ContainsItemWithName",value:function(t){return this._itemNameToValues.has(t)}},{key:"TryGetItemWithValue",value:function(t){var e,n=pt(this._itemNameToValues);try{for(n.s();!(e=n.n()).done;){var i=S(e.value,2),r=i[0];if(i[1]==t)return{result:new kt(this.name,r),exists:!0}}}catch(t){n.e(t)}finally{n.f()}return{result:kt.Null,exists:!1}}},{key:"TryGetValueForItem",value:function(t){if(!t.itemName)return{result:0,exists:!1};var e=this._itemNameToValues.get(t.itemName);return e?{result:e,exists:!0}:{result:0,exists:!1}}}]),n}(),K=function(){function c(t){m(this,c),this._lists=new Map,this._allUnambiguousListValueCache=new Map;var e,n=pt(t);try{for(n.s();!(e=n.n()).done;){var i=e.value;this._lists.set(i.name,i);var r,a=pt(i.items);try{for(a.s();!(r=a.n()).done;){var s=S(r.value,2),o=s[0],u=s[1],l=kt.fromSerializedKey(o),h=new Pt(l,u);if(!l.itemName)throw new Error("item.itemName is null or undefined.");this._allUnambiguousListValueCache.set(l.itemName,h),this._allUnambiguousListValueCache.set(l.fullName,h)}}catch(t){a.e(t)}finally{a.f()}}}catch(t){n.e(t)}finally{n.f()}}return u(c,[{key:"lists",get:function(){var t,e=[],n=pt(this._lists);try{for(n.s();!(t=n.n()).done;){var i=S(t.value,2)[1];e.push(i)}}catch(t){n.e(t)}finally{n.f()}return e}},{key:"TryListGetDefinition",value:function(t,e){if(null===t)return{result:e,exists:!1};var n=this._lists.get(t);return n?{result:n,exists:!0}:{result:e,exists:!1}}},{key:"FindSingleItemListWithName",value:function(t){if(null===t)return gt("name");var e=this._allUnambiguousListValueCache.get(t);return void 0!==e?e:null}}]),c}(),z=function(){function E(){m(this,E)}return u(E,null,[{key:"JArrayToRuntimeObjList",value:function(t,e){var n=1<arguments.length&&void 0!==e&&e,i=t.length;n&&i--;for(var r=[],a=0;a<i;a++){var s=t[a],o=this.JTokenToRuntimeObject(s);if(null===o)return gt("runtimeObj");r.push(o)}return r}},{key:"WriteDictionaryRuntimeObjs",value:function(t,e){t.WriteObjectStart();var n,i=pt(e);try{for(i.s();!(n=i.n()).done;){var r=S(n.value,2),a=r[0],s=r[1];t.WritePropertyStart(a),this.WriteRuntimeObject(t,s),t.WritePropertyEnd()}}catch(t){i.e(t)}finally{i.f()}t.WriteObjectEnd()}},{key:"WriteListRuntimeObjs",value:function(t,e){t.WriteArrayStart();var n,i=pt(e);try{for(i.s();!(n=i.n()).done;){var r=n.value;this.WriteRuntimeObject(t,r)}}catch(t){i.e(t)}finally{i.f()}t.WriteArrayEnd()}},{key:"WriteIntDictionary",value:function(t,e){t.WriteObjectStart();var n,i=pt(e);try{for(i.s();!(n=i.n()).done;){var r=S(n.value,2),a=r[0],s=r[1];t.WriteIntProperty(a,s)}}catch(t){i.e(t)}finally{i.f()}t.WriteObjectEnd()}},{key:"WriteRuntimeObject",value:function(t,e){var n=yt(e,Ot);if(n)this.WriteRuntimeContainer(t,n);else{var i=yt(e,xt);if(i){var r,a="->";return i.isExternal?a="x()":i.pushesToStack&&(i.stackPushType==Nt.Function?a="f()":i.stackPushType==Nt.Tunnel&&(a="->t->")),r=i.hasVariableTarget?i.variableDivertName:i.targetPathString,t.WriteObjectStart(),t.WriteProperty(a,r),i.hasVariableTarget&&t.WriteProperty("var",!0),i.isConditional&&t.WriteProperty("c",!0),0<i.externalArgs&&t.WriteIntProperty("exArgs",i.externalArgs),void t.WriteObjectEnd()}var s=yt(e,M);if(s)return t.WriteObjectStart(),t.WriteProperty("*",s.pathStringOnChoice),t.WriteIntProperty("flg",s.flags),void t.WriteObjectEnd();var o=yt(e,x);if(o)t.WriteBool(o.value);else{var u=yt(e,wt);if(u)t.WriteInt(u.value);else{var l=yt(e,F);if(l)t.WriteFloat(l.value);else{var h=yt(e,Tt);if(h)h.isNewline?t.Write("\n",!1):(t.WriteStringStart(),t.WriteStringInner("^"),t.WriteStringInner(h.value),t.WriteStringEnd());else{var c=yt(e,Pt);if(c)this.WriteInkList(t,c);else{var f=yt(e,Et);if(f)return t.WriteObjectStart(),null===f.value?gt("divTargetVal.value"):(t.WriteProperty("^->",f.value.componentsString),void t.WriteObjectEnd());var v=yt(e,W);if(v)return t.WriteObjectStart(),t.WriteProperty("^var",v.value),t.WriteIntProperty("ci",v.contextIndex),void t.WriteObjectEnd();if(yt(e,G))t.Write("<>");else{var d=yt(e,At);if(d)t.Write(E._controlCommandNames[d.commandType]);else{var p=yt(e,Lt);if(p){var y=p.name;return"^"==y&&(y="L^"),void t.Write(y)}var m=yt(e,Ft);if(m){t.WriteObjectStart();var g=m.pathStringForCount;return null!=g?t.WriteProperty("CNT?",g):t.WriteProperty("VAR?",m.name),void t.WriteObjectEnd()}var S=yt(e,Wt);if(S){t.WriteObjectStart();var k=S.isGlobal?"VAR=":"temp=";return t.WriteProperty(k,S.variableName),S.isNewDeclaration||t.WriteProperty("re",!0),void t.WriteObjectEnd()}if(yt(e,Vt))t.Write("void");else{var C=yt(e,J);if(C)return t.WriteObjectStart(),t.WriteProperty("#",C.text),void t.WriteObjectEnd();var b=yt(e,U);if(!b)throw new Error("Failed to convert runtime object to Json token: "+e);this.WriteChoice(t,b)}}}}}}}}}}},{key:"JObjectToDictionaryRuntimeObjs",value:function(t){var e=new Map;for(var n in t)if(t.hasOwnProperty(n)){var i=this.JTokenToRuntimeObject(t[n]);if(null===i)return gt("inkObject");e.set(n,i)}return e}},{key:"JObjectToIntDictionary",value:function(t){var e=new Map;for(var n in t)t.hasOwnProperty(n)&&e.set(n,parseInt(t[n]));return e}},{key:"JTokenToRuntimeObject",value:function(t){if("number"==typeof t&&!isNaN(t)||"boolean"==typeof t)return _t.Create(t);if("string"==typeof t){var e=t.toString(),n=e[0];if("^"==n)return new Tt(e.substring(1));if("\n"==n&&1==e.length)return new Tt("\n");if("<>"==e)return new G;for(var i=0;i<E._controlCommandNames.length;++i){if(e==E._controlCommandNames[i])return new At(i)}if("L^"==e&&(e="^"),Lt.CallExistsWithName(e))return Lt.CallWithName(e);if("->->"==e)return At.PopTunnel();if("~ret"==e)return At.PopFunction();if("void"==e)return new Vt}if("object"===P(t)&&!Array.isArray(t)){var r,a=t;if(a["^->"])return r=a["^->"],new Et(new O(r.toString()));if(a["^var"]){r=a["^var"];var s=new W(r.toString());return"ci"in a&&(r=a.ci,s.contextIndex=parseInt(r)),s}var o=!1,u=!1,l=Nt.Function,h=!1;if((r=a["->"])?o=!0:(r=a["f()"])?(u=o=!0,l=Nt.Function):(r=a["->t->"])?(u=o=!0,l=Nt.Tunnel):(r=a["x()"])&&(u=!(h=o=!0),l=Nt.Function),o){var c=new xt;c.pushesToStack=u,c.stackPushType=l,c.isExternal=h;var f=r.toString();return(r=a.var)?c.variableDivertName=f:c.targetPathString=f,c.isConditional=!!a.c,h&&(r=a.exArgs)&&(c.externalArgs=parseInt(r)),c}if(r=a["*"]){var v=new M;return v.pathStringOnChoice=r.toString(),(r=a.flg)&&(v.flags=parseInt(r)),v}if(r=a["VAR?"])return new Ft(r.toString());if(r=a["CNT?"]){var d=new Ft;return d.pathStringForCount=r.toString(),d}var p=!1,y=!1;if((r=a["VAR="])?y=p=!0:(r=a["temp="])&&(y=!(p=!0)),p){var m=r.toString(),g=!a.re,S=new Wt(m,g);return S.isGlobal=y,S}if(void 0!==a["#"])return r=a["#"],new J(r.toString());if(r=a.list){var k,C,b,_=r,w=new Ct;for(var T in(r=a.origins)&&w.SetInitialOriginNames(r),_){_.hasOwnProperty(T)&&(k=_[T],C=new kt(T),b=parseInt(k),w.Add(C,b))}return new Pt(w)}if(null!=a.originalChoicePath)return this.JObjectToChoice(a)}if(Array.isArray(t))return this.JArrayToContainer(t);if(null==t)return null;throw new Error("Failed to convert token to runtime object: "+JSON.stringify(t))}},{key:"WriteRuntimeContainer",value:function(t,e,n){var i=2<arguments.length&&void 0!==n&&n;if(t.WriteArrayStart(),null===e)return gt("container");var r,a=pt(e.content);try{for(a.s();!(r=a.n()).done;){var s=r.value;this.WriteRuntimeObject(t,s)}}catch(t){a.e(t)}finally{a.f()}var o=e.namedOnlyContent,u=e.countFlags,l=null!=e.name&&!i,h=null!=o||0<u||l;if(h&&t.WriteObjectStart(),null!=o){var c,f=pt(o);try{for(f.s();!(c=f.n()).done;){var v=S(c.value,2),d=v[0],p=yt(v[1],Ot);t.WritePropertyStart(d),this.WriteRuntimeContainer(t,p,!0),t.WritePropertyEnd()}}catch(t){f.e(t)}finally{f.f()}}l&&t.WriteProperty("#n",e.name),h?t.WriteObjectEnd():t.WriteNull(),t.WriteArrayEnd()}},{key:"JArrayToContainer",value:function(t){var e=new Ot;e.content=this.JArrayToRuntimeObjList(t,!0);var n=t[t.length-1];if(null!=n){var i,r,a=new Map;for(var s in n){"#f"==s?e.countFlags=parseInt(n[s]):"#n"==s?e.name=n[s].toString():((r=yt(i=this.JTokenToRuntimeObject(n[s]),Ot))&&(r.name=s),a.set(s,i))}e.namedOnlyContent=a}return e}},{key:"JObjectToChoice",value:function(t){var e=new U;return e.text=t.text.toString(),e.index=parseInt(t.index),e.sourcePath=t.originalChoicePath.toString(),e.originalThreadIndex=parseInt(t.originalThreadIndex),e.pathStringOnChoice=t.targetPath.toString(),e}},{key:"WriteChoice",value:function(t,e){t.WriteObjectStart(),t.WriteProperty("text",e.text),t.WriteIntProperty("index",e.index),t.WriteProperty("originalChoicePath",e.sourcePath),t.WriteIntProperty("originalThreadIndex",e.originalThreadIndex),t.WriteProperty("targetPath",e.pathStringOnChoice),t.WriteObjectEnd()}},{key:"WriteInkList",value:function(t,e){var n=e.value;if(null===n)return gt("rawList");t.WriteObjectStart(),t.WritePropertyStart("list"),t.WriteObjectStart();var i,r=pt(n);try{for(r.s();!(i=r.n()).done;){var a=S(i.value,2),s=a[0],o=a[1],u=kt.fromSerializedKey(s),l=o;if(null===u.itemName)return gt("item.itemName");t.WritePropertyNameStart(),t.WritePropertyNameInner(u.originName?u.originName:"?"),t.WritePropertyNameInner("."),t.WritePropertyNameInner(u.itemName),t.WritePropertyNameEnd(),t.Write(l),t.WritePropertyEnd()}}catch(t){r.e(t)}finally{r.f()}if(t.WriteObjectEnd(),t.WritePropertyEnd(),0==n.Count&&null!=n.originNames&&0<n.originNames.length){t.WritePropertyStart("origins"),t.WriteArrayStart();var h,c=pt(n.originNames);try{for(c.s();!(h=c.n()).done;){var f=h.value;t.Write(f)}}catch(t){c.e(t)}finally{c.f()}t.WriteArrayEnd(),t.WritePropertyEnd()}t.WriteObjectEnd()}},{key:"ListDefinitionsToJToken",value:function(t){var e,n={},i=pt(t.lists);try{for(i.s();!(e=i.n()).done;){var r,a=e.value,s={},o=pt(a.items);try{for(o.s();!(r=o.n()).done;){var u=S(r.value,2),l=u[0],h=u[1],c=kt.fromSerializedKey(l);if(null===c.itemName)return gt("item.itemName");s[c.itemName]=h}}catch(t){o.e(t)}finally{o.f()}n[a.name]=s}}catch(t){i.e(t)}finally{i.f()}return n}},{key:"JTokenToListDefinitions",value:function(t){var e=t,n=[];for(var i in e)if(e.hasOwnProperty(i)){var r,a=i.toString(),s=e[i],o=new Map;for(var u in s){e.hasOwnProperty(i)&&(r=s[u],o.set(u,parseInt(r)))}var l=new q(a,o);n.push(l)}return new K(n)}}]),E}();z._controlCommandNames=function(){var t=[];t[At.CommandType.EvalStart]="ev",t[At.CommandType.EvalOutput]="out",t[At.CommandType.EvalEnd]="/ev",t[At.CommandType.Duplicate]="du",t[At.CommandType.PopEvaluatedValue]="pop",t[At.CommandType.PopFunction]="~ret",t[At.CommandType.PopTunnel]="->->",t[At.CommandType.BeginString]="str",t[At.CommandType.EndString]="/str",t[At.CommandType.NoOp]="nop",t[At.CommandType.ChoiceCount]="choiceCnt",t[At.CommandType.Turns]="turn",t[At.CommandType.TurnsSince]="turns",t[At.CommandType.ReadCount]="readc",t[At.CommandType.Random]="rnd",t[At.CommandType.SeedRandom]="srnd",t[At.CommandType.VisitIndex]="visit",t[At.CommandType.SequenceShuffleIndex]="seq",t[At.CommandType.StartThread]="thread",t[At.CommandType.Done]="done",t[At.CommandType.End]="end",t[At.CommandType.ListFromInt]="listInt",t[At.CommandType.ListRange]="range",t[At.CommandType.ListRandom]="lrnd";for(var e=0;e<At.CommandType.TOTAL_VALUES;++e)if(null==t[e])throw new Error("Control command not accounted for in serialisation");return t}();var H=function(){function s(){if(m(this,s),this._threadCounter=0,this._startOfRoot=It.Null,arguments[0]instanceof a.Story){var t=arguments[0];this._startOfRoot=It.StartOf(t.rootContentContainer),this.Reset()}else{var e=arguments[0];this._threads=[];var n,i=pt(e._threads);try{for(i.s();!(n=i.n()).done;){var r=n.value;this._threads.push(r.Copy())}}catch(t){i.e(t)}finally{i.f()}this._threadCounter=e._threadCounter,this._startOfRoot=e._startOfRoot.copy()}}return u(s,[{key:"elements",get:function(){return this.callStack}},{key:"depth",get:function(){return this.elements.length}},{key:"currentElement",get:function(){var t=this._threads[this._threads.length-1].callstack;return t[t.length-1]}},{key:"currentElementIndex",get:function(){return this.callStack.length-1}},{key:"currentThread",get:function(){return this._threads[this._threads.length-1]},set:function(t){k.Assert(1==this._threads.length,"Shouldn't be directly setting the current thread when we have a stack of them"),this._threads.length=0,this._threads.push(t)}},{key:"canPop",get:function(){return 1<this.callStack.length}},{key:"Reset",value:function(){this._threads=[],this._threads.push(new s.Thread),this._threads[0].callstack.push(new s.Element(Nt.Tunnel,this._startOfRoot))}},{key:"SetJsonToken",value:function(t,e){this._threads.length=0;var n,i=pt(t.threads);try{for(i.s();!(n=i.n()).done;){var r=n.value,a=new s.Thread(r,e);this._threads.push(a)}}catch(t){i.e(t)}finally{i.f()}this._threadCounter=parseInt(t.threadCounter),this._startOfRoot=It.StartOf(e.rootContentContainer)}},{key:"WriteJson",value:function(t){var i=this;t.WriteObject(function(t){t.WritePropertyStart("threads"),t.WriteArrayStart();var e,n=pt(i._threads);try{for(n.s();!(e=n.n()).done;){e.value.WriteJson(t)}}catch(t){n.e(t)}finally{n.f()}t.WriteArrayEnd(),t.WritePropertyEnd(),t.WritePropertyStart("threadCounter"),t.WriteInt(i._threadCounter),t.WritePropertyEnd()})}},{key:"PushThread",value:function(){var t=this.currentThread.Copy();this._threadCounter++,t.threadIndex=this._threadCounter,this._threads.push(t)}},{key:"ForkThread",value:function(){var t=this.currentThread.Copy();return this._threadCounter++,t.threadIndex=this._threadCounter,t}},{key:"PopThread",value:function(){if(!this.canPopThread)throw new Error("Can't pop thread");this._threads.splice(this._threads.indexOf(this.currentThread),1)}},{key:"canPopThread",get:function(){return 1<this._threads.length&&!this.elementIsEvaluateFromGame}},{key:"elementIsEvaluateFromGame",get:function(){return this.currentElement.type==Nt.FunctionEvaluationFromGame}},{key:"Push",value:function(t,e,n){var i=1<arguments.length&&void 0!==e?e:0,r=2<arguments.length&&void 0!==n?n:0,a=new s.Element(t,this.currentElement.currentPointer,!1);a.evaluationStackHeightWhenPushed=i,a.functionStartInOutputStream=r,this.callStack.push(a)}},{key:"CanPop",value:function(t){var e=0<arguments.length&&void 0!==t?t:null;return!!this.canPop&&(null==e||this.currentElement.type==e)}},{key:"Pop",value:function(t){var e=0<arguments.length&&void 0!==t?t:null;if(!this.CanPop(e))throw new Error("Mismatched push/pop in Callstack");this.callStack.pop()}},{key:"GetTemporaryVariableWithName",value:function(t,e){var n=1<arguments.length&&void 0!==e?e:-1;-1==n&&(n=this.currentElementIndex+1);var i=E(this.callStack[n-1].temporaryVariables,t,null);return i.exists?i.result:null}},{key:"SetTemporaryVariable",value:function(t,e,n,i){var r=3<arguments.length&&void 0!==i?i:-1;-1==r&&(r=this.currentElementIndex+1);var a=this.callStack[r-1];if(!n&&!a.temporaryVariables.get(t))throw new Error("Could not find temporary variable to set: "+t);var s=E(a.temporaryVariables,t,null);s.exists&&Pt.RetainListOriginsForAssignment(s.result,e),a.temporaryVariables.set(t,e)}},{key:"ContextForVariableNamed",value:function(t){return this.currentElement.temporaryVariables.get(t)?this.currentElementIndex+1:0}},{key:"ThreadWithIndex",value:function(e){var t=this._threads.filter(function(t){if(t.threadIndex==e)return t});return 0<t.length?t[0]:null}},{key:"callStack",get:function(){return this.currentThread.callstack}},{key:"callStackTrace",get:function(){for(var t=new St,e=0;e<this._threads.length;e++){var n=this._threads[e],i=e==this._threads.length-1;t.AppendFormat("=== THREAD {0}/{1} {2}===\n",e+1,this._threads.length,i?"(current) ":"");for(var r=0;r<n.callstack.length;r++){n.callstack[r].type==Nt.Function?t.Append("  [FUNCTION] "):t.Append("  [TUNNEL] ");var a=n.callstack[r].currentPointer;if(!a.isNull){if(t.Append("<SOMEWHERE IN "),null===a.container)return gt("pointer.container");t.Append(a.container.path.toString()),t.AppendLine(">")}}}return t.toString()}}]),s}();!function(t){var y=function(){function i(t,e){var n=2<arguments.length&&void 0!==arguments[2]&&arguments[2];m(this,i),this.evaluationStackHeightWhenPushed=0,this.functionStartInOutputStream=0,this.currentPointer=e.copy(),this.inExpressionEvaluation=n,this.temporaryVariables=new Map,this.type=t}return u(i,[{key:"Copy",value:function(){var t=new i(this.type,this.currentPointer,this.inExpressionEvaluation);return t.temporaryVariables=new Map(this.temporaryVariables),t.evaluationStackHeightWhenPushed=this.evaluationStackHeightWhenPushed,t.functionStartInOutputStream=this.functionStartInOutputStream,t}}]),i}();t.Element=y;var e=function(){function p(){if(m(this,p),this.threadIndex=0,this.previousPointer=It.Null,this.callstack=[],arguments[0]&&arguments[1]){var t=arguments[0],e=arguments[1];this.threadIndex=parseInt(t.threadIndex);var n,i=pt(t.callstack);try{for(i.s();!(n=i.n()).done;){var r=n.value,a=parseInt(r.type),s=It.Null,o=void 0,u=r.cPath;if(void 0!==u){o=u.toString();var l=e.ContentAtPath(new O(o));if(s.container=l.container,s.index=parseInt(r.idx),null==l.obj)throw new Error("When loading state, internal story location couldn't be found: "+o+". Has the story changed since this save data was created?");if(l.approximate){if(null===s.container)return gt("pointer.container");e.Warning("When loading state, exact internal story location couldn't be found: '"+o+"', so it was approximated to '"+s.container.path.toString()+"' to recover. Has the story changed since this save data was created?")}}var h=!!r.exp,c=new y(a,s,h),f=r.temp;void 0!==f?c.temporaryVariables=z.JObjectToDictionaryRuntimeObjs(f):c.temporaryVariables.clear(),this.callstack.push(c)}}catch(t){i.e(t)}finally{i.f()}var v,d=t.previousContentObject;void 0!==d&&(v=new O(d.toString()),this.previousPointer=e.PointerAtPath(v))}}return u(p,[{key:"Copy",value:function(){var t=new p;t.threadIndex=this.threadIndex;var e,n=pt(this.callstack);try{for(n.s();!(e=n.n()).done;){var i=e.value;t.callstack.push(i.Copy())}}catch(t){n.e(t)}finally{n.f()}return t.previousPointer=this.previousPointer.copy(),t}},{key:"WriteJson",value:function(t){t.WriteObjectStart(),t.WritePropertyStart("callstack"),t.WriteArrayStart();var e,n=pt(this.callstack);try{for(n.s();!(e=n.n()).done;){var i=e.value;if(t.WriteObjectStart(),!i.currentPointer.isNull){if(null===i.currentPointer.container)return gt("el.currentPointer.container");t.WriteProperty("cPath",i.currentPointer.container.path.componentsString),t.WriteIntProperty("idx",i.currentPointer.index)}t.WriteProperty("exp",i.inExpressionEvaluation),t.WriteIntProperty("type",i.type),0<i.temporaryVariables.size&&(t.WritePropertyStart("temp"),z.WriteDictionaryRuntimeObjs(t,i.temporaryVariables),t.WritePropertyEnd()),t.WriteObjectEnd()}}catch(t){n.e(t)}finally{n.f()}if(t.WriteArrayEnd(),t.WritePropertyEnd(),t.WriteIntProperty("threadIndex",this.threadIndex),!this.previousPointer.isNull){var r=this.previousPointer.Resolve();if(null===r)return gt("this.previousPointer.Resolve()");t.WriteProperty("previousContentObject",r.path.toString())}t.WriteObjectEnd()}}]),p}();t.Thread=e}(H=H||{});var X=function(){function l(t,e){m(this,l),this.variableChangedEventCallbacks=[],this.patch=null,this._batchObservingVariableChanges=!1,this._defaultGlobalVariables=new Map,this._changedVariablesForBatchObs=new Set,this._globalVariables=new Map,this._callStack=t,this._listDefsOrigin=e;try{return new Proxy(this,{get:function(t,e){return e in t?t[e]:t.$(e)},set:function(t,e,n){return e in t?t[e]=n:t.$(e,n),!0}})}catch(t){}}return u(l,[{key:"variableChangedEvent",value:function(t,e){var n,i=pt(this.variableChangedEventCallbacks);try{for(i.s();!(n=i.n()).done;){(0,n.value)(t,e)}}catch(t){i.e(t)}finally{i.f()}}},{key:"batchObservingVariableChanges",get:function(){return this._batchObservingVariableChanges},set:function(t){if(this._batchObservingVariableChanges=t)this._changedVariablesForBatchObs=new Set;else if(null!=this._changedVariablesForBatchObs){var e,n=pt(this._changedVariablesForBatchObs);try{for(n.s();!(e=n.n()).done;){var i=e.value,r=this._globalVariables.get(i);r?this.variableChangedEvent(i,r):gt("currentValue")}}catch(t){n.e(t)}finally{n.f()}this._changedVariablesForBatchObs=null}}},{key:"callStack",get:function(){return this._callStack},set:function(t){this._callStack=t}},{key:"$",value:function(t,e){if(void 0===e){var n=null;return null!==this.patch&&(n=this.patch.TryGetGlobal(t,null)).exists?n.result.valueObject:(void 0===(n=this._globalVariables.get(t))&&(n=this._defaultGlobalVariables.get(t)),void 0!==n?n.valueObject:null)}if(void 0===this._defaultGlobalVariables.get(t))throw new bt("Cannot assign to a variable ("+t+") that hasn't been declared in the story");var i=_t.Create(e);if(null==i)throw null==e?new Error("Cannot pass null to VariableState"):new Error("Invalid value passed to VariableState: "+e.toString());this.SetGlobal(t,i)}},{key:"ApplyPatch",value:function(){if(null===this.patch)return gt("this.patch");var t,e=pt(this.patch.globals);try{for(e.s();!(t=e.n()).done;){var n=S(t.value,2),i=n[0],r=n[1];this._globalVariables.set(i,r)}}catch(t){e.e(t)}finally{e.f()}if(null!==this._changedVariablesForBatchObs){var a,s=pt(this.patch.changedVariables);try{for(s.s();!(a=s.n()).done;){var o=a.value;this._changedVariablesForBatchObs.add(o)}}catch(t){s.e(t)}finally{s.f()}}this.patch=null}},{key:"SetJsonToken",value:function(t){this._globalVariables.clear();var e,n=pt(this._defaultGlobalVariables);try{for(n.s();!(e=n.n()).done;){var i=S(e.value,2),r=i[0],a=i[1],s=t[r];if(void 0!==s){var o=z.JTokenToRuntimeObject(s);if(null===o)return gt("tokenInkObject");this._globalVariables.set(r,o)}else this._globalVariables.set(r,a)}}catch(t){n.e(t)}finally{n.f()}}},{key:"WriteJson",value:function(t){t.WriteObjectStart();var e,n=pt(this._globalVariables);try{for(n.s();!(e=n.n()).done;){var i=S(e.value,2),r=i[0],a=i[1],s=r,o=a;if(l.dontSaveDefaultValues&&this._defaultGlobalVariables.has(s)){var u=this._defaultGlobalVariables.get(s);if(this.RuntimeObjectsEqual(o,u))continue}t.WritePropertyStart(s),z.WriteRuntimeObject(t,o),t.WritePropertyEnd()}}catch(t){n.e(t)}finally{n.f()}t.WriteObjectEnd()}},{key:"RuntimeObjectsEqual",value:function(t,e){if(null===t)return gt("obj1");if(null===e)return gt("obj2");if(t.constructor!==e.constructor)return!1;var n=yt(t,x);if(null!==n)return n.value===mt(e,x).value;var i=yt(t,wt);if(null!==i)return i.value===mt(e,wt).value;var r=yt(t,F);if(null!==r)return r.value===mt(e,F).value;var a=yt(t,_t),s=yt(e,_t);if(null!==a&&null!==s)return _(a.valueObject)&&_(s.valueObject)?a.valueObject.Equals(s.valueObject):a.valueObject===s.valueObject;throw new Error("FastRoughDefinitelyEquals: Unsupported runtime object type: "+t.constructor.name)}},{key:"GetVariableWithName",value:function(t,e){var n=1<arguments.length&&void 0!==e?e:-1,i=this.GetRawVariableWithName(t,n),r=yt(i,W);return null!==r&&(i=this.ValueAtVariablePointer(r)),i}},{key:"TryGetDefaultVariableValue",value:function(t){var e=E(this._defaultGlobalVariables,t,null);return e.exists?e.result:null}},{key:"GlobalVariableExistsWithName",value:function(t){return this._globalVariables.has(t)||null!==this._defaultGlobalVariables&&this._defaultGlobalVariables.has(t)}},{key:"GetRawVariableWithName",value:function(t,e){if(0==e||-1==e){var n=null;if(null!==this.patch&&(n=this.patch.TryGetGlobal(t,null)).exists)return n.result;if((n=E(this._globalVariables,t,null)).exists)return n.result;if(null!==this._defaultGlobalVariables&&(n=E(this._defaultGlobalVariables,t,null)).exists)return n.result;if(null===this._listDefsOrigin)return gt("VariablesState._listDefsOrigin");var i=this._listDefsOrigin.FindSingleItemListWithName(t);if(i)return i}return this._callStack.GetTemporaryVariableWithName(t,e)}},{key:"ValueAtVariablePointer",value:function(t){return this.GetVariableWithName(t.variableName,t.contextIndex)}},{key:"Assign",value:function(t,e){var n=t.variableName;if(null===n)return gt("name");var i=-1,r=!1,r=t.isNewDeclaration?t.isGlobal:this.GlobalVariableExistsWithName(n);if(t.isNewDeclaration){var a=yt(e,W);null!==a&&(e=this.ResolveVariablePointer(a))}else for(var s=null;null!=(s=yt(this.GetRawVariableWithName(n,i),W))&&(n=s.variableName,r=0==(i=s.contextIndex)),null!=s;);r?this.SetGlobal(n,e):this._callStack.SetTemporaryVariable(n,e,t.isNewDeclaration,i)}},{key:"SnapshotDefaultGlobals",value:function(){this._defaultGlobalVariables=new Map(this._globalVariables)}},{key:"RetainListOriginsForAssignment",value:function(t,e){var n=mt(t,Pt),i=mt(e,Pt);n.value&&i.value&&0==i.value.Count&&i.value.SetInitialOriginNames(n.value.originNames)}},{key:"SetGlobal",value:function(t,e){var n=null;if(null===this.patch&&(n=E(this._globalVariables,t,null)),null!==this.patch&&((n=this.patch.TryGetGlobal(t,null)).exists||(n=E(this._globalVariables,t,null))),Pt.RetainListOriginsForAssignment(n.result,e),null===t)return gt("variableName");if(null!==this.patch?this.patch.SetGlobal(t,e):this._globalVariables.set(t,e),null!==this.variableChangedEvent&&null!==n&&e!==n.result)if(this.batchObservingVariableChanges){if(null===this._changedVariablesForBatchObs)return gt("this._changedVariablesForBatchObs");null!==this.patch?this.patch.AddChangedVariable(t):null!==this._changedVariablesForBatchObs&&this._changedVariablesForBatchObs.add(t)}else this.variableChangedEvent(t,e)}},{key:"ResolveVariablePointer",value:function(t){var e=t.contextIndex;-1==e&&(e=this.GetContextIndexOfVariableNamed(t.variableName));var n=yt(this.GetRawVariableWithName(t.variableName,e),W);return null!=n?n:new W(t.variableName,e)}},{key:"GetContextIndexOfVariableNamed",value:function(t){return this.GlobalVariableExistsWithName(t)?0:this._callStack.currentElementIndex}},{key:"ObserveVariableChange",value:function(t){this.variableChangedEventCallbacks.push(t)}}]),l}();X.dontSaveDefaultValues=!0;var Rt=function(){function e(t){m(this,e),this.seed=t%2147483647,this.seed<=0&&(this.seed+=2147483646)}return u(e,[{key:"next",value:function(){return this.seed=16807*this.seed%2147483647}},{key:"nextFloat",value:function(){return(this.next()-1)/2147483646}}]),e}(),$=function(){function e(){var t;m(this,e),this._changedVariables=new Set,this._visitCounts=new Map,this._turnIndices=new Map,1===arguments.length&&null!==arguments[0]?(t=arguments[0],this._globals=new Map(t._globals),this._changedVariables=new Set(t._changedVariables),this._visitCounts=new Map(t._visitCounts),this._turnIndices=new Map(t._turnIndices)):(this._globals=new Map,this._changedVariables=new Set,this._visitCounts=new Map,this._turnIndices=new Map)}return u(e,[{key:"globals",get:function(){return this._globals}},{key:"changedVariables",get:function(){return this._changedVariables}},{key:"visitCounts",get:function(){return this._visitCounts}},{key:"turnIndices",get:function(){return this._turnIndices}},{key:"TryGetGlobal",value:function(t,e){return null!==t&&this._globals.has(t)?{result:this._globals.get(t),exists:!0}:{result:e,exists:!1}}},{key:"SetGlobal",value:function(t,e){this._globals.set(t,e)}},{key:"AddChangedVariable",value:function(t){return this._changedVariables.add(t)}},{key:"TryGetVisitCount",value:function(t,e){return this._visitCounts.has(t)?{result:this._visitCounts.get(t),exists:!0}:{result:e,exists:!1}}},{key:"SetVisitCount",value:function(t,e){this._visitCounts.set(t,e)}},{key:"SetTurnIndex",value:function(t,e){this._turnIndices.set(t,e)}},{key:"TryGetTurnIndex",value:function(t,e){return this._turnIndices.has(t)?{result:this._turnIndices.get(t),exists:!0}:{result:e,exists:!1}}}]),e}(),Y=function(){function e(){m(this,e)}return u(e,null,[{key:"TextToDictionary",value:function(t){return new e.Reader(t).ToDictionary()}},{key:"TextToArray",value:function(t){return new e.Reader(t).ToArray()}}]),e}();!function(n){var t=function(){function e(t){m(this,e),this._rootObject=JSON.parse(t)}return u(e,[{key:"ToDictionary",value:function(){return this._rootObject}},{key:"ToArray",value:function(){return this._rootObject}}]),e}();n.Reader=t;var e=function(){function t(){m(this,t),this._currentPropertyName=null,this._currentString=null,this._stateStack=[],this._collectionStack=[],this._propertyNameStack=[],this._jsonObject=null}return u(t,[{key:"WriteObject",value:function(t){this.WriteObjectStart(),t(this),this.WriteObjectEnd()}},{key:"WriteObjectStart",value:function(){this.StartNewObject(!0);var t,e={};this.state===n.Writer.State.Property?(this.Assert(null!==this.currentCollection),this.Assert(null!==this.currentPropertyName),t=this._propertyNameStack.pop(),this.currentCollection[t]=e):this.state===n.Writer.State.Array?(this.Assert(null!==this.currentCollection),this.currentCollection.push(e)):(this.Assert(this.state===n.Writer.State.None),this._jsonObject=e),this._collectionStack.push(e),this._stateStack.push(new n.Writer.StateElement(n.Writer.State.Object))}},{key:"WriteObjectEnd",value:function(){this.Assert(this.state===n.Writer.State.Object),this._collectionStack.pop(),this._stateStack.pop()}},{key:"WriteProperty",value:function(t,e){this.WritePropertyStart(t),e instanceof Function?e(this):this.Write(e),this.WritePropertyEnd()}},{key:"WriteIntProperty",value:function(t,e){this.WritePropertyStart(t),this.WriteInt(e),this.WritePropertyEnd()}},{key:"WriteFloatProperty",value:function(t,e){this.WritePropertyStart(t),this.WriteFloat(e),this.WritePropertyEnd()}},{key:"WritePropertyStart",value:function(t){this.Assert(this.state===n.Writer.State.Object),this._propertyNameStack.push(t),this.IncrementChildCount(),this._stateStack.push(new n.Writer.StateElement(n.Writer.State.Property))}},{key:"WritePropertyEnd",value:function(){this.Assert(this.state===n.Writer.State.Property),this.Assert(1===this.childCount),this._stateStack.pop()}},{key:"WritePropertyNameStart",value:function(){this.Assert(this.state===n.Writer.State.Object),this.IncrementChildCount(),this._currentPropertyName="",this._stateStack.push(new n.Writer.StateElement(n.Writer.State.Property)),this._stateStack.push(new n.Writer.StateElement(n.Writer.State.PropertyName))}},{key:"WritePropertyNameEnd",value:function(){this.Assert(this.state===n.Writer.State.PropertyName),this.Assert(null!==this._currentPropertyName),this._propertyNameStack.push(this._currentPropertyName),this._currentPropertyName=null,this._stateStack.pop()}},{key:"WritePropertyNameInner",value:function(t){this.Assert(this.state===n.Writer.State.PropertyName),this.Assert(null!==this._currentPropertyName),this._currentPropertyName+=t}},{key:"WriteArrayStart",value:function(){this.StartNewObject(!0);var t,e=[];this.state===n.Writer.State.Property?(this.Assert(null!==this.currentCollection),this.Assert(null!==this.currentPropertyName),t=this._propertyNameStack.pop(),this.currentCollection[t]=e):this.state===n.Writer.State.Array?(this.Assert(null!==this.currentCollection),this.currentCollection.push(e)):(this.Assert(this.state===n.Writer.State.None),this._jsonObject=e),this._collectionStack.push(e),this._stateStack.push(new n.Writer.StateElement(n.Writer.State.Array))}},{key:"WriteArrayEnd",value:function(){this.Assert(this.state===n.Writer.State.Array),this._collectionStack.pop(),this._stateStack.pop()}},{key:"Write",value:function(t){null!==t?(this.StartNewObject(!1),this._addToCurrentObject(t)):console.error("Warning: trying to write a null string")}},{key:"WriteBool",value:function(t){null!==t&&(this.StartNewObject(!1),this._addToCurrentObject(t))}},{key:"WriteInt",value:function(t){null!==t&&(this.StartNewObject(!1),this._addToCurrentObject(Math.floor(t)))}},{key:"WriteFloat",value:function(t){null!==t&&(this.StartNewObject(!1),t==Number.POSITIVE_INFINITY?this._addToCurrentObject(34e37):t==Number.NEGATIVE_INFINITY?this._addToCurrentObject(-34e37):isNaN(t)?this._addToCurrentObject(0):this._addToCurrentObject(t))}},{key:"WriteNull",value:function(){this.StartNewObject(!1),this._addToCurrentObject(null)}},{key:"WriteStringStart",value:function(){this.StartNewObject(!1),this._currentString="",this._stateStack.push(new n.Writer.StateElement(n.Writer.State.String))}},{key:"WriteStringEnd",value:function(){this.Assert(this.state==n.Writer.State.String),this._stateStack.pop(),this._addToCurrentObject(this._currentString),this._currentString=null}},{key:"WriteStringInner",value:function(t){this.Assert(this.state===n.Writer.State.String),null!==t?this._currentString+=t:console.error("Warning: trying to write a null string")}},{key:"ToString",value:function(){return null===this._jsonObject?"":JSON.stringify(this._jsonObject)}},{key:"StartNewObject",value:function(t){t?this.Assert(this.state===n.Writer.State.None||this.state===n.Writer.State.Property||this.state===n.Writer.State.Array):this.Assert(this.state===n.Writer.State.Property||this.state===n.Writer.State.Array),this.state===n.Writer.State.Property&&this.Assert(0===this.childCount),this.state!==n.Writer.State.Array&&this.state!==n.Writer.State.Property||this.IncrementChildCount()}},{key:"state",get:function(){return 0<this._stateStack.length?this._stateStack[this._stateStack.length-1].type:n.Writer.State.None}},{key:"childCount",get:function(){return 0<this._stateStack.length?this._stateStack[this._stateStack.length-1].childCount:0}},{key:"currentCollection",get:function(){return 0<this._collectionStack.length?this._collectionStack[this._collectionStack.length-1]:null}},{key:"currentPropertyName",get:function(){return 0<this._propertyNameStack.length?this._propertyNameStack[this._propertyNameStack.length-1]:null}},{key:"IncrementChildCount",value:function(){this.Assert(0<this._stateStack.length);var t=this._stateStack.pop();t.childCount++,this._stateStack.push(t)}},{key:"Assert",value:function(t){if(!t)throw Error("Assert failed while writing JSON")}},{key:"_addToCurrentObject",value:function(t){this.Assert(null!==this.currentCollection),this.state===n.Writer.State.Array?(this.Assert(Array.isArray(this.currentCollection)),this.currentCollection.push(t)):this.state===n.Writer.State.Property&&(this.Assert(!Array.isArray(this.currentCollection)),this.Assert(null!==this.currentPropertyName),this.currentCollection[this.currentPropertyName]=t,this._propertyNameStack.pop())}}]),t}();n.Writer=e,function(t){var e;(e=t.State||(t.State={}))[e.None=0]="None",e[e.Object=1]="Object",e[e.Array=2]="Array",e[e.Property=3]="Property",e[e.PropertyName=4]="PropertyName",e[e.String=5]="String";t.StateElement=function t(e){m(this,t),this.type=n.Writer.State.None,this.childCount=0,this.type=e}}(e=n.Writer||(n.Writer={}))}(Y=Y||{});var Q,Z,tt,et,nt=function(){function r(){m(this,r);var t,e,n=arguments[0],i=arguments[1];this.name=n,this.callStack=new H(i),arguments[2]?(t=arguments[2],this.callStack.SetJsonToken(t.callstack,i),this.outputStream=z.JArrayToRuntimeObjList(t.outputStream),this.currentChoices=z.JArrayToRuntimeObjList(t.currentChoices),void 0!==(e=t.choiceThreads)&&this.LoadFlowChoiceThreads(e,i)):(this.outputStream=[],this.currentChoices=[])}return u(r,[{key:"WriteJson",value:function(t){var r=this;t.WriteObjectStart(),t.WriteProperty("callstack",function(t){return r.callStack.WriteJson(t)}),t.WriteProperty("outputStream",function(t){return z.WriteListRuntimeObjs(t,r.outputStream)});var e,n=!1,i=pt(this.currentChoices);try{for(i.s();!(e=i.n()).done;){var a=e.value;if(null===a.threadAtGeneration)return gt("c.threadAtGeneration");a.originalThreadIndex=a.threadAtGeneration.threadIndex,null===this.callStack.ThreadWithIndex(a.originalThreadIndex)&&(n||(n=!0,t.WritePropertyStart("choiceThreads"),t.WriteObjectStart()),t.WritePropertyStart(a.originalThreadIndex),a.threadAtGeneration.WriteJson(t),t.WritePropertyEnd())}}catch(t){i.e(t)}finally{i.f()}n&&(t.WriteObjectEnd(),t.WritePropertyEnd()),t.WriteProperty("currentChoices",function(t){t.WriteArrayStart();var e,n=pt(r.currentChoices);try{for(n.s();!(e=n.n()).done;){var i=e.value;z.WriteChoice(t,i)}}catch(t){n.e(t)}finally{n.f()}t.WriteArrayEnd()}),t.WriteObjectEnd()}},{key:"LoadFlowChoiceThreads",value:function(t,e){var n,i=pt(this.currentChoices);try{for(i.s();!(n=i.n()).done;){var r,a=n.value,s=this.callStack.ThreadWithIndex(a.originalThreadIndex);null!==s?a.threadAtGeneration=s.Copy():(r=t["".concat(a.originalThreadIndex)],a.threadAtGeneration=new H.Thread(r,e))}}catch(t){i.e(t)}finally{i.f()}}}]),r}(),it=function(){function c(t){m(this,c),this.kInkSaveStateVersion=9,this.kMinCompatibleLoadVersion=8,this.onDidLoadState=null,this._currentErrors=null,this._currentWarnings=null,this.divertedPointer=It.Null,this._currentTurnIndex=0,this.storySeed=0,this.previousRandom=0,this.didSafeExit=!1,this._currentText=null,this._currentTags=null,this._outputStreamTextDirty=!0,this._outputStreamTagsDirty=!0,this._patch=null,this._namedFlows=null,this.kDefaultFlowName="DEFAULT_FLOW",this.story=t,this._currentFlow=new nt(this.kDefaultFlowName,t),this.OutputStreamDirty(),this._evaluationStack=[],this._variablesState=new X(this.callStack,t.listDefinitions),this._visitCounts=new Map,this._turnIndices=new Map,this.currentTurnIndex=-1;var e=(new Date).getTime();this.storySeed=new Rt(e).next()%100,this.previousRandom=0,this.GoToStart()}return u(c,[{key:"ToJson",value:function(){var t=new Y.Writer;return this.WriteJson(t),t.ToString()}},{key:"toJson",value:function(t){var e=0<arguments.length&&void 0!==t&&t;return this.ToJson(e)}},{key:"LoadJson",value:function(t){var e=Y.TextToDictionary(t);this.LoadJsonObj(e),null!==this.onDidLoadState&&this.onDidLoadState()}},{key:"VisitCountAtPathString",value:function(t){var e;if(null!==this._patch){var n=this.story.ContentAtPath(new O(t)).container;if(null===n)throw new Error("Content at path not found: "+t);if((e=this._patch.TryGetVisitCount(n,0)).exists)return e.result}return(e=E(this._visitCounts,t,null)).exists?e.result:0}},{key:"VisitCountForContainer",value:function(t){if(null===t)return gt("container");if(!t.visitsShouldBeCounted)return this.story.Error("Read count for target ("+t.name+" - on "+t.debugMetadata+") unknown. The story may need to be compiled with countAllVisits flag (-c)."),0;if(null!==this._patch){var e=this._patch.TryGetVisitCount(t,0);if(e.exists)return e.result}var n=t.path.toString(),i=E(this._visitCounts,n,null);return i.exists?i.result:0}},{key:"IncrementVisitCountForContainer",value:function(t){if(null!==this._patch){var e=this.VisitCountForContainer(t);return e++,void this._patch.SetVisitCount(t,e)}var n=t.path.toString(),i=E(this._visitCounts,n,null);i.exists?this._visitCounts.set(n,i.result+1):this._visitCounts.set(n,1)}},{key:"RecordTurnIndexVisitToContainer",value:function(t){var e;null===this._patch?(e=t.path.toString(),this._turnIndices.set(e,this.currentTurnIndex)):this._patch.SetTurnIndex(t,this.currentTurnIndex)}},{key:"TurnsSinceForContainer",value:function(t){if(t.turnIndexShouldBeCounted||this.story.Error("TURNS_SINCE() for target ("+t.name+" - on "+t.debugMetadata+") unknown. The story may need to be compiled with countAllVisits flag (-c)."),null!==this._patch){var e=this._patch.TryGetTurnIndex(t,0);if(e.exists)return this.currentTurnIndex-e.result}var n=t.path.toString(),i=E(this._turnIndices,n,0);return i.exists?this.currentTurnIndex-i.result:-1}},{key:"callstackDepth",get:function(){return this.callStack.depth}},{key:"outputStream",get:function(){return this._currentFlow.outputStream}},{key:"currentChoices",get:function(){return this.canContinue?[]:this._currentFlow.currentChoices}},{key:"generatedChoices",get:function(){return this._currentFlow.currentChoices}},{key:"currentErrors",get:function(){return this._currentErrors}},{key:"currentWarnings",get:function(){return this._currentWarnings}},{key:"variablesState",get:function(){return this._variablesState},set:function(t){this._variablesState=t}},{key:"callStack",get:function(){return this._currentFlow.callStack}},{key:"evaluationStack",get:function(){return this._evaluationStack}},{key:"currentTurnIndex",get:function(){return this._currentTurnIndex},set:function(t){this._currentTurnIndex=t}},{key:"currentPathString",get:function(){var t=this.currentPointer;return t.isNull?null:null===t.path?gt("pointer.path"):t.path.toString()}},{key:"currentPointer",get:function(){return this.callStack.currentElement.currentPointer.copy()},set:function(t){this.callStack.currentElement.currentPointer=t.copy()}},{key:"previousPointer",get:function(){return this.callStack.currentThread.previousPointer.copy()},set:function(t){this.callStack.currentThread.previousPointer=t.copy()}},{key:"canContinue",get:function(){return!this.currentPointer.isNull&&!this.hasError}},{key:"hasError",get:function(){return null!=this.currentErrors&&0<this.currentErrors.length}},{key:"hasWarning",get:function(){return null!=this.currentWarnings&&0<this.currentWarnings.length}},{key:"currentText",get:function(){if(this._outputStreamTextDirty){var t,e=new St,n=pt(this.outputStream);try{for(n.s();!(t=n.n()).done;){var i=yt(t.value,Tt);null!==i&&e.Append(i.value)}}catch(t){n.e(t)}finally{n.f()}this._currentText=this.CleanOutputWhitespace(e.toString()),this._outputStreamTextDirty=!1}return this._currentText}},{key:"CleanOutputWhitespace",value:function(t){for(var e=new St,n=-1,i=0,r=0;r<t.length;r++){var a=t.charAt(r),s=" "==a||"\t"==a;s&&-1==n&&(n=r),s||("\n"!=a&&0<n&&n!=i&&e.Append(" "),n=-1),"\n"==a&&(i=r+1),s||e.Append(a)}return e.toString()}},{key:"currentTags",get:function(){if(this._outputStreamTagsDirty){this._currentTags=[];var t,e=pt(this.outputStream);try{for(e.s();!(t=e.n()).done;){var n=yt(t.value,J);null!==n&&this._currentTags.push(n.text)}}catch(t){e.e(t)}finally{e.f()}this._outputStreamTagsDirty=!1}return this._currentTags}},{key:"currentFlowName",get:function(){return this._currentFlow.name}},{key:"inExpressionEvaluation",get:function(){return this.callStack.currentElement.inExpressionEvaluation},set:function(t){this.callStack.currentElement.inExpressionEvaluation=t}},{key:"GoToStart",value:function(){this.callStack.currentElement.currentPointer=It.StartOf(this.story.mainContentContainer)}},{key:"SwitchFlow_Internal",value:function(t){if(null===t)throw new Error("Must pass a non-null string to Story.SwitchFlow");var e,n;null===this._namedFlows&&(this._namedFlows=new Map,this._namedFlows.set(this.kDefaultFlowName,this._currentFlow)),t!==this._currentFlow.name&&((n=E(this._namedFlows,t,null)).exists?e=n.result:(e=new nt(t,this.story),this._namedFlows.set(t,e)),this._currentFlow=e,this.variablesState.callStack=this._currentFlow.callStack,this.OutputStreamDirty())}},{key:"SwitchToDefaultFlow_Internal",value:function(){null!==this._namedFlows&&this.SwitchFlow_Internal(this.kDefaultFlowName)}},{key:"RemoveFlow_Internal",value:function(t){if(null===t)throw new Error("Must pass a non-null string to Story.DestroyFlow");if(t===this.kDefaultFlowName)throw new Error("Cannot destroy default flow");if(this._currentFlow.name===t&&this.SwitchToDefaultFlow_Internal(),null===this._namedFlows)return gt("this._namedFlows");this._namedFlows.delete(t)}},{key:"CopyAndStartPatching",value:function(){var t,e,n,i,r,a=new c(this.story);if(a._patch=new $(this._patch),a._currentFlow.name=this._currentFlow.name,a._currentFlow.callStack=new H(this._currentFlow.callStack),(t=a._currentFlow.currentChoices).push.apply(t,d(this._currentFlow.currentChoices)),(e=a._currentFlow.outputStream).push.apply(e,d(this._currentFlow.outputStream)),a.OutputStreamDirty(),null!==this._namedFlows){a._namedFlows=new Map;var s,o=pt(this._namedFlows);try{for(o.s();!(s=o.n()).done;){var u=S(s.value,2),l=u[0],h=u[1];a._namedFlows.set(l,h)}}catch(t){o.e(t)}finally{o.f()}a._namedFlows.set(this._currentFlow.name,a._currentFlow)}return this.hasError&&(a._currentErrors=[],(i=a._currentErrors).push.apply(i,d(this.currentErrors||[]))),this.hasWarning&&(a._currentWarnings=[],(r=a._currentWarnings).push.apply(r,d(this.currentWarnings||[]))),a.variablesState=this.variablesState,a.variablesState.callStack=a.callStack,a.variablesState.patch=a._patch,(n=a.evaluationStack).push.apply(n,d(this.evaluationStack)),this.divertedPointer.isNull||(a.divertedPointer=this.divertedPointer.copy()),a.previousPointer=this.previousPointer.copy(),a._visitCounts=this._visitCounts,a._turnIndices=this._turnIndices,a.currentTurnIndex=this.currentTurnIndex,a.storySeed=this.storySeed,a.previousRandom=this.previousRandom,a.didSafeExit=this.didSafeExit,a}},{key:"RestoreAfterPatch",value:function(){this.variablesState.callStack=this.callStack,this.variablesState.patch=this._patch}},{key:"ApplyAnyPatch",value:function(){if(null!==this._patch){this.variablesState.ApplyPatch();var t,e=pt(this._patch.visitCounts);try{for(e.s();!(t=e.n()).done;){var n=S(t.value,2),i=n[0],r=n[1];this.ApplyCountChanges(i,r,!0)}}catch(t){e.e(t)}finally{e.f()}var a,s=pt(this._patch.turnIndices);try{for(s.s();!(a=s.n()).done;){var o=S(a.value,2),u=o[0],l=o[1];this.ApplyCountChanges(u,l,!1)}}catch(t){s.e(t)}finally{s.f()}this._patch=null}}},{key:"ApplyCountChanges",value:function(t,e,n){(n?this._visitCounts:this._turnIndices).set(t.path.toString(),e)}},{key:"WriteJson",value:function(i){var e=this;if(i.WriteObjectStart(),i.WritePropertyStart("flows"),i.WriteObjectStart(),null!==this._namedFlows){var r,n=pt(this._namedFlows);try{var t=function(){var t=S(r.value,2),e=t[0],n=t[1];i.WriteProperty(e,function(t){return n.WriteJson(t)})};for(n.s();!(r=n.n()).done;)t()}catch(t){n.e(t)}finally{n.f()}}else i.WriteProperty(this._currentFlow.name,function(t){return e._currentFlow.WriteJson(t)});if(i.WriteObjectEnd(),i.WritePropertyEnd(),i.WriteProperty("currentFlowName",this._currentFlow.name),i.WriteProperty("variablesState",function(t){return e.variablesState.WriteJson(t)}),i.WriteProperty("evalStack",function(t){return z.WriteListRuntimeObjs(t,e.evaluationStack)}),!this.divertedPointer.isNull){if(null===this.divertedPointer.path)return gt("divertedPointer");i.WriteProperty("currentDivertTarget",this.divertedPointer.path.componentsString)}i.WriteProperty("visitCounts",function(t){return z.WriteIntDictionary(t,e._visitCounts)}),i.WriteProperty("turnIndices",function(t){return z.WriteIntDictionary(t,e._turnIndices)}),i.WriteIntProperty("turnIdx",this.currentTurnIndex),i.WriteIntProperty("storySeed",this.storySeed),i.WriteIntProperty("previousRandom",this.previousRandom),i.WriteIntProperty("inkSaveVersion",this.kInkSaveStateVersion),i.WriteIntProperty("inkFormatVersion",a.Story.inkVersionCurrent),i.WriteObjectEnd()}},{key:"LoadJsonObj",value:function(t){var e=t,n=e.inkSaveVersion;if(null==n)throw new Error("ink save format incorrect, can't load.");if(parseInt(n)<this.kMinCompatibleLoadVersion)throw new Error("Ink save format isn't compatible with the current version (saw '"+n+"', but minimum is "+this.kMinCompatibleLoadVersion+"), so can't load.");var i=e.flows;if(null!=i){var r=i;1===Object.keys(r).length?this._namedFlows=null:null===this._namedFlows?this._namedFlows=new Map:this._namedFlows.clear();for(var a,s=0,o=Object.entries(r);s<o.length;s++){var u=S(o[s],2),l=u[0],h=u[1],c=new nt(l,this.story,h);if(1===Object.keys(r).length)this._currentFlow=new nt(l,this.story,h);else{if(null===this._namedFlows)return gt("this._namedFlows");this._namedFlows.set(l,c)}}null!=this._namedFlows&&1<this._namedFlows.size&&(a=e.currentFlowName,this._currentFlow=this._namedFlows.get(a))}else{this._namedFlows=null,this._currentFlow.name=this.kDefaultFlowName,this._currentFlow.callStack.SetJsonToken(e.callstackThreads,this.story),this._currentFlow.outputStream=z.JArrayToRuntimeObjList(e.outputStream),this._currentFlow.currentChoices=z.JArrayToRuntimeObjList(e.currentChoices);var f=e.choiceThreads;this._currentFlow.LoadFlowChoiceThreads(f,this.story)}this.OutputStreamDirty(),this.variablesState.SetJsonToken(e.variablesState),this.variablesState.callStack=this._currentFlow.callStack,this._evaluationStack=z.JArrayToRuntimeObjList(e.evalStack);var v,d=e.currentDivertTarget;null!=d&&(v=new O(d.toString()),this.divertedPointer=this.story.PointerAtPath(v)),this._visitCounts=z.JObjectToIntDictionary(e.visitCounts),this._turnIndices=z.JObjectToIntDictionary(e.turnIndices),this.currentTurnIndex=parseInt(e.turnIdx),this.storySeed=parseInt(e.storySeed),this.previousRandom=parseInt(e.previousRandom)}},{key:"ResetErrors",value:function(){this._currentErrors=null,this._currentWarnings=null}},{key:"ResetOutput",value:function(t){var e,n=0<arguments.length&&void 0!==t?t:null;this.outputStream.length=0,null!==n&&(e=this.outputStream).push.apply(e,d(n)),this.OutputStreamDirty()}},{key:"PushToOutputStream",value:function(t){var e=yt(t,Tt);if(null!==e){var n=this.TrySplittingHeadTailWhitespace(e);if(null!==n){var i,r=pt(n);try{for(r.s();!(i=r.n()).done;){var a=i.value;this.PushToOutputStreamIndividual(a)}}catch(t){r.e(t)}finally{r.f()}return void this.OutputStreamDirty()}}this.PushToOutputStreamIndividual(t),this.OutputStreamDirty()}},{key:"PopFromOutputStream",value:function(t){this.outputStream.splice(this.outputStream.length-t,t),this.OutputStreamDirty()}},{key:"TrySplittingHeadTailWhitespace",value:function(t){var e=t.value;if(null===e)return gt("single.value");for(var n=-1,i=-1,r=0;r<e.length;r++){var a=e[r];if("\n"!=a){if(" "==a||"\t"==a)continue;break}-1==n&&(n=r),i=r}for(var s=-1,o=-1,u=e.length-1;0<=u;u--){var l=e[u];if("\n"!=l){if(" "==l||"\t"==l)continue;break}-1==s&&(s=u),o=u}if(-1==n&&-1==s)return null;var h,c,f,v,d=[],p=0,y=e.length;return-1!=n&&(0<n&&(h=new Tt(e.substring(0,n)),d.push(h)),d.push(new Tt("\n")),p=i+1),-1!=s&&(y=o),p<y&&(c=e.substring(p,y-p),d.push(new Tt(c))),-1!=s&&i<o&&(d.push(new Tt("\n")),s<e.length-1&&(f=e.length-s-1,v=new Tt(e.substring(s+1,f)),d.push(v))),d}},{key:"PushToOutputStreamIndividual",value:function(t){var e=yt(t,G),n=yt(t,Tt),i=!0;if(e)this.TrimNewlinesFromOutputStream(),i=!0;else if(n){var r=-1,a=this.callStack.currentElement;a.type==Nt.Function&&(r=a.functionStartInOutputStream);for(var s=-1,o=this.outputStream.length-1;0<=o;o--){var u=this.outputStream[o],l=u instanceof At?u:null;if(null!=(u instanceof G?u:null)){s=o;break}if(null!=l&&l.commandType==At.CommandType.BeginString){r<=o&&(r=-1);break}}if(-1!=(-1!=s&&-1!=r?Math.min(r,s):-1!=s?s:r)){if(n.isNewline)i=!1;else if(n.isNonWhitespace&&(-1<s&&this.RemoveExistingGlue(),-1<r))for(var h=this.callStack.elements,c=h.length-1;0<=c;c--){var f=h[c];if(f.type!=Nt.Function)break;f.functionStartInOutputStream=-1}}else n.isNewline&&(!this.outputStreamEndsInNewline&&this.outputStreamContainsContent||(i=!1))}if(i){if(null===t)return gt("obj");this.outputStream.push(t),this.OutputStreamDirty()}}},{key:"TrimNewlinesFromOutputStream",value:function(){for(var t=-1,e=this.outputStream.length-1;0<=e;){var n=this.outputStream[e],i=yt(n,At),r=yt(n,Tt);if(null!=i||null!=r&&r.isNonWhitespace)break;null!=r&&r.isNewline&&(t=e),e--}if(0<=t)for(e=t;e<this.outputStream.length;){yt(this.outputStream[e],Tt)?this.outputStream.splice(e,1):e++}this.OutputStreamDirty()}},{key:"RemoveExistingGlue",value:function(){for(var t=this.outputStream.length-1;0<=t;t--){var e=this.outputStream[t];if(e instanceof G)this.outputStream.splice(t,1);else if(e instanceof At)break}this.OutputStreamDirty()}},{key:"outputStreamEndsInNewline",get:function(){if(0<this.outputStream.length)for(var t=this.outputStream.length-1;0<=t;t--){if(this.outputStream[t]instanceof At)break;var e=this.outputStream[t];if(e instanceof Tt){if(e.isNewline)return!0;if(e.isNonWhitespace)break}}return!1}},{key:"outputStreamContainsContent",get:function(){var t,e=pt(this.outputStream);try{for(e.s();!(t=e.n()).done;){if(t.value instanceof Tt)return!0}}catch(t){e.e(t)}finally{e.f()}return!1}},{key:"inStringEvaluation",get:function(){for(var t=this.outputStream.length-1;0<=t;t--){var e=yt(this.outputStream[t],At);if(e instanceof At&&e.commandType==At.CommandType.BeginString)return!0}return!1}},{key:"PushEvaluationStack",value:function(t){var e=yt(t,Pt);if(e){var n=e.value;if(null===n)return gt("rawList");if(null!=n.originNames){n.origins||(n.origins=[]),n.origins.length=0;var i,r=pt(n.originNames);try{for(r.s();!(i=r.n()).done;){var a=i.value;if(null===this.story.listDefinitions)return gt("StoryState.story.listDefinitions");var s=this.story.listDefinitions.TryListGetDefinition(a,null);if(null===s.result)return gt("StoryState def.result");n.origins.indexOf(s.result)<0&&n.origins.push(s.result)}}catch(t){r.e(t)}finally{r.f()}}}if(null===t)return gt("obj");this.evaluationStack.push(t)}},{key:"PopEvaluationStack",value:function(t){if(void 0===t)return b(this.evaluationStack.pop());if(t>this.evaluationStack.length)throw new Error("trying to pop too many objects");return b(this.evaluationStack.splice(this.evaluationStack.length-t,t))}},{key:"PeekEvaluationStack",value:function(){return this.evaluationStack[this.evaluationStack.length-1]}},{key:"ForceEnd",value:function(){this.callStack.Reset(),this._currentFlow.currentChoices.length=0,this.currentPointer=It.Null,this.previousPointer=It.Null,this.didSafeExit=!0}},{key:"TrimWhitespaceFromFunctionEnd",value:function(){k.Assert(this.callStack.currentElement.type==Nt.Function);var t=this.callStack.currentElement.functionStartInOutputStream;-1==t&&(t=0);for(var e=this.outputStream.length-1;t<=e;e--){var n=this.outputStream[e],i=yt(n,Tt),r=yt(n,At);if(null!=i){if(r)break;if(!i.isNewline&&!i.isInlineWhitespace)break;this.outputStream.splice(e,1),this.OutputStreamDirty()}}}},{key:"PopCallStack",value:function(t){var e=0<arguments.length&&void 0!==t?t:null;this.callStack.currentElement.type==Nt.Function&&this.TrimWhitespaceFromFunctionEnd(),this.callStack.Pop(e)}},{key:"SetChosenPath",value:function(t,e){this._currentFlow.currentChoices.length=0;var n=this.story.PointerAtPath(t);n.isNull||-1!=n.index||(n.index=0),this.currentPointer=n,e&&this.currentTurnIndex++}},{key:"StartFunctionEvaluationFromGame",value:function(t,e){this.callStack.Push(Nt.FunctionEvaluationFromGame,this.evaluationStack.length),this.callStack.currentElement.currentPointer=It.StartOf(t),this.PassArgumentsToEvaluationStack(e)}},{key:"PassArgumentsToEvaluationStack",value:function(t){if(null!==t)for(var e=0;e<t.length;e++){if("number"!=typeof t[e]&&"string"!=typeof t[e]||t[e]instanceof Ct)throw new Error((b(arguments[e]),"null"));this.PushEvaluationStack(_t.Create(t[e]))}}},{key:"TryExitFunctionEvaluationFromGame",value:function(){return this.callStack.currentElement.type==Nt.FunctionEvaluationFromGame&&(this.currentPointer=It.Null,this.didSafeExit=!0)}},{key:"CompleteFunctionEvaluationFromGame",value:function(){if(this.callStack.currentElement.type!=Nt.FunctionEvaluationFromGame)throw new Error("Expected external function evaluation to be complete. Stack trace: "+this.callStack.callStackTrace);for(var t=this.callStack.currentElement.evaluationStackHeightWhenPushed,e=null;this.evaluationStack.length>t;){var n=this.PopEvaluationStack();null===e&&(e=n)}if(this.PopCallStack(Nt.FunctionEvaluationFromGame),e){if(e instanceof Vt)return null;var i=mt(e,_t);return i.valueType==N.DivertTarget?i.valueObject.toString():i.valueObject}return null}},{key:"AddError",value:function(t,e){e?(null==this._currentWarnings&&(this._currentWarnings=[]),this._currentWarnings.push(t)):(null==this._currentErrors&&(this._currentErrors=[]),this._currentErrors.push(t))}},{key:"OutputStreamDirty",value:function(){this._outputStreamTextDirty=!0,this._outputStreamTagsDirty=!0}}]),c}(),rt=function(){function t(){m(this,t),this.startTime=void 0}return u(t,[{key:"ElapsedMilliseconds",get:function(){return void 0===this.startTime?0:(new Date).getTime()-this.startTime}},{key:"Start",value:function(){this.startTime=(new Date).getTime()}},{key:"Stop",value:function(){this.startTime=void 0}}]),t}();(Z=Q=Q||{})[Z.Author=0]="Author",Z[Z.Warning=1]="Warning",Z[Z.Error=2]="Error",Number.isInteger||(Number.isInteger=function(t){return"number"==typeof t&&isFinite(t)&&-9007199254740992<t&&t<9007199254740992&&Math.floor(t)===t}),a.Story=function(){s(f,T);var h=v(f);function f(){var t,e;m(this,f),(t=h.call(this)).inkVersionMinimumCompatible=18,t.onError=null,t.onDidContinue=null,t.onMakeChoice=null,t.onEvaluateFunction=null,t.onCompleteEvaluateFunction=null,t.onChoosePathString=null,t._prevContainers=[],t.allowExternalFunctionFallbacks=!1,t._listDefinitions=null,t._variableObservers=null,t._hasValidatedExternals=!1,t._temporaryEvaluationContainer=null,t._asyncContinueActive=!1,t._stateSnapshotAtLastNewline=null,t._sawLookaheadUnsafeFunctionAfterNewline=!1,t._recursiveContinueCount=0,t._asyncSaving=!1;var n,i=t._profiler=null,r=null;if(arguments[0]instanceof Ot?(e=arguments[0],void 0!==arguments[1]&&(i=arguments[1]),t._mainContentContainer=e):r="string"==typeof arguments[0]?(n=arguments[0],Y.TextToDictionary(n)):arguments[0],null!=i&&(t._listDefinitions=new K(i)),t._externals=new Map,null!==r){var a=r,s=a.inkVersion;if(null==s)throw new Error("ink version number not found. Are you sure it's a valid .ink.json file?");var o=parseInt(s);if(f.inkVersionCurrent<o)throw new Error("Version of ink used to build story was newer than the current version of the engine");if(o<t.inkVersionMinimumCompatible)throw new Error("Version of ink used to build story is too old to be loaded by this version of the engine");o!=f.inkVersionCurrent&&console.warn("WARNING: Version of ink used to build story doesn't match current version of engine. Non-critical, but recommend synchronising.");var u,l=a.root;if(null==l)throw new Error("Root node for ink not found. Are you sure it's a valid .ink.json file?");(u=a.listDefs)&&(t._listDefinitions=z.JTokenToListDefinitions(u)),t._mainContentContainer=mt(z.JTokenToRuntimeObject(l),Ot),t.ResetState()}return t}return u(f,[{key:"currentChoices",get:function(){var t=[];if(null===this._state)return gt("this._state");var e,n=pt(this._state.currentChoices);try{for(n.s();!(e=n.n()).done;){var i=e.value;i.isInvisibleDefault||(i.index=t.length,t.push(i))}}catch(t){n.e(t)}finally{n.f()}return t}},{key:"currentText",get:function(){return this.IfAsyncWeCant("call currentText since it's a work in progress"),this.state.currentText}},{key:"currentTags",get:function(){return this.IfAsyncWeCant("call currentTags since it's a work in progress"),this.state.currentTags}},{key:"currentErrors",get:function(){return this.state.currentErrors}},{key:"currentWarnings",get:function(){return this.state.currentWarnings}},{key:"currentFlowName",get:function(){return this.state.currentFlowName}},{key:"hasError",get:function(){return this.state.hasError}},{key:"hasWarning",get:function(){return this.state.hasWarning}},{key:"variablesState",get:function(){return this.state.variablesState}},{key:"listDefinitions",get:function(){return this._listDefinitions}},{key:"state",get:function(){return this._state}},{key:"StartProfiling",value:function(){}},{key:"EndProfiling",value:function(){}},{key:"ToJson",value:function(t){var e=this,n=!1;if(t||(n=!0,t=new Y.Writer),t.WriteObjectStart(),t.WriteIntProperty("inkVersion",f.inkVersionCurrent),t.WriteProperty("root",function(t){return z.WriteRuntimeContainer(t,e._mainContentContainer)}),null!=this._listDefinitions){t.WritePropertyStart("listDefs"),t.WriteObjectStart();var i,r=pt(this._listDefinitions.lists);try{for(r.s();!(i=r.n()).done;){var a=i.value;t.WritePropertyStart(a.name),t.WriteObjectStart();var s,o=pt(a.items);try{for(o.s();!(s=o.n()).done;){var u=S(s.value,2),l=u[0],h=u[1],c=kt.fromSerializedKey(l);t.WriteIntProperty(c.itemName,h)}}catch(t){o.e(t)}finally{o.f()}t.WriteObjectEnd(),t.WritePropertyEnd()}}catch(t){r.e(t)}finally{r.f()}t.WriteObjectEnd(),t.WritePropertyEnd()}if(t.WriteObjectEnd(),n)return t.ToString()}},{key:"ResetState",value:function(){this.IfAsyncWeCant("ResetState"),this._state=new it(this),this._state.variablesState.ObserveVariableChange(this.VariableStateDidChangeEvent.bind(this)),this.ResetGlobals()}},{key:"ResetErrors",value:function(){if(null===this._state)return gt("this._state");this._state.ResetErrors()}},{key:"ResetCallstack",value:function(){if(this.IfAsyncWeCant("ResetCallstack"),null===this._state)return gt("this._state");this._state.ForceEnd()}},{key:"ResetGlobals",value:function(){var t;this._mainContentContainer.namedContent.get("global decl")&&(t=this.state.currentPointer.copy(),this.ChoosePath(new O("global decl"),!1),this.ContinueInternal(),this.state.currentPointer=t),this.state.variablesState.SnapshotDefaultGlobals()}},{key:"SwitchFlow",value:function(t){if(this.IfAsyncWeCant("switch flow"),this._asyncSaving)throw new Error("Story is already in background saving mode, can't switch flow to "+t);this.state.SwitchFlow_Internal(t)}},{key:"RemoveFlow",value:function(t){this.state.RemoveFlow_Internal(t)}},{key:"SwitchToDefaultFlow",value:function(){this.state.SwitchToDefaultFlow_Internal()}},{key:"Continue",value:function(){return this.ContinueAsync(0),this.currentText}},{key:"canContinue",get:function(){return this.state.canContinue}},{key:"asyncContinueComplete",get:function(){return!this._asyncContinueActive}},{key:"ContinueAsync",value:function(t){this._hasValidatedExternals||this.ValidateExternalBindings(),this.ContinueInternal(t)}},{key:"ContinueInternal",value:function(t){var e=0<arguments.length&&void 0!==t?t:0;null!=this._profiler&&this._profiler.PreContinue();var n=0<e;if(this._recursiveContinueCount++,!this._asyncContinueActive){if(this._asyncContinueActive=n,!this.canContinue)throw new Error("Can't continue - should check canContinue before calling Continue");this._state.didSafeExit=!1,this._state.ResetOutput(),1==this._recursiveContinueCount&&(this._state.variablesState.batchObservingVariableChanges=!0)}var i=new rt;i.Start();var r=!1;this._sawLookaheadUnsafeFunctionAfterNewline=!1;do{try{r=this.ContinueSingleStep()}catch(t){if(!(t instanceof bt))throw t;this.AddError(t.message,void 0,t.useEndLineNumber);break}if(r)break;if(this._asyncContinueActive&&i.ElapsedMilliseconds>e)break}while(this.canContinue);if(i.Stop(),!r&&this.canContinue||(null!==this._stateSnapshotAtLastNewline&&this.RestoreStateSnapshot(),this.canContinue||(this.state.callStack.canPopThread&&this.AddError("Thread available to pop, threads should always be flat by the end of evaluation?"),0!=this.state.generatedChoices.length||this.state.didSafeExit||null!=this._temporaryEvaluationContainer||(this.state.callStack.CanPop(Nt.Tunnel)?this.AddError("unexpectedly reached end of content. Do you need a '->->' to return from a tunnel?"):this.state.callStack.CanPop(Nt.Function)?this.AddError("unexpectedly reached end of content. Do you need a '~ return'?"):this.state.callStack.canPop?this.AddError("unexpectedly reached end of content for unknown reason. Please debug compiler!"):this.AddError("ran out of content. Do you need a '-> DONE' or '-> END'?"))),this.state.didSafeExit=!1,this._sawLookaheadUnsafeFunctionAfterNewline=!1,1==this._recursiveContinueCount&&(this._state.variablesState.batchObservingVariableChanges=!1),this._asyncContinueActive=!1,null!==this.onDidContinue&&this.onDidContinue()),this._recursiveContinueCount--,null!=this._profiler&&this._profiler.PostContinue(),this.state.hasError||this.state.hasWarning){if(null===this.onError){var a=new St;throw a.Append("Ink had "),this.state.hasError&&(a.Append("".concat(this.state.currentErrors.length)),a.Append(1==this.state.currentErrors.length?" error":"errors"),this.state.hasWarning&&a.Append(" and ")),this.state.hasWarning&&(a.Append("".concat(this.state.currentWarnings.length)),a.Append(1==this.state.currentWarnings.length?" warning":"warnings"),this.state.hasWarning&&a.Append(" and ")),a.Append(". It is strongly suggested that you assign an error handler to story.onError. The first issue was: "),a.Append(this.state.hasError?this.state.currentErrors[0]:this.state.currentWarnings[0]),new bt(a.toString())}if(this.state.hasError){var s,o=pt(this.state.currentErrors);try{for(o.s();!(s=o.n()).done;){var u=s.value;this.onError(u,Q.Error)}}catch(u){o.e(u)}finally{o.f()}}if(this.state.hasWarning){var l,h=pt(this.state.currentWarnings);try{for(h.s();!(l=h.n()).done;){var c=l.value;this.onError(c,Q.Warning)}}catch(u){h.e(u)}finally{h.f()}}this.ResetErrors()}}},{key:"ContinueSingleStep",value:function(){if(null!=this._profiler&&this._profiler.PreStep(),this.Step(),null!=this._profiler&&this._profiler.PostStep(),this.canContinue||this.state.callStack.elementIsEvaluateFromGame||this.TryFollowDefaultInvisibleChoice(),null!=this._profiler&&this._profiler.PreSnapshot(),!this.state.inStringEvaluation){if(null!==this._stateSnapshotAtLastNewline){if(null===this._stateSnapshotAtLastNewline.currentTags)return gt("this._stateAtLastNewline.currentTags");if(null===this.state.currentTags)return gt("this.state.currentTags");var t=this.CalculateNewlineOutputStateChange(this._stateSnapshotAtLastNewline.currentText,this.state.currentText,this._stateSnapshotAtLastNewline.currentTags.length,this.state.currentTags.length);if(t==f.OutputStateChange.ExtendedBeyondNewline||this._sawLookaheadUnsafeFunctionAfterNewline)return this.RestoreStateSnapshot(),!0;t==f.OutputStateChange.NewlineRemoved&&this.DiscardSnapshot()}this.state.outputStreamEndsInNewline&&(this.canContinue?null==this._stateSnapshotAtLastNewline&&this.StateSnapshot():this.DiscardSnapshot())}return null!=this._profiler&&this._profiler.PostSnapshot(),!1}},{key:"CalculateNewlineOutputStateChange",value:function(t,e,n,i){if(null===t)return gt("prevText");if(null===e)return gt("currText");var r=e.length>=t.length&&"\n"==e.charAt(t.length-1);if(n==i&&t.length==e.length&&r)return f.OutputStateChange.NoChange;if(!r)return f.OutputStateChange.NewlineRemoved;if(n<i)return f.OutputStateChange.ExtendedBeyondNewline;for(var a=t.length;a<e.length;a++){var s=e.charAt(a);if(" "!=s&&"\t"!=s)return f.OutputStateChange.ExtendedBeyondNewline}return f.OutputStateChange.NoChange}},{key:"ContinueMaximally",value:function(){this.IfAsyncWeCant("ContinueMaximally");for(var t=new St;this.canContinue;)t.Append(this.Continue());return t.toString()}},{key:"ContentAtPath",value:function(t){return this.mainContentContainer.ContentAtPath(t)}},{key:"KnotContainerWithName",value:function(t){var e=this.mainContentContainer.namedContent.get(t);return e instanceof Ot?e:null}},{key:"PointerAtPath",value:function(t){if(0==t.length)return It.Null;var e=new It,n=t.length,i=null;return null===t.lastComponent?gt("path.lastComponent"):(t.lastComponent.isIndex?(n=t.length-1,i=this.mainContentContainer.ContentAtPath(t,void 0,n),e.container=i.container,e.index=t.lastComponent.index):(i=this.mainContentContainer.ContentAtPath(t),e.container=i.container,e.index=-1),null==i.obj||i.obj==this.mainContentContainer&&0<n?this.Error("Failed to find content at path '"+t+"', and no approximation of it was possible."):i.approximate&&this.Warning("Failed to find content at path '"+t+"', so it was approximated to: '"+i.obj.path+"'."),e)}},{key:"StateSnapshot",value:function(){this._stateSnapshotAtLastNewline=this._state,this._state=this._state.CopyAndStartPatching()}},{key:"RestoreStateSnapshot",value:function(){null===this._stateSnapshotAtLastNewline&&gt("_stateSnapshotAtLastNewline"),this._stateSnapshotAtLastNewline.RestoreAfterPatch(),this._state=this._stateSnapshotAtLastNewline,this._stateSnapshotAtLastNewline=null,this._asyncSaving||this._state.ApplyAnyPatch()}},{key:"DiscardSnapshot",value:function(){this._asyncSaving||this._state.ApplyAnyPatch(),this._stateSnapshotAtLastNewline=null}},{key:"CopyStateForBackgroundThreadSave",value:function(){if(this.IfAsyncWeCant("start saving on a background thread"),this._asyncSaving)throw new Error("Story is already in background saving mode, can't call CopyStateForBackgroundThreadSave again!");var t=this._state;return this._state=this._state.CopyAndStartPatching(),this._asyncSaving=!0,t}},{key:"BackgroundSaveComplete",value:function(){null===this._stateSnapshotAtLastNewline&&this._state.ApplyAnyPatch(),this._asyncSaving=!1}},{key:"Step",value:function(){var t=!0,e=this.state.currentPointer.copy();if(!e.isNull){for(var n=yt(e.Resolve(),Ot);n&&(this.VisitContainer(n,!0),0!=n.content.length);)n=yt((e=It.StartOf(n)).Resolve(),Ot);this.state.currentPointer=e.copy(),null!=this._profiler&&this._profiler.Step(this.state.callStack);var i,r,a,s,o,u=e.Resolve(),l=this.PerformLogicAndFlowControl(u);this.state.currentPointer.isNull||(l&&(t=!1),(i=yt(u,M))&&((r=this.ProcessChoice(i))&&this.state.generatedChoices.push(r),u=null,t=!1),u instanceof Ot&&(t=!1),t&&((a=yt(u,W))&&-1==a.contextIndex&&(s=this.state.callStack.ContextForVariableNamed(a.variableName),u=new W(a.variableName,s)),this.state.inExpressionEvaluation?this.state.PushEvaluationStack(u):this.state.PushToOutputStream(u)),this.NextContent(),(o=yt(u,At))&&o.commandType==At.CommandType.StartThread&&this.state.callStack.PushThread())}}},{key:"VisitContainer",value:function(t,e){t.countingAtStartOnly&&!e||(t.visitsShouldBeCounted&&this.state.IncrementVisitCountForContainer(t),t.turnIndexShouldBeCounted&&this.state.RecordTurnIndexVisitToContainer(t))}},{key:"VisitChangedContainersDueToDivert",value:function(){var t=this.state.previousPointer.copy(),e=this.state.currentPointer.copy();if(!e.isNull&&-1!=e.index){if(this._prevContainers.length=0,!t.isNull)for(var n=yt(t.Resolve(),Ot)||yt(t.container,Ot);n;)this._prevContainers.push(n),n=yt(n.parent,Ot);var i=e.Resolve();if(null!=i)for(var r=yt(i.parent,Ot),a=!0;r&&(this._prevContainers.indexOf(r)<0||r.countingAtStartOnly);){var s=0<r.content.length&&i==r.content[0]&&a;s||(a=!1),this.VisitContainer(r,s),r=yt((i=r).parent,Ot)}}}},{key:"ProcessChoice",value:function(t){var e,n=!0;t.hasCondition&&(e=this.state.PopEvaluationStack(),this.IsTruthy(e)||(n=!1));var i="",r="";if(t.hasChoiceOnlyContent&&(r=mt(this.state.PopEvaluationStack(),Tt).value||""),t.hasStartContent&&(i=mt(this.state.PopEvaluationStack(),Tt).value||""),t.onceOnly&&0<this.state.VisitCountForContainer(t.choiceTarget)&&(n=!1),!n)return null;var a=new U;return a.targetPath=t.pathOnChoice,a.sourcePath=t.path.toString(),a.isInvisibleDefault=t.isInvisibleDefault,a.threadAtGeneration=this.state.callStack.ForkThread(),a.text=(i+r).replace(/^[ \t]+|[ \t]+$/g,""),a}},{key:"IsTruthy",value:function(t){if(t instanceof _t){var e=t;return e instanceof Et?(this.Error("Shouldn't use a divert target (to "+e.targetPath+") as a conditional value. Did you intend a function call 'likeThis()' or a read count check 'likeThis'? (no arrows)"),!1):e.isTruthy}return!1}},{key:"PerformLogicAndFlowControl",value:function(t){if(null==t)return!1;if(t instanceof xt){var e=t;if(e.isConditional){var n=this.state.PopEvaluationStack();if(!this.IsTruthy(n))return!0}if(e.hasVariableTarget){var i,r,a=e.variableDivertName,s=this.state.variablesState.GetVariableWithName(a);null==s?this.Error("Tried to divert using a target from a variable that could not be found ("+a+")"):s instanceof Et||(r="Tried to divert to a target from a variable, but the variable ("+a+") didn't contain a divert target, it ",(i=yt(s,wt))instanceof wt&&0==i.value?r+="was empty/null (the value 0).":r+="contained '"+s+"'.",this.Error(r));var o=mt(s,Et);this.state.divertedPointer=this.PointerAtPath(o.targetPath)}else{if(e.isExternal)return this.CallExternalFunction(e.targetPathString,e.externalArgs),!0;this.state.divertedPointer=e.targetPointer.copy()}return e.pushesToStack&&this.state.callStack.Push(e.stackPushType,void 0,this.state.outputStream.length),this.state.divertedPointer.isNull&&!e.isExternal&&(e&&e.debugMetadata&&null!=e.debugMetadata.sourceName?this.Error("Divert target doesn't exist: "+e.debugMetadata.sourceName):this.Error("Divert resolution failed: "+e)),!0}if(t instanceof At){var u,l,h=t;switch(h.commandType){case At.CommandType.EvalStart:this.Assert(!1===this.state.inExpressionEvaluation,"Already in expression evaluation?"),this.state.inExpressionEvaluation=!0;break;case At.CommandType.EvalEnd:this.Assert(!0===this.state.inExpressionEvaluation,"Not in expression evaluation mode"),this.state.inExpressionEvaluation=!1;break;case At.CommandType.EvalOutput:0<this.state.evaluationStack.length&&((u=this.state.PopEvaluationStack())instanceof Vt||(l=new Tt(u.toString()),this.state.PushToOutputStream(l)));break;case At.CommandType.NoOp:break;case At.CommandType.Duplicate:this.state.PushEvaluationStack(this.state.PeekEvaluationStack());break;case At.CommandType.PopEvaluatedValue:this.state.PopEvaluationStack();break;case At.CommandType.PopFunction:case At.CommandType.PopTunnel:var c,f,v,d,p=h.commandType==At.CommandType.PopFunction?Nt.Function:Nt.Tunnel,y=null;if(p!=Nt.Tunnel||null===(y=yt(c=this.state.PopEvaluationStack(),Et))&&this.Assert(c instanceof Vt,"Expected void if ->-> doesn't override target"),this.state.TryExitFunctionEvaluationFromGame())break;this.state.callStack.currentElement.type==p&&this.state.callStack.canPop?(this.state.PopCallStack(),y&&(this.state.divertedPointer=this.PointerAtPath(y.targetPath))):((f=new Map).set(Nt.Function,"function return statement (~ return)"),f.set(Nt.Tunnel,"tunnel onwards statement (->->)"),v=f.get(this.state.callStack.currentElement.type),this.state.callStack.canPop||(v="end of flow (-> END or choice)"),d="Found "+f.get(p)+", when expected "+v,this.Error(d));break;case At.CommandType.BeginString:this.state.PushToOutputStream(h),this.Assert(!0===this.state.inExpressionEvaluation,"Expected to be in an expression when evaluating a string"),this.state.inExpressionEvaluation=!1;break;case At.CommandType.EndString:for(var m=[],g=0,S=this.state.outputStream.length-1;0<=S;--S){var k=this.state.outputStream[S];g++;var C=yt(k,At);if(C&&C.commandType==At.CommandType.BeginString)break;k instanceof Tt&&m.push(k)}this.state.PopFromOutputStream(g),m=m.reverse();var b,_=new St,w=pt(m);try{for(w.s();!(b=w.n()).done;){var T=b.value;_.Append(T.toString())}}catch(t){w.e(t)}finally{w.f()}this.state.inExpressionEvaluation=!0,this.state.PushEvaluationStack(new Tt(_.toString()));break;case At.CommandType.ChoiceCount:var E=this.state.generatedChoices.length;this.state.PushEvaluationStack(new wt(E));break;case At.CommandType.Turns:this.state.PushEvaluationStack(new wt(this.state.currentTurnIndex+1));break;case At.CommandType.TurnsSince:case At.CommandType.ReadCount:var P=this.state.PopEvaluationStack();if(!(P instanceof Et)){var O=P instanceof wt?". Did you accidentally pass a read count ('knot_name') instead of a target ('-> knot_name')?":"";this.Error("TURNS_SINCE / READ_COUNT expected a divert target (knot, stitch, label name), but saw "+P+O);break}var N,A=mt(P,Et),I=yt(this.ContentAtPath(A.targetPath).correctObj,Ot);null!=I?N=h.commandType==At.CommandType.TurnsSince?this.state.TurnsSinceForContainer(I):this.state.VisitCountForContainer(I):(N=h.commandType==At.CommandType.TurnsSince?-1:0,this.Warning("Failed to find container for "+h.toString()+" lookup at "+A.targetPath.toString())),this.state.PushEvaluationStack(new wt(N));break;case At.CommandType.Random:var x=yt(this.state.PopEvaluationStack(),wt),F=yt(this.state.PopEvaluationStack(),wt);if(null==F||F instanceof wt==!1)return this.Error("Invalid value for minimum parameter of RANDOM(min, max)");if(null==x||F instanceof wt==!1)return this.Error("Invalid value for maximum parameter of RANDOM(min, max)");if(null===x.value)return gt("maxInt.value");if(null===F.value)return gt("minInt.value");var W=x.value-F.value+1;(!isFinite(W)||W>Number.MAX_SAFE_INTEGER)&&(W=Number.MAX_SAFE_INTEGER,this.Error("RANDOM was called with a range that exceeds the size that ink numbers can use.")),W<=0&&this.Error("RANDOM was called with minimum as "+F.value+" and maximum as "+x.value+". The maximum must be larger");var V=this.state.storySeed+this.state.previousRandom,L=new Rt(V).next(),R=L%W+F.value;this.state.PushEvaluationStack(new wt(R)),this.state.previousRandom=L;break;case At.CommandType.SeedRandom:var j=yt(this.state.PopEvaluationStack(),wt);if(null==j||j instanceof wt==!1)return this.Error("Invalid value passed to SEED_RANDOM");if(null===j.value)return gt("minInt.value");this.state.storySeed=j.value,this.state.previousRandom=0,this.state.PushEvaluationStack(new Vt);break;case At.CommandType.VisitIndex:var D=this.state.VisitCountForContainer(this.state.currentPointer.container)-1;this.state.PushEvaluationStack(new wt(D));break;case At.CommandType.SequenceShuffleIndex:var B=this.NextSequenceShuffleIndex();this.state.PushEvaluationStack(new wt(B));break;case At.CommandType.StartThread:break;case At.CommandType.Done:this.state.callStack.canPopThread?this.state.callStack.PopThread():(this.state.didSafeExit=!0,this.state.currentPointer=It.Null);break;case At.CommandType.End:this.state.ForceEnd();break;case At.CommandType.ListFromInt:var G=yt(this.state.PopEvaluationStack(),wt),M=mt(this.state.PopEvaluationStack(),Tt);if(null===G)throw new bt("Passed non-integer when creating a list element from a numerical value.");var J=null;if(null===this.listDefinitions)return gt("this.listDefinitions");var U=this.listDefinitions.TryListGetDefinition(M.value,null);if(!U.exists)throw new bt("Failed to find LIST called "+M.value);if(null===G.value)return gt("minInt.value");var q=U.result.TryGetItemWithValue(G.value,kt.Null);q.exists&&(J=new Pt(q.result,G.value)),null==J&&(J=new Pt),this.state.PushEvaluationStack(J);break;case At.CommandType.ListRange:var K=yt(this.state.PopEvaluationStack(),_t),z=yt(this.state.PopEvaluationStack(),_t),H=yt(this.state.PopEvaluationStack(),Pt);if(null===H||null===z||null===K)throw new bt("Expected list, minimum and maximum for LIST_RANGE");if(null===H.value)return gt("targetList.value");var X=H.value.ListWithSubRange(z.valueObject,K.valueObject);this.state.PushEvaluationStack(new Pt(X));break;case At.CommandType.ListRandom:var $=this.state.PopEvaluationStack();if(null===$)throw new bt("Expected list for LIST_RANDOM");var Y=$.value,Q=null;if(null===Y)throw gt("list");if(0==Y.Count)Q=new Ct;else{for(var Z=this.state.storySeed+this.state.previousRandom,tt=new Rt(Z).next(),et=tt%Y.Count,nt=Y.entries(),it=0;it<=et-1;it++)nt.next();var rt=nt.next().value,at={Key:kt.fromSerializedKey(rt[0]),Value:rt[1]};if(null===at.Key.originName)return gt("randomItem.Key.originName");(Q=new Ct(at.Key.originName,this)).Add(at.Key,at.Value),this.state.previousRandom=tt}this.state.PushEvaluationStack(new Pt(Q));break;default:this.Error("unhandled ControlCommand: "+h)}return!0}if(t instanceof Wt){var st=t,ot=this.state.PopEvaluationStack();return this.state.variablesState.Assign(st,ot),!0}if(t instanceof Ft){var ut,lt,ht=t,ct=null;return null!=ht.pathForCount?(ut=ht.containerForCount,lt=this.state.VisitCountForContainer(ut),ct=new wt(lt)):null==(ct=this.state.variablesState.GetVariableWithName(ht.name))&&(this.Warning("Variable not found: '"+ht.name+"'. Using default value of 0 (false). This can happen with temporary variables if the declaration hasn't yet been hit. Globals are always given a default value on load if a value doesn't exist in the save state."),ct=new wt(0)),this.state.PushEvaluationStack(ct),!0}if(t instanceof Lt){var ft=t,vt=this.state.PopEvaluationStack(ft.numberOfParameters),dt=ft.Call(vt);return this.state.PushEvaluationStack(dt),!0}return!1}},{key:"ChoosePathString",value:function(t,e,n){var i=!(1<arguments.length&&void 0!==e)||e,r=2<arguments.length&&void 0!==n?n:[];if(this.IfAsyncWeCant("call ChoosePathString right now"),null!==this.onChoosePathString&&this.onChoosePathString(t,r),i)this.ResetCallstack();else if(this.state.callStack.currentElement.type==Nt.Function){var a="",s=this.state.callStack.currentElement.currentPointer.container;throw null!=s&&(a="("+s.path.toString()+") "),new Error("Story was running a function "+a+"when you called ChoosePathString("+t+") - this is almost certainly not not what you want! Full stack trace: \n"+this.state.callStack.callStackTrace)}this.state.PassArgumentsToEvaluationStack(r),this.ChoosePath(new O(t))}},{key:"IfAsyncWeCant",value:function(t){if(this._asyncContinueActive)throw new Error("Can't "+t+". Story is in the middle of a ContinueAsync(). Make more ContinueAsync() calls or a single Continue() call beforehand.")}},{key:"ChoosePath",value:function(t,e){var n=!(1<arguments.length&&void 0!==e)||e;this.state.SetChosenPath(t,n),this.VisitChangedContainersDueToDivert()}},{key:"ChooseChoiceIndex",value:function(t){t=t;var e=this.currentChoices;this.Assert(0<=t&&t<e.length,"choice out of range");var n=e[t];return null!==this.onMakeChoice&&this.onMakeChoice(n),null===n.threadAtGeneration?gt("choiceToChoose.threadAtGeneration"):null===n.targetPath?gt("choiceToChoose.targetPath"):(this.state.callStack.currentThread=n.threadAtGeneration,void this.ChoosePath(n.targetPath))}},{key:"HasFunction",value:function(t){try{return null!=this.KnotContainerWithName(t)}catch(t){return!1}}},{key:"EvaluateFunction",value:function(t,e,n){var i=1<arguments.length&&void 0!==e?e:[],r=2<arguments.length&&void 0!==n&&n;if(null!==this.onEvaluateFunction&&this.onEvaluateFunction(t,i),this.IfAsyncWeCant("evaluate a function"),null==t)throw new Error("Function is null");if(""==t||""==t.trim())throw new Error("Function is empty or white space.");var a=this.KnotContainerWithName(t);if(null==a)throw new Error("Function doesn't exist: '"+t+"'");var s=[];s.push.apply(s,d(this.state.outputStream)),this._state.ResetOutput(),this.state.StartFunctionEvaluationFromGame(a,i);for(var o=new St;this.canContinue;)o.Append(this.Continue());var u=o.toString();this._state.ResetOutput(s);var l=this.state.CompleteFunctionEvaluationFromGame();return null!=this.onCompleteEvaluateFunction&&this.onCompleteEvaluateFunction(t,i,u,l),r?{returned:l,output:u}:l}},{key:"EvaluateExpression",value:function(t){var e=this.state.callStack.elements.length;this.state.callStack.Push(Nt.Tunnel),this._temporaryEvaluationContainer=t,this.state.GoToStart();var n=this.state.evaluationStack.length;return this.Continue(),this._temporaryEvaluationContainer=null,this.state.callStack.elements.length>e&&this.state.PopCallStack(),n<this.state.evaluationStack.length?this.state.PopEvaluationStack():null}},{key:"CallExternalFunction",value:function(t,e){if(null===t)return gt("funcName");var n=this._externals.get(t),i=null,r=void 0!==n;if(!r||n.lookAheadSafe||null===this._stateSnapshotAtLastNewline){if(!r){if(this.allowExternalFunctionFallbacks)return i=this.KnotContainerWithName(t),this.Assert(null!==i,"Trying to call EXTERNAL function '"+t+"' which has not been bound, and fallback ink function could not be found."),this.state.callStack.Push(Nt.Function,void 0,this.state.outputStream.length),void(this.state.divertedPointer=It.StartOf(i));this.Assert(!1,"Trying to call EXTERNAL function '"+t+"' which has not been bound (and ink fallbacks disabled).")}for(var a=[],s=0;s<e;++s){var o=mt(this.state.PopEvaluationStack(),_t).valueObject;a.push(o)}a.reverse();var u=n.function(a),l=null;null!=u?(l=_t.Create(u),this.Assert(null!==l,"Could not create ink value from returned object of type "+P(u))):l=new Vt,this.state.PushEvaluationStack(l)}else this._sawLookaheadUnsafeFunctionAfterNewline=!0}},{key:"BindExternalFunctionGeneral",value:function(t,e,n){this.IfAsyncWeCant("bind an external function"),this.Assert(!this._externals.has(t),"Function '"+t+"' has already been bound."),this._externals.set(t,{function:e,lookAheadSafe:n})}},{key:"TryCoerce",value:function(t){return t}},{key:"BindExternalFunction",value:function(t,r,e){var a=this;this.Assert(null!=r,"Can't bind a null function"),this.BindExternalFunctionGeneral(t,function(t){a.Assert(t.length>=r.length,"External function expected "+r.length+" arguments");for(var e=[],n=0,i=t.length;n<i;n++)e[n]=a.TryCoerce(t[n]);return r.apply(null,e)},e)}},{key:"UnbindExternalFunction",value:function(t){this.IfAsyncWeCant("unbind an external a function"),this.Assert(this._externals.has(t),"Function '"+t+"' has not been bound."),this._externals.delete(t)}},{key:"ValidateExternalBindings",value:function(t,e){var n,i=null,r=null,a=e||new Set;if(t instanceof Ot&&(i=t),t instanceof T&&(r=t),null===i&&null===r)this.ValidateExternalBindings(this._mainContentContainer,a),this._hasValidatedExternals=!0,0==a.size?this._hasValidatedExternals=!0:(n="Error: Missing function binding for external",n+=1<a.size?"s":"",n+=": '",n+=Array.from(a).join("', '"),n+="' ",n+=this.allowExternalFunctionFallbacks?", and no fallback ink function found.":" (ink fallbacks disabled)",this.Error(n));else if(null!=i){var s,o=pt(i.content);try{for(o.s();!(s=o.n()).done;){var u=s.value;null!=u&&u.hasValidName||this.ValidateExternalBindings(u,a)}}catch(t){o.e(t)}finally{o.f()}var l,h=pt(i.namedContent);try{for(h.s();!(l=h.n()).done;){var c=S(l.value,2)[1];this.ValidateExternalBindings(yt(c,T),a)}}catch(t){h.e(t)}finally{h.f()}}else if(null!=r){var f=yt(r,xt);if(f&&f.isExternal){var v=f.targetPathString;if(null===v)return gt("name");this._externals.has(v)||this.allowExternalFunctionFallbacks&&this.mainContentContainer.namedContent.has(v)||a.add(v)}}}},{key:"ObserveVariable",value:function(t,e){if(this.IfAsyncWeCant("observe a new variable"),null===this._variableObservers&&(this._variableObservers=new Map),!this.state.variablesState.GlobalVariableExistsWithName(t))throw new Error("Cannot observe variable '"+t+"' because it wasn't declared in the ink story.");this._variableObservers.has(t)?this._variableObservers.get(t).push(e):this._variableObservers.set(t,[e])}},{key:"ObserveVariables",value:function(t,e){for(var n=0,i=t.length;n<i;n++)this.ObserveVariable(t[n],e[n])}},{key:"RemoveVariableObserver",value:function(t,e){var n;if(this.IfAsyncWeCant("remove a variable observer"),null!==this._variableObservers)if(null!=e)this._variableObservers.has(e)&&(null!=t?null!=(n=this._variableObservers.get(e))&&(n.splice(n.indexOf(t),1),0===n.length&&this._variableObservers.delete(e)):this._variableObservers.delete(e));else if(null!=t){var i,r=pt(this._variableObservers.keys());try{for(r.s();!(i=r.n()).done;){var a=i.value,s=this._variableObservers.get(a);null!=s&&(s.splice(s.indexOf(t),1),0===s.length&&this._variableObservers.delete(a))}}catch(t){r.e(t)}finally{r.f()}}}},{key:"VariableStateDidChangeEvent",value:function(t,e){if(null!==this._variableObservers){var n=this._variableObservers.get(t);if(void 0!==n){if(!(e instanceof _t))throw new Error("Tried to get the value of a variable that isn't a standard type");var i,r=mt(e,_t),a=pt(n);try{for(a.s();!(i=a.n()).done;){(0,i.value)(t,r.valueObject)}}catch(t){a.e(t)}finally{a.f()}}}}},{key:"globalTags",get:function(){return this.TagsAtStartOfFlowContainerWithPathString("")}},{key:"TagsForContentAtPath",value:function(t){return this.TagsAtStartOfFlowContainerWithPathString(t)}},{key:"TagsAtStartOfFlowContainerWithPathString",value:function(t){var e=new O(t),n=this.ContentAtPath(e).container;if(null===n)return gt("flowContainer");for(;;){var i=n.content[0];if(!(i instanceof Ot))break;n=i}var r,a=null,s=pt(n.content);try{for(s.s();!(r=s.n()).done;){var o=yt(r.value,J);if(!o)break;null==a&&(a=[]),a.push(o.text)}}catch(t){s.e(t)}finally{s.f()}return a}},{key:"BuildStringOfHierarchy",value:function(){var t=new St;return this.mainContentContainer.BuildStringOfHierarchy(t,0,this.state.currentPointer.Resolve()),t.toString()}},{key:"BuildStringOfContainer",value:function(t){var e=new St;return t.BuildStringOfHierarchy(e,0,this.state.currentPointer.Resolve()),e.toString()}},{key:"NextContent",value:function(){var t;this.state.previousPointer=this.state.currentPointer.copy(),(this.state.divertedPointer.isNull||(this.state.currentPointer=this.state.divertedPointer.copy(),this.state.divertedPointer=It.Null,this.VisitChangedContainersDueToDivert(),this.state.currentPointer.isNull))&&(this.IncrementContentPointer()||(t=!1,this.state.callStack.CanPop(Nt.Function)?(this.state.PopCallStack(Nt.Function),this.state.inExpressionEvaluation&&this.state.PushEvaluationStack(new Vt),t=!0):this.state.callStack.canPopThread?(this.state.callStack.PopThread(),t=!0):this.state.TryExitFunctionEvaluationFromGame(),t&&!this.state.currentPointer.isNull&&this.NextContent()))}},{key:"IncrementContentPointer",value:function(){var t=!0,e=this.state.callStack.currentElement.currentPointer.copy();if(e.index++,null===e.container)return gt("pointer.container");for(;e.index>=e.container.content.length;){t=!1;var n=yt(e.container.parent,Ot);if(n instanceof Ot==!1)break;var i=n.content.indexOf(e.container);if(-1==i)break;if((e=new It(n,i)).index++,t=!0,null===e.container)return gt("pointer.container")}return t||(e=It.Null),this.state.callStack.currentElement.currentPointer=e.copy(),t}},{key:"TryFollowDefaultInvisibleChoice",value:function(){var t=this._state.currentChoices,e=t.filter(function(t){return t.isInvisibleDefault});if(0==e.length||t.length>e.length)return!1;var n=e[0];return null===n.targetPath?gt("choice.targetPath"):null===n.threadAtGeneration?gt("choice.threadAtGeneration"):(this.state.callStack.currentThread=n.threadAtGeneration,null!==this._stateSnapshotAtLastNewline&&(this.state.callStack.currentThread=this.state.callStack.ForkThread()),this.ChoosePath(n.targetPath,!1),!0)}},{key:"NextSequenceShuffleIndex",value:function(){var t=yt(this.state.PopEvaluationStack(),wt);if(!(t instanceof wt))return this.Error("expected number of elements in sequence for shuffle index"),0;var e=this.state.currentPointer.container;if(null===e)return gt("seqContainer");if(null===t.value)return gt("numElementsIntVal.value");var n=t.value,i=mt(this.state.PopEvaluationStack(),wt).value;if(null===i)return gt("seqCount");for(var r=i/n,a=i%n,s=e.path.toString(),o=0,u=0,l=s.length;u<l;u++)o+=s.charCodeAt(u)||0;for(var h=o+r+this.state.storySeed,c=new Rt(Math.floor(h)),f=[],v=0;v<n;++v)f.push(v);for(var d=0;d<=a;++d){var p=c.next()%f.length,y=f[p];if(f.splice(p,1),d==a)return y}throw new Error("Should never reach here")}},{key:"Error",value:function(t,e){var n=1<arguments.length&&void 0!==e&&e,i=new bt(t);throw i.useEndLineNumber=n,i}},{key:"Warning",value:function(t){this.AddError(t,!0)}},{key:"AddError",value:function(t,e,n){var i,r=1<arguments.length&&void 0!==e&&e,a=2<arguments.length&&void 0!==n&&n,s=this.currentDebugMetadata,o=r?"WARNING":"ERROR";t=null!=s?(i=a?s.endLineNumber:s.startLineNumber,"RUNTIME "+o+": '"+s.fileName+"' line "+i+": "+t):this.state.currentPointer.isNull?"RUNTIME "+o+": "+t:"RUNTIME "+o+": ("+this.state.currentPointer+"): "+t,this.state.AddError(t,r),r||this.state.ForceEnd()}},{key:"Assert",value:function(t,e){var n=1<arguments.length&&void 0!==e?e:null;if(0==t)throw null==n&&(n="Story assert"),new Error(n+" "+this.currentDebugMetadata)}},{key:"currentDebugMetadata",get:function(){var t=this.state.currentPointer;if(!t.isNull&&null!==t.Resolve()&&null!==(n=t.Resolve().debugMetadata))return n;for(var e=this.state.callStack.elements.length-1;0<=e;--e)if(!(t=this.state.callStack.elements[e].currentPointer).isNull&&null!==t.Resolve()&&null!==(n=t.Resolve().debugMetadata))return n;for(var n,i=this.state.outputStream.length-1;0<=i;--i){if(null!==(n=this.state.outputStream[i].debugMetadata))return n}return null}},{key:"mainContentContainer",get:function(){return this._temporaryEvaluationContainer?this._temporaryEvaluationContainer:this._mainContentContainer}}]),f}(),a.Story.inkVersionCurrent=20,tt=a.Story||(a.Story={}),(et=tt.OutputStateChange||(tt.OutputStateChange={}))[et.NoChange=0]="NoChange",et[et.ExtendedBeyondNewline=1]="ExtendedBeyondNewline",et[et.NewlineRemoved=2]="NewlineRemoved",a.InkList=Ct,Object.defineProperty(a,"__esModule",{value:!0})});
//# sourceMappingURL=ink.js.map

    </script>
    <script>async function preload() {
    const splash = await loadImage("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEABAMAAACuXLVVAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAGUExURQAAAP/YAFIewjUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAACXSURBVHja7dJBCgMhDEDReIN4/8sOkba4mEULogN9DxcusvhEAwAAAAAAAAAAAAAAAABmfRMBAgQ8PCA/czndDwX0QwHRxonaQdT85oCx+szXra1/iW8CIs4G5LSBeoJ6iHF2BLw/QP2BVgG1kI0BN/Otr/VrwHICBAgQIECAAAECBAh4bgAAAAAAAAAAAAAAAAAAfyjiAkM9EgGHYOwCAAAAAElFTkSuQmCC"); 
    const canvas = ONE("#player-canvas");
    const rendering = canvas.getContext("2d");
    rendering.drawImage(splash, 0, 0);
    fitCanvasToParent(canvas);
}

    </script>
    
    
    
    
    
    
    <script>async function startPlayback(font, bundle) {
    const playback = new BipsiPlayback(font);
    await playback.init();
    await playback.loadBundle(bundle);
    playback.start();
}

async function startEditor(font) {
    const editor = new BipsiEditor(font);
    await editor.init();

    // used to show/hide elements in css
    document.documentElement.setAttribute("data-app-mode", "editor");

    // no embedded project, start editor with save or editor embed
    const save = await storage.load("slot0").catch(() => undefined);
    const bundle = save || maker.bundleFromHTML(document, "#editor-embed");
    
    // load bundle and enter editor mode
    await editor.loadBundle(bundle);

    // unsaved changes warning
    window.addEventListener("beforeunload", (event) => {
        if (!editor.unsavedChanges) return;
        event.preventDefault();
        return event.returnValue = "Are you sure you want to exit?";
    });
}

async function makePlayback(font, bundle, story) {
    const playback = new BipsiPlayback(font);
    await playback.initWithStory(story);

    const playCanvas = /** @type {HTMLCanvasElement} */ (ONE("#player-canvas"));
    const playRendering = /** @type {CanvasRenderingContext2D} */ (playCanvas.getContext("2d"));

    // update the canvas size every render just in case..
    playback.addEventListener("render", () => {
        fillRendering2D(playRendering);
        playRendering.drawImage(playback.rendering.canvas, 0, 0);
        fitCanvasToParent(playCanvas);
        document.documentElement.style.setProperty('--vh', `${window.innerHeight / 100}px`);
    });

    // update the canvas size whenever the browser window resizes
    window.addEventListener("resize", () => fitCanvasToParent(playCanvas));
    
    // update the canvas size initially
    fitCanvasToParent(playCanvas);

    let moveCooldown = 0;
    const heldKeys = new Set();
    const keys = new Map();
    keys.set("ArrowLeft",  () => playback.move(-1,  0));
    keys.set("ArrowRight", () => playback.move( 1,  0));
    keys.set("ArrowUp",    () => playback.move( 0, -1));
    keys.set("ArrowDown",  () => playback.move( 0,  1));

    const keyToCode = new Map();
    keyToCode.set("ArrowUp", "KeyW");
    keyToCode.set("ArrowLeft", "KeyA");
    keyToCode.set("ArrowDown", "KeyS");
    keyToCode.set("ArrowRight", "KeyD");

    function doMove(key) {
        const move = keys.get(key);
        if (move) {
            move();
            moveCooldown = .2;
        }
    }

    function doChoice(key){
        const choiceEvent = new CustomEvent('choice', { detail: key});
        playback.dispatchEvent(choiceEvent);
    }

    let prev;
    const timer = (next) => {
        prev = prev ?? Date.now();
        next = next ?? Date.now();
        const dt = Math.max(0, (next - prev) / 1000.);
        moveCooldown = Math.max(moveCooldown - dt, 0);
        prev = next;
        window.requestAnimationFrame(timer);

        if (moveCooldown === 0) {
            const key = Array.from(keys.keys()).find((key) => heldKeys.has(key) || heldKeys.has(keyToCode.get(key)));
            if (key) doMove(key);
        }

        playback.update(dt);
    }
    timer();

    function down(key, code) {
        if (!playback.dialoguePlayback.empty) {
            if(playback.choiceExpected){
                return doChoice(key);
            };
            playback.proceed();
        } else {
            heldKeys.add(key);
            heldKeys.add(code);
            doMove(key);
        }
    }

    function up(key, code) {
        heldKeys.delete(key);
        heldKeys.delete(code);
    }

    const turnToKey = ["ArrowRight", "ArrowDown", "ArrowLeft", "ArrowUp"];
    let ignoreMouse = false;

    window.onblur = () => setTimeout(() => ignoreMouse = true, 0);
    window.onfocus = () => setTimeout(() => ignoreMouse = false, 0);

    document.addEventListener("keydown", (event) => {
        if (!event.repeat) down(event.key, event.code);
        if (event.key !== "Tab") {
            event.stopPropagation();
            event.preventDefault();
        }
    }, { capture: true });
    document.addEventListener("keyup", (event) => up(event.key, event.code));

    document.addEventListener("pointerdown", (event) => {
        if (ignoreMouse) return;

        const threshold = playCanvas.getBoundingClientRect().width / 16 * 2;

        const drag = ui.drag(event);
        let [x0, y0] = [drag.downEvent.clientX, drag.downEvent.clientY];

        if(!playback.choiceExpected){
            playback.proceed();
        };
        

        drag.addEventListener("move", () => {
            const [x1, y1] = [drag.lastEvent.clientX, drag.lastEvent.clientY];
            const [dx, dy] = [x1 - x0, y1 - y0];

            const dist = Math.max(Math.abs(dx), Math.abs(dy));
            const angle = Math.atan2(dy, dx) + Math.PI * 2;
            const turns = Math.round(angle / (Math.PI * .5)) % 4;
            const nextKey = turnToKey[turns];

            if (dist >= threshold) {
                if(playback.choiceExpected){
                    return doChoice(nextKey);
                }else{
                    doMove(nextKey);
                    x0 = x1;
                    y0 = y1;
                }
                
            } 
        });
    });

    function captureGif() {
        const frames = recordFrames(playback);
        const giffer = window.open(
            "https://kool.tools/tools/gif/",
            "gif maker",
            "left=10,top=10,width=512,height=512,resizable=no,location=no",
        );
        sleep(500).then(() => giffer.postMessage({ name: "bipsi", frames }, "https://kool.tools"));
    }

    function getRoomListing() {
        const current = getLocationOfEvent(playback.data, getEventById(playback.data, playback.avatarId));
        const rooms = [];
        const thumb = createRendering2D(16, 16);
        const preview = createRendering2D(128, 128);
        playback.data.rooms.forEach((room) => {
            drawRoomPreviewPlayback(preview, playback, room.id);
            drawRoomThumbPlayback(thumb, playback, room.id);
            rooms.push({ id: room.id, thumb: thumb.canvas.toDataURL(), preview: preview.canvas.toDataURL() });
        });
        postMessageParent({ type: "room-listing", rooms, current }, "*");
    }

    /** @type {Map<string, (any) => void>} */
    const debugHandlers = new Map();

    debugHandlers.set("move-to", (message) => moveEventById(playback.data, playback.avatarId, message.destination));
    debugHandlers.set("key-down", (message) => down(message.key, message.code));
    debugHandlers.set("key-up", (message) => up(message.key, message.code));
    debugHandlers.set("capture-gif", (message) => captureGif());
    debugHandlers.set("get-room-listing", (message) => getRoomListing());

    // only allow these when playtesting from editor
    if (document.documentElement.getAttribute("data-debug")) {
        debugHandlers.set("touch-location", (message) => playback.touch(getEventAtLocation(playback.data, message.location)));

        // if the game runs javascript from variables then this would be a 
        // vector to run arbitrary javascript on the game's origin giving
        // read/write access to storage for that origin and the power to e.g
        // erase all game saves etc
        debugHandlers.set("set-variable", (message) => playback.setVariable(message.key, message.value));
    }

    window.addEventListener("message", (event) => {
        debugHandlers.get(event.data.type)?.call(this, event.data);
    });

    document.documentElement.setAttribute("data-app-mode", "player");
    await playback.loadBundle(bundle);
    playback.start();

    return playback;
}

async function start() {
    const font = await loadBasicFont(ONE("#font-embed"));

    // determine if there is a project bundle embedded in this page
    const bundle = maker.bundleFromHTML(document);

    const storyContent = maker.bundleFromHTML(document, "#story-embed");
    const story = new inkjs.Story(storyContent);

    if (bundle) {
        await makePlayback(font, bundle, story);
    } else {
        await startEditor(font);
    }
}

    </script>
    
    <style>
/* prevent weird highlights https://stackoverflow.com/questions/21003535/ */
.no-select {
    -webkit-tap-highlight-color: transparent;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
}

/* hidden elements should be hidden regardless of their display style */
[hidden] { display: none !important; }

/* default to width/height including padding and border */
* { box-sizing: border-box; }

/* used dynamically to prevent or cancel smooth transitions */
.skip-transition { transition: none !important; }

/* make buttons and select inherit font */ 
button, select { font-family: inherit; font-size: inherit; }

/* clickable things should use this cursor imo */
button, a, input[type="radio"], input[type="checkbox"], select, option, label, summary { cursor: pointer; }

/* crisp pixelart for images and backgrounds */
* {
    image-rendering: -moz-crisp-edges;
    image-rendering: -webkit-crisp-edges;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
}

/* prevent pull down to refresh page (and lose data rip) */
body {
    overscroll-behavior-y: contain;
}

html, body {
    margin: 0; padding: 0;
    width: 100%;
    min-height: calc(var(--vh, 1vh) * 100);

    overflow: hidden auto;
    overscroll-behavior-y: contain;
}

body {
    display: flex; flex-direction: column;
    justify-content: center;
    align-items: center;

    background: black;
    color: white;
}

    </style>
    <style>body, canvas {
    touch-action: none;
}

#player {
    position: absolute;
    width: 100%; height: 100%;
    overflow: hidden;

    display: flex;
    flex-direction: column;

    padding-bottom: 0;
    gap: 1em;
}

#player-container {
    flex: 1;

    display: flex;
    flex-direction: column;
    justify-content: start;
    align-items: center;

    margin: 0 auto;
    max-width: 512px;
    width: 100%;
}

@media screen and (max-width: 640px) {
    #player-container {
        max-width: 100%;
        width: 100%;
    }
}


#player-container #player-choices{
    margin-top: 0.8em;
    width: 100%;
    padding: 1em;
}
#player-container #player-choices ul{
    font-family: "Press Start 2P";
    list-style: none;
    font-size: 0.8em;
    margin: 0; padding: 0
}
#player-container #player-choices ul li{
    margin: 0; padding: 0;
}
#player-container #player-choices ul li:not(last-child){
    margin-bottom: 1em;
}
#player-container #player-choices a{
    color: white;
    text-decoration: none;
}

    </style>
    
  </head>
  <body class="no-select" onload="start()">
    <div id="player" hidden="hidden">
      <div id="player-container">
        <canvas id="player-canvas" width="256" height="256"></canvas>
      </div>
    </div>
    
    <script id="plugins"></script>
    <script>preload();</script>
    <script id="bundle-embed" type="application/json">{"project":{"rooms":[{"id":0,"palette":0,"tilemap":[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],[0,1,2,2,2,2,2,2,4,2,2,2,2,2,1,0],[0,1,0,0,0,0,0,0,0,0,0,1,0,0,1,0],[0,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0],[0,1,0,0,8,8,8,8,8,8,8,8,0,0,1,0],[0,1,0,0,0,0,0,0,0,0,0,0,0,0,4,0],[0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0],[0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0],[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],[0,2,2,2,2,2,2,4,2,2,2,2,2,2,2,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]],"highmap":[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]],"wallmap":[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],[0,1,0,0,0,0,0,0,0,0,0,1,0,0,1,0],[0,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0],[0,1,0,0,1,1,1,1,1,1,1,1,0,0,1,0],[0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1],[0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0],[0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0],[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],[0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]],"events":[{"id":8,"position":[6,14],"fields":[{"key":"is-player","type":"tag","data":true},{"key":"graphic","type":"tile","data":6},{"key":"page-color","type":"text","data":"black"},{"key":"say-style","type":"json","data":{"noMargin":true,"anchorX":0,"anchorY":1,"lines":3,"panelColor":"#2d1b00","textColor":"#c4f0c2"}}]},{"id":9,"position":[9,7],"fields":[{"key":"graphic","type":"tile","data":9},{"key":"solid","type":"tag","data":true}]},{"id":10,"position":[7,13],"fields":[{"key":"exit","type":"location","data":{"room":0,"position":[7,11]}}]},{"id":11,"position":[7,12],"fields":[{"key":"exit","type":"location","data":{"room":0,"position":[7,14]}}]},{"id":12,"position":[9,8],"fields":[{"key":"reception_talk","type":"tag","data":true}]},{"id":13,"position":[14,9],"fields":[{"key":"reception-to-corridor1","type":"tag","data":true},{"key":"reception-from-corridor1","type":"tag","data":true}]},{"id":18,"position":[7,14],"fields":[{"key":"desk-from-start","type":"tag","data":true}]},{"id":33,"position":[4,6],"fields":[{"key":"access-behind-desk","type":"tag","data":true}]},{"id":34,"position":[3,6],"fields":[{"key":"behind-desk-pushback","type":"tag","data":true}]},{"id":41,"position":[2,11],"fields":[{"key":"graphic","type":"tile","data":7},{"key":"solid","type":"tag","data":true},{"key":"patch","type":"file","data":"8"},{"key":"cat","type":"tag","data":true}]}],"backmap":[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]],"foremap":[[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]]},{"id":1,"palette":0,"tilemap":[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0],[0,0,0,1,2,14,15,2,2,2,4,2,1,0,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,10,0,0,0],[0,0,0,4,0,0,0,0,0,0,0,0,4,0,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0],[0,0,0,2,2,2,2,2,2,2,2,2,2,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]],"backmap":[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]],"foremap":[[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,2,2,1,1,1,2,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,2,1,1,1,1,1,1,1,1,2,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],"wallmap":[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0],[0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0],[0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]],"events":[{"id":17,"position":[3,8],"fields":[{"key":"corridor1-from-reception","type":"tag","data":true},{"key":"corridor1-to-reception","type":"tag","data":true}]},{"id":30,"position":[12,8],"fields":[{"key":"elevator-1","type":"tag","data":true},{"key":"elevator","type":"tag","data":true}]}]},{"id":3,"palette":0,"tilemap":[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0],[0,0,0,1,2,2,4,2,2,4,2,2,1,0,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,11,0,0,0],[0,0,0,4,0,0,0,0,0,0,0,0,4,0,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0],[0,0,0,2,2,2,2,2,2,2,2,2,2,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]],"backmap":[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]],"foremap":[[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,2,1,1,2,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,2,1,1,1,1,1,1,1,1,2,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],"wallmap":[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0],[0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0],[0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]],"events":[{"id":31,"position":[12,8],"fields":[{"key":"elevator-2","type":"tag","data":true},{"key":"elevator","type":"tag","data":true}]}]},{"id":4,"palette":0,"tilemap":[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0],[0,0,0,1,2,2,4,2,2,4,2,2,1,0,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,12,0,0,0],[0,0,0,4,0,0,0,0,0,0,0,0,4,0,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0],[0,0,0,2,2,2,2,2,2,2,2,2,2,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]],"backmap":[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]],"foremap":[[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,2,1,1,2,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,2,1,1,1,1,1,1,1,1,2,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],"wallmap":[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0],[0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0],[0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]],"events":[{"id":26,"position":[12,8],"fields":[{"key":"elevator-3","type":"tag","data":true},{"key":"elevator","type":"tag","data":true}]}]},{"id":5,"palette":0,"tilemap":[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],[1,2,2,3,2,2,2,3,2,2,3,2,1,0,0,0],[1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0],[1,0,20,17,17,17,17,17,17,24,0,0,13,0,0,0],[1,0,22,16,16,16,16,16,16,23,0,0,4,0,0,0],[1,0,21,18,18,18,18,18,18,19,0,0,1,0,0,0],[1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0],[1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],[2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]],"backmap":[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]],"foremap":[[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],"wallmap":[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],[1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],[1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0],[1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0],[1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0],[1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0],[1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0],[1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],[1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]],"events":[{"id":32,"position":[12,8],"fields":[{"key":"elevator-4","type":"tag","data":true},{"key":"elevator","type":"tag","data":true}]},{"id":40,"position":[8,6],"fields":[{"key":"graphic","type":"tile","data":7},{"key":"solid","type":"tag","data":true},{"key":"patch","type":"file","data":"8"},{"key":"cat","type":"tag","data":true}]}]},{"id":2,"palette":0,"tilemap":[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,10],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,11],[0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,12],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,13],[0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]],"backmap":[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]],"foremap":[[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2],[1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,2],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],"wallmap":[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]],"events":[{"id":20,"position":[12,8],"fields":[{"key":"elevator-in","type":"tag","data":true}]},{"id":35,"position":[11,8],"fields":[{"key":"elevator-exit","type":"tag","data":true}]},{"id":36,"position":[15,6],"fields":[{"key":"elevator-1","type":"tag","data":true}]},{"id":37,"position":[15,7],"fields":[{"key":"elevator-2","type":"tag","data":true}]},{"id":38,"position":[15,8],"fields":[{"key":"elevator-3","type":"tag","data":true}]},{"id":39,"position":[15,9],"fields":[{"key":"elevator-4","type":"tag","data":true}]}]}],"palettes":[["#c4f0c2","#5ab9a8","#1e606e"],["#192b33","#201f7f","#958fbf"],["#2f1933","#7f1f24","#bf908f"],["#251933","#5f1f7f","#bf8fac"],["#193233","#451f7f","#bf8faf"],["#331920","#6b7f1f","#8fbfb0"],["#332219","#7f651f","#bfba8f"],["#332719","#547f1f","#8fbfae"]],"tileset":"156","tiles":[{"id":1,"frames":[1]},{"id":2,"frames":[5]},{"id":8,"frames":[8]},{"id":3,"frames":[4]},{"id":4,"frames":[6]},{"id":14,"frames":[14]},{"id":15,"frames":[15]},{"id":10,"frames":[10]},{"id":11,"frames":[11]},{"id":12,"frames":[12]},{"id":13,"frames":[13]},{"id":5,"frames":[7]},{"id":6,"frames":[0]},{"id":9,"frames":[9]},{"id":7,"frames":[2,3]},{"id":16,"frames":[16,17]},{"id":17,"frames":[18,19]},{"id":18,"frames":[20,21]},{"id":19,"frames":[22,23]},{"id":20,"frames":[24,25]},{"id":21,"frames":[26,27]},{"id":22,"frames":[28,29]},{"id":23,"frames":[30,31]},{"id":24,"frames":[32,33]}]},"resources":{"8":{"type":"file-datauri","data":{"name":"cat-patch.png","uri":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAaCAYAAACtv5zzAAAAAXNSR0IArs4c6QAAAKBJREFUSIlj1JVm+M9AQ8BES8NHLRjEFky/eoigRmLU4LSAmpbgtCBT246gAcSoYaHUAJiaTG070i2AGUAJwAgifK7BBigKImIMhDkGl8Pw5gNiwp8QwGsBpeHPwEBCEMGCgFRLiS4qyPUNQQtg8YBOo6vB5QAMC9AzF3JGwmYQoYTAiKvKJJQfYAYTCjqcFhByHbFxgtcCaoBhWqMNKQsAKjVN31Vy5DsAAAAASUVORK5CYII=","type":"image/png"}},"156":{"type":"canvas-datauri","data":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAAAYCAYAAAAyC/XlAAAAAXNSR0IArs4c6QAAAotJREFUaEPtWu1ywzAIW97/obNLb+yYKkAxSTtv3p81ccB8CJCbbh/ub9/3/bjctm2z23bPP+c/+2ejZ6r70R6H7mp/tBf9qeyr9Js8Phfdr3y9Yz3ykeXzKT4KALINqgB3HT6cQCD46ypBHsj+WfYZbbW9j/vZZyyIDNCmi8VlBFSZjLL2XeneMOwArBLtXvYfg++D6IPa6QB+/6z6swqu/GNJY8GtAu4rktmjrjPAnS1Ey0XY6rFCIoNZdbKKMaMZuLIu4fdV9mIVX1Ww0uGqEYCFkPmUjbZoDbsegqUFgKoCqwrBJCkAwJYatURlRmNnwf0rAFyZrCy5xldUn6LRwsAwDAA2Y9HQMwCIKh2DrBqscIAuAFhnyTpPlsiR6lbjHfE1NlpNZzXaf4yALklCxDKDVYCcrRYEVMQ3qu7EupnSQRigI12MU7CERZ3p0g7AZqbSnjGREUuu9GftFwPV5QAMoEo7VgBQ+XHXekSCq/2eSGAlEK1XAaz0qqOg0sPW2WjIutLIHr5yR23IYlD5kNlcyT7WR52eQU4JwLsTqNg4WiSS7hkSOWqjEoAFgK/oRqQpI1PYTtkZ/53yyFPYLDcAjPrvTykj/nflGcdi3CnkYoy8oVHsmgVOkcsY7KvlESCRn+ir8R4kYL9RHr+geiLSGcPNKtzLVScA3APReJd8pZcd09ROEFXZq+UjECp5XSSQvP1EvqHwiA6L7+qf/hTQPUaOEkQv101g14bO/m0AdBMwekTpBm3JXxOB9HuAO9vTNeYvLd0ILAB0Izi5PH0ZdOoc6X4+Nnks/qX5j9/c4VtA5TyOZ+h/Gb0/4PSjA0TnZeUcvUjg3ChYHGDu/LWtXwBoh3BuBZ+t06hAQ6EArQAAAABJRU5ErkJggg=="}}}</script>
    
    <script id="story-embed" type="application/json">{"inkVersion":20,"root":[["\n","\n","\n","\n","^Sprout Detective ",{"#":"TITLE"},"\n",{"->":"init"},["done",{"#n":"g-0"}],null],"done",{"init":[["ev","str","^auto: start game","/str","/ev",{"*":".^.c-0","flg":4},{"c-0":["\n","^SPAWN_AT(desk-from-start)","\n",{"->":"reception"},null]}],null],"elevator_thread":[["ev","str","^tag: elevator","/str","/ev",{"*":".^.c-0","flg":4},{"c-0":["\n","^SPAWN_AT(elevator-in)","\n",{"->":"elevator"},"done",null]}],null],"elevator":[[["ev","visit",1,"MIN","/ev","ev","du",0,"==","/ev",{"->":".^.s0","c":true},"ev","du",1,"==","/ev",{"->":".^.s1","c":true},"nop",{"s0":["pop","^You are in the elevator",{"->":".^.^.17"},null],"s1":["pop",{"->":".^.^.17"},null],"#f":5}],"\n",["ev","str","^tag: elevator-1","/str","/ev",{"*":".^.c-0","flg":4},"ev","str","^tag: elevator-2","/str","/ev",{"*":".^.c-1","flg":4},"ev","str","^tag: elevator-3","/str","/ev",{"*":".^.c-2","flg":4},"ev","str","^tag: elevator-4","/str","/ev",{"*":".^.c-3","flg":4},"ev","str","^tag: elevator-exit","/str","/ev",{"*":".^.c-4","flg":4},{"c-0":["\n","ev",1,{"f()":"moveElevator"},"pop","/ev","\n",{"->":".^.^"},null],"c-1":["\n","ev",2,{"f()":"moveElevator"},"pop","/ev","\n",{"->":".^.^"},null],"c-2":["\n","ev",3,{"f()":"moveElevator"},"pop","/ev","\n",{"->":".^.^"},null],"c-3":["\n","ev",4,{"f()":"moveElevator"},"pop","/ev","\n",{"->":".^.^"},null],"c-4":["\n","ev",{"VAR?":"currentFloor"},"/ev",["du","ev",1,"==","/ev",{"->":".^.b","c":true},{"b":["pop","\n","^SPAWN_AT(elevator-1)","\n",{"->":"corridor1"},{"->":".^.^.^.9"},null]}],["du","ev",2,"==","/ev",{"->":".^.b","c":true},{"b":["pop","\n","^SPAWN_AT(elevator-2)","\n",{"->":"corridor2"},{"->":".^.^.^.9"},null]}],["du","ev",3,"==","/ev",{"->":".^.b","c":true},{"b":["pop","\n","^SPAWN_AT(elevator-3)","\n",{"->":"corridor3"},{"->":".^.^.^.9"},null]}],["du","ev",4,"==","/ev",{"->":".^.b","c":true},{"b":["pop","\n","^SPAWN_AT(elevator-4)","\n",{"->":"swimming_pool"},{"->":".^.^.^.9"},null]}],"pop","nop","\n",null],"#n":"opts"}],null],null],"moveElevator":[{"temp=":"to"},"ev",{"VAR?":"to"},{"VAR?":"currentFloor"},"==","/ev",[{"->":".^.b","c":true},{"b":["\n","^You already are on Floor ","ev",{"VAR?":"to"},"out","/ev","\n",{"->":".^.^.^.8"},null]}],[{"->":".^.b"},{"b":["\n","^You feel the elevator moving ","ev",{"VAR?":"to"},{"VAR?":"currentFloor"},">","/ev",[{"->":".^.b","c":true},{"b":["^ up",{"->":".^.^.^.9"},null]}],[{"->":".^.b"},{"b":["^down",{"->":".^.^.^.9"},null]}],"nop","\n","ev",{"VAR?":"to"},"/ev",{"VAR=":"currentFloor","re":true},{"->":".^.^.^.8"},null]}],"nop","\n",null],"corridor1":[["thread",{"->":"elevator_thread"},"ev","str","^tag: corridor1-to-reception","/str","/ev",{"*":".^.c-0","flg":4},{"c-0":["\n","^SPAWN_AT(reception-from-corridor1)","\n",{"->":"reception"},"done",null]}],null],"corridor2":["thread",{"->":"elevator_thread"},"done",null],"corridor3":["thread",{"->":"elevator_thread"},"done",null],"swimming_pool":[[["ev","visit",1,"MIN","/ev","ev","du",0,"==","/ev",{"->":".^.s0","c":true},"ev","du",1,"==","/ev",{"->":".^.s1","c":true},"nop",{"s0":["pop","\n","^swimming pool ",{"#":"TITLE"},"\n",{"->":".^.^.17"},null],"s1":["pop",{"->":".^.^.17"},null],"#f":5}],"\n",["thread",{"->":"elevator_thread"},"ev","str","^tag: cat","/str","/ev",{"*":".^.c-0","flg":4},{"c-0":["\n","^I'm a cat. But not just any cat. I'm the cat of the ##[REDACTED]##. And I have an eye patch! ",{"#":"cat-patch"},"\n",{"->":".^.^.^.g-0"},null],"#n":"opts"}],{"g-0":[{"->":".^.^.opts"},null]}],null],"reception":[[["ev","str","^tag: reception_talk","/str","/ev",{"*":".^.c-0","flg":4},"ev","str","^tag: reception-to-corridor1","/str","/ev",{"*":".^.c-1","flg":4},"ev","str","^tag: access-behind-desk","/str","/ev",{"*":".^.c-2","flg":4},"ev","str","^tag: cat","/str","/ev",{"*":".^.c-3","flg":4},{"c-0":["\n",{"->t->":"talk_to_receptionist"},{"->":".^.^.^.g-0"},null],"c-1":["\n","^SPAWN_AT(corridor1-from-reception)","\n",{"->":"corridor1"},{"->":".^.^.^.g-0"},null],"c-2":["\n","^This is for staff only, go back ! ",{"#":"receptionist-angry"},"\n","^SPAWN_AT(behind-desk-pushback)","\n",{"->":".^.^.^.g-0"},null],"c-3":["\n","^I'm a cat. But not just any cat. I'm the cat of the ##[REDACTED]##. And I have an eye patch! ",{"#":"cat-patch"},"\n",{"->":".^.^.^.g-0"},null],"#n":"opts"}],{"g-0":[{"->":".^.^.opts"},null]}],null],"talk_to_receptionist":[["^Welcome to Lich Hotel. ",{"#":"receptionist-bored"},"\n","^Do you have a room here ? ",{"#":"receptionist-bored"},"\n",["ev",{"^->":"talk_to_receptionist.0.6.$r1"},{"temp=":"$r"},"str",{"->":".^.s"},[{"#n":"$r1"}],"/str","/ev",{"*":".^.^.c-0","flg":2},{"s":["^Yes",{"->":"$r","var":true},null]}],["ev",{"^->":"talk_to_receptionist.0.7.$r1"},{"temp=":"$r"},"str",{"->":".^.s"},[{"#n":"$r1"}],"/str","/ev",{"*":".^.^.c-1","flg":2},{"s":["^No",{"->":"$r","var":true},null]}],{"c-0":["ev",{"^->":"talk_to_receptionist.0.c-0.$r2"},"/ev",{"temp=":"$r"},{"->":".^.^.6.s"},[{"#n":"$r2"}],"\n",{"->":".^.^.g-0"},null],"c-1":["ev",{"^->":"talk_to_receptionist.0.c-1.$r2"},"/ev",{"temp=":"$r"},{"->":".^.^.7.s"},[{"#n":"$r2"}],"\n",{"->":".^.^.g-0"},null],"g-0":["^So why bother me ?","\n","ev","void","/ev","->->",null]}],null],"global decl":["ev",1,{"VAR=":"currentFloor"},"/ev","end",null]}],"listDefs":{}}</script>
    <script id="font-embed" type="text" data-char-width="6" data-char-height="8" data-runs="0,9786-9787,9829-9830,9827,9824,8226,9688,9675,9689,9794,9792,9834-9835,9788,9658,9668,8597,8252,182,167,9644,8616,8593,8595,8594,8592,8735,8596,9650,9660,32-126,8962,199,252,233,226,228,224,229,231,234,235,232,239,238,236,196-197,201,230,198,244,246,242,251,249,255,214,220,162-163,165,8359,402,225,237,243,250,241,209,170,186,191,8976,172,189,188,161,171,187,9617-9619,9474,9508,9569-9570,9558,9557,9571,9553,9559,9565,9564,9563,9488,9492,9524,9516,9500,9472,9532,9566-9567,9562,9556,9577,9574,9568,9552,9580,9575-9576,9572-9573,9561,9560,9554-9555,9579,9578,9496,9484,9608,9604,9612,9616,9600,945,223,915,960,931,963,181,964,934,920,937,948,8734,966,949,8745,8801,177,8805,8804,8992,8993,247,8776,176,8729,183,8730,8319,178,9632,160">data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAACACAMAAADDApyIAAAABlBMVEUAAAD///+l2Z/dAAAAAXRSTlMAQObYZgAABWtJREFUaN7tWkuW2zAMI+5/6S5qSwQIUnYy01XdNi91LEGk+IUVcV0A1iddcgPAeih/X2PXb3UaxDUAaVYe1gAAuGa4Zgbi/rPGpZsZRiW7JsU95/WRAOLvWLA+sgQ3wF77urP+XQu4vl2fAvh30QvgFogBBNICIFiWOElg1l72IKsIsZWJtQWyB6xrqBWVPaDv1/+xBSi2+PzqzbQfQktdUgepKz8K5x9m0m3E2zNuhYO3vVdjAUvGm72EbCYDZHWSRQUtSwF4KcsqVEUhXl1WnSGRFlEAnAQJhyQw+s2GfPucSkl7QM53+0eor8pODACNFcUOAJg3luT75vpuhu3i7MKxYk322MBHq7sAkGPL3ovgjCJWP3vxPV3sLcqS0DyoMQrn+Y03dgpBWD9wW42YAJL1cfJ7LAGmgLnC0vJoC1BSTUr5aOFywMo5rDiMrMt//7ELB/dBrY7AMccFss4mc3jfithlxzIjyFDIM5NN3jPLloCMHzo/A0AdEIC6I+etFLqXiiTYLRUxAHzo2YqAqgJ7K7awOTRj2mTQB8pAWIXor1yl2DrKZzQeQfaQaqtSBnln/E0PsBLw91oOL/tBNdxiY2r7/jPc4GTWkpM4qVz20kwKk4UdQDaQ/Ce0ggMAWW9WV9TC667Ui5RQCcByxCMVwUhQwkn3wxuAaR6yjdaKdiYSC+GxcFb06xcGP8DJiGtuqFm6Gyxabp6xcVI67WZjHQAoT8jc0JxBKuqqaANAtb0JbT7RpfVFtCqClHkwXV4LUKI/59XStRkAX9BsdkTtt9RuRfu9Ff0r+9ceEUPxbdvqyFVlX4qeATClrxNA0rV2zijZGJSwuQNKvS/g9uMUEnLs1MoqKHijult0+SBJ0AIgzgBzPiAVHSSIUYJ5D1gCJPfMd4Si+q5P/ldeBcPZPeOUXlV2ZVeyqu8NLDm5BEFSPYA+XK8KjEsMSBs5AVQzzfuCrkAPtn2oheeBGBJOD8A5AMwCQYqdSUUSfyAxpLbaUSKPadJOvecbw3zMHAgnlMjNqHHR/CodmXCPT9aOB64Pk04gST8Kk1prUPOrYXsQ2tlJ/HOfQ/1cpg5URxOLqp+mJWnYSFu+49grhPQ/vuIyTBgM5+wkMIwMarsMOFLlc+N/OZCzWHq5QS86NAKmaZDaQlsHfSYNxUXK0tTLhxCwRNUMf6NkBYShRJEbubd/Q6kHazKQxPMOQCQAbHRqAZByA1oVsQ6YZVs5GY4LojqsMkW6akm+n9r08xdonemgePjchL1LW7WpRTNad3tmfsM+WrYO+3LECWRBujnEh9WSVjP5Ci3QYoVaRW+g/F7TNMPaRQMiAYwEEA8wb/+HLqylW9jq1ZUstyJ1PeLnuNI3rOo+jWBfN40VCZo78Cj+HWTw+QhkThH9HaY9C9s5RJUzK/lEAlCIjFIEKEPaFgqHPcgSYCxrDi8auz0AEN8BnPcgfleCnwDA9OK0mbT6h/v+BgDE0QfSGRfsdIt6/wMJZlqqJdcypr0jLwJkvZMEfX71XhpjFDqUoP8BDAC+KeKTjVCJRTTAquHxFkBNbQB4KwHq1QGYJ8djMOiuVoKxHHk09fcAeHJ9BoDn11sAvL3GTZYibzYm1JNpOBmc1NI4EUPhmLtSpkaWQPpFaUKZflA+tbJcRBEZDhx85EyLF32jwLQn8q84SKA0LJTjo1VzZXIEoDMvMJQTLDECd7bEq4jCX7eBAThixFjRDxHxH5zAgDAlfPK2nH+Atrd68qYHPQHY52HaLC1YVt01A5S3Qq0E+UivvBg9AxBF1LAO+YD1a4BE3qHQ+2yLeqzkDAACwERJiBYf7UHmTeZoWYL8OyuSuP8H7ZUOIucBHAwAAAAASUVORK5CYII=</script>
  </body>
</html>