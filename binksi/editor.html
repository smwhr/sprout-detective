<!DOCTYPE html>
<html lang="en" data-remix-generation="0" data-app-mode="editor">
  <head>
    <title>binksi</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta charset="utf-8"/>
    <link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAAXNSR0IArs4c6QAAAAxQTFRFAAAAAxmR8+/s3i5SinG4LAAAAAR0Uk5TAP///7MtQIgAAABGSURBVBiVlY9BDgAgCMPY/P+fhQlo9GQTknXxMM0CCivYpA+PcQCXu8RVcxeeBav5K6CC6RDsVajCtiB3HJ5TL99vnv8qTuMLAYu9aKwhAAAAAElFTkSuQmCC"/>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Press+Start+2P" type="text/css"/>
    <!-- scripts-->
    <script></script>
    <script>"strict"
const maker = {};
const ui = {};

/**
 * @template TProject
 * @typedef {(project: TProject) => string[]} maker.ManifestFunction
 */

/**
 * @typedef {Object} ResourceData
 * @property {string} type
 * @property {any} data
 */

/**
 * @typedef {Object.<string, ResourceData>} maker.ResourceBundle
 */

/**
 * @template TProject
 * @typedef {Object} maker.ProjectBundle
 * @property {TProject} project
 * @property {maker.ResourceBundle} resources
 */

/**
 * @template TData
 * @template TInstance
 * @typedef {Object} maker.ResourceHandler
 * @property {(data: TData) => Promise<TInstance>} load
 * @property {(instance: TInstance) => Promise<TInstance>} copy
 * @property {(instance: TInstance) => Promise<TData>} save
 */

/** @type {Map<string, maker.ResourceHandler<any, any>>} */
maker.resourceHandlers = new Map();

// add a resource type called "canvas-datauri" that describes how to load a
// canvas rendering context from a datauri, how to copy one, and how to convert
// one back into a datauri
maker.resourceHandlers.set("canvas-datauri", {
    load: async (data) => imageToRendering2D(await loadImage(data)),
    copy: async (instance) => copyRendering2D(instance),
    save: async (instance) => instance.canvas.toDataURL("image/png", 1),
});

maker.resourceHandlers.set("file-datauri", {
    load: async (data) => new File([await fetch(data.uri).then((r) => r.blob())], data.name, { type: data.type }),
    copy: async (instance) => new File([await instance.arrayBuffer()], instance.name, { type: instance.type }),
    save: async (instance) => ({ 
        name: instance.name, 
        uri: await maker.dataURIFromFile(instance), 
        type: instance.type,
    }),
});

maker.ResourceManager = class {
    constructor() {
        this.lastId = 0;
        /** @type {Map<string, { type: string, instance: any }>} */
        this.resources = new Map();
    }

    /**
     * Generate a new unique id for a resource.
     * @returns {string}
     */
    generateId() {
        this.lastId += 1;
        // just next lowest unused number
        while (this.resources.has(this.lastId.toString())) {
            this.lastId += 1;
        }

        return this.lastId.toString();
    }
    
    /**
     * Clear all resources.
     */
    clear() {
        this.resources.clear();
    }

    /**
     * Get the resource instance with the given id.
     * @param {string} id 
     * @returns {any}
     */
    get(id) {
        return this.resources.get(id)?.instance;
    }

    /**
     * Add a resource instance at a specific id.
     * @param {string} id 
     * @param {any} instance 
     * @param {string} type 
     */
    set(id, instance, type) {
        this.resources.set(id, { type, instance });
    }

    /**
     * Add an instance as a new resource and return its new id.
     * @param {any} instance 
     * @param {string} type 
     * @returns {string}
     */
    add(instance, type) {
        const id = this.generateId();
        this.set(id, instance, type);
        return id;
    }

    /**
     * Copy the existing resource with the given id and add it as a new resource.
     * @param {string} id 
     * @returns 
     */
    async fork(id) {
        const source = this.resources.get(id);
        const forkId = this.generateId();
        const instance = await maker.resourceHandlers.get(source.type).copy(source.instance); 
        this.set(forkId, instance, source.type);
        return { id: forkId, instance };
    }

    /**
     * Discard all resources except those at the ids given.
     * @param {Iterable<string>} keepIds 
     */
    prune(keepIds) {
        const ids = new Set(keepIds);

        this.resources.forEach((_, id) => {
            if (!ids.has(id)) this.resources.delete(id);
        });
    }

    /**
     * Copy all resources from another resource manager.
     * @param {maker.ResourceManager} other 
     */
    async copyFrom(other) {
        const tasks = [];
        Array.from(other.resources).forEach(([id, { type, instance }]) => {
            const task = maker.resourceHandlers.get(type)
                         .copy(instance)
                         .then((copy) => this.set(id, copy, type));
            tasks.push(task);
        });

        return Promise.all(tasks);
    }

    /**
     * Save all resources in an object mapping id to type and save data.
     * @param {Iterable<string>} ids 
     * @returns {Promise<maker.ResourceBundle>}
     */
    async save(ids) {
        /** @type {maker.ResourceBundle} */
        const bundle = {};

        const resourceIds = new Set(ids);
        const relevant = Array.from(this.resources)
                         .filter(([id]) => resourceIds.has(id));

        const tasks = [];
        Array.from(relevant).forEach(([id, { type, instance }]) => {
            const task = maker.resourceHandlers.get(type)
                         .save(instance)
                         .then((data) => bundle[id] = { type, data });
            tasks.push(task);
        });

        await Promise.all(tasks);
        return bundle;
    }

    /**
     * Load all resources from the given bundle.
     * @param {maker.ResourceBundle} bundle 
     */
    async load(bundle) {
        const tasks = [];
        Object.entries(bundle).forEach(([id, { type, data }]) => {
            const task = maker.resourceHandlers.get(type)
                         .load(data)
                         .then((instance) => this.set(id, instance, type));
            tasks.push(task);
        });
        return Promise.all(tasks);
    }
}

/**
 * 
 * @template TState
 */
maker.StateManager = class extends EventTarget {
    /**
     * Create a state manager, optionally providing a function that describes
     * how to determine resource dependencies of a given state. 
     * @param {maker.ManifestFunction<TState>} getManifest 
     */
    constructor(getManifest = undefined) {
        super();

        /** @type {maker.ManifestFunction<TState>} */
        this.getManifest = getManifest || (() => []);
        this.resources = new maker.ResourceManager();

        /** @type {TState[]} */
        this.history = [];
        this.index = -1;
        this.historyLimit = 20;
    }

    /**
     * The present state in history.
     */
    get present() {
        return this.history[this.index];
    }

    /**
     * Is there any edit history to undo to?
     */
    get canUndo() {
        return this.index > 0;
    }

    /**
     * Are there any undone edits to redo?
     */
    get canRedo() {
        return this.index < this.history.length - 1;
    }

    /**
     * Replace all state with the project and resources in the given project
     * bundle.
     * @param {maker.ProjectBundle<TState>} bundle
     */
    async loadBundle(bundle) {
        this.history.length = 0;
        this.history.push(bundle.project);
        this.index = 0;
        this.resources.clear();
        await this.resources.load(bundle.resources);

        this.changed();
    }

    /**
     * Replace all state by copying from another state manager.
     * @param {maker.StateManager<TState>} other 
     */
    async copyFrom(other) {
        this.history = COPY(other.history);
        this.index = other.index;
        
        this.resources.clear();
        await this.resources.copyFrom(other.resources);
        
        this.changed();
    }
    
    /**
     * Replace all state by copying just the present and dependent resources
     * from another state manager.
     * @param {maker.StateManager<TState>} other 
     */
    async copyPresentFrom(other) {
        this.history = [COPY(other.present)];
        this.index = 0;
        this.resources.clear();

        // TODO: only copy what's not going to be pruned..
        await this.resources.copyFrom(other.resources);
        this.pruneResources();
        
        this.changed();
    }

    /**
     * Copy the present state and dependent resources into a project bundle.
     * @returns {Promise<maker.ProjectBundle<TState>>}
     */
    async makeBundle() {
        const project = COPY(this.present);
        const resources = await this.resources.save(this.getManifest(this.present));

        return { project, resources };
    }

    /**
     * Save the current state as a checkpoint in history that can be returned to
     * with undo/redo.
     */
    makeCheckpoint() {
        this.history.length = this.index + 1;
        
        const currentData = this.present;

        this.history[this.index] = COPY(currentData);
        this.history.push(currentData);
        
        if (this.index < this.historyLimit) {
            this.index += 1;
        } else {
            // delete earliest history
            this.history.splice(0, 1);
            this.pruneResources();
        }
    }

    /**
     * Dispatch the change event signalling that the present state has been
     * updated.
     */
    changed() {
        this.dispatchEvent(new CustomEvent("change"));
    }

    /**
     * Discard all resources that are no longer required accord to the manifest
     * function.
     */
    pruneResources() {
        this.resources.prune(this.history.flatMap(this.getManifest));
    }

    /**
     * Make a history checkpoint, replace the current state with a forked
     * version via callback, and then dispatch the change event.
     * @param {(data: TState) => Promise} action 
     */
    async makeChange(action) {
        this.makeCheckpoint();
        await action(this.present);
        this.changed();
    }

    /**
     * Revert the state to the previous checkpoint in history.
     */
    undo() {
        if (!this.canUndo) return;
        this.index -= 1;
        this.changed();
    }

    /**
     * Return the state to the most recently undone checkpoint in history.
     */
    redo() {
        if (!this.canRedo) return;
        this.index += 1;
        this.changed();
    }
};

/**
 * Ask the browser to download the given blob as a file with the given name.
 * @param {Blob} blob 
 * @param {string} name
 */
maker.saveAs = function(blob, name) {
    const element = document.createElement("a");
    const url = window.URL.createObjectURL(blob);
    element.href = url;
    element.download = name;
    element.click();
    window.URL.revokeObjectURL(url);
};

/**
 * Open the browser file picker, optionally restricted to files of a given file
 * type pattern and optionally accepting multiple files. 
 * @param {string} accept 
 * @param {boolean} multiple 
 * @returns {Promise<File[]>}
 */
 maker.pickFiles = async function(accept = "*", multiple = false) {
    return new Promise((resolve) => {
        const fileInput = html("input", { type: "file", accept, multiple });
        fileInput.addEventListener("change", () => resolve(Array.from(fileInput.files)));
        fileInput.click();
    });
}

/**
 * Read plain text from a file.
 * @param {File} file 
 * @return {Promise<string>}
 */
maker.textFromFile = async function(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onerror = reject;
        reader.onload = () => resolve(/** @type {string} */ (reader.result));
        reader.readAsText(file); 
    });
}

/**
 * Read image from a file.
 * @param {File} file 
 * @return {Promise<string>}
 */
maker.dataURIFromFile = async function(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onerror = reject;
        reader.onload = () => resolve(/** @type {string} */ (reader.result));
        reader.readAsDataURL(file); 
    });
}

/**
 * Create a DOM for an html page from html source code
 * @param {string} source
 * @returns 
 */
maker.htmlFromText = function(source) {
    const template = document.createElement('template');
    template.innerHTML = source;
    return template.content;
}

/**
 * @param {string} text 
 */
maker.textToBlob = function(text, type = "text/plain") {
    return new Blob([text], { type });
}

/**
 * 
 * @param {ParentNode} html 
 */
maker.bundleFromHTML = function(html, query="#bundle-embed") {
    let json = ONE(query, html)?.textContent;

    const bundle = json ? JSON.parse(json.charCodeAt(0) == 123 ? json : json.substring(1)) : undefined;
    return bundle;
}

class RadioGroupWrapper extends EventTarget {
    /** @param {HTMLInputElement[]} inputs */
    constructor(inputs) {
        super();

        const group = this;
        this.onRadioChange = function() {
            if (!this.checked) return;
            group.dispatchEvent(new CustomEvent("change"));
        }

        this.inputs = [];
        this.replaceInputs(inputs);
    }

    get selectedIndex() {
        return this.inputs.findIndex((button) => button.checked); 
    }

    set selectedIndex(value) {
        this.inputs[value].click();
    }

    get selectedInput() {
        return this.inputs[this.selectedIndex];
    }

    get value() {
        return this.selectedInput?.value;
    }
    
    get valueAsNumber() {
        return parseInt(this.selectedInput?.value ?? "-1", 10);
    }

    setSelectedIndexSilent(value) {
        this.inputs.forEach((input, index) => input.checked = index === value);
    }

    setValueSilent(value) {
        value = value.toString();
        this.inputs.forEach((input) => input.checked = input.value === value);
    }

    /**
     * @param {HTMLElement} element 
     * @param  {...string} values 
     */
    tab(element, ...values) {
        this.addEventListener("change", () => element.hidden = !values.includes(this.value));
    }

    /**
     * @param {HTMLInputElement} radioElement 
     */
    add(radioElement) {
        this.inputs.push(radioElement);
        radioElement.addEventListener("change", this.onRadioChange);
    }

    /**
     * @param {HTMLInputElement} radioElement 
     */
    remove(radioElement) {
        arrayDiscard(this.inputs, radioElement);
        radioElement.removeEventListener("change", this.onRadioChange);
    }

    removeAll() {
        this.inputs.forEach((element) => element.removeEventListener("change", this.onRadioChange));
        this.inputs.length = 0;
    }

    replaceInputs(inputs) {
        this.removeAll();
        inputs.forEach((input) => this.add(input));
    }
}

class CheckboxWrapper extends EventTarget {
    /** @param {HTMLInputElement[]} inputs */
    constructor(inputs) {
        super();
        this.inputs = inputs;

        inputs.forEach((input) => {
            input.addEventListener("change", () => {
                this.dispatchEvent(new CustomEvent("change"));
                this.setCheckedSilent(input.checked);
            });
        });
    }

    get checked() {
        return this.inputs[0].checked; 
    }

    set checked(value) {
        if (this.checked !== value) this.inputs[0].click();
    }

    setCheckedSilent(value) {
        this.inputs.forEach((input) => input.checked = value);
    }
}

class ButtonAction extends EventTarget {
    /** @param {HTMLButtonElement[]} buttons */
    constructor(buttons) {
        super();
        this.buttons = buttons;
        this.disabled = false;

        buttons.forEach((button) => {
            button.addEventListener("click", () => this.invoke());
        });
    }

    get disabled() {
        return this._disabled;
    }

    set disabled(value) {
        this._disabled = value;
        this.buttons.forEach((button) => button.disabled = value);
    }

    invoke(force = false) {
        if (!force && this.disabled) return;
        this.dispatchEvent(new CustomEvent("invoke"));
    }
}

/**
 * Get a wrapper for the radio input elements sharing the given name.
 * @param {string} name
 * @returns {RadioGroupWrapper}
 */
ui.radio = (name) => new RadioGroupWrapper(ALL(`input[type="radio"][name="${name}"]`));

ui.toggle = (name) => new CheckboxWrapper(ALL(`input[type="checkbox"][name="${name}"]`));

/**
 * @param {string} name 
 * @returns {HTMLInputElement}
 */
ui.slider = (name) => ONE(`input[type="range"][name=${name}]`);

/**
 * @param {string} name 
 * @returns {HTMLInputElement | HTMLTextAreaElement}
 */
ui.text = (name) => ONE(`[name=${name}]`);

/** @type {Map<string, ButtonAction>} */
ui.actions = new Map();
/**
 * Get an action linked to all button elements sharing the given name. 
 * Optionally provide a default listener for the action.
 * @param {string} name
 * @param {() => void} listener
 * @returns {ButtonAction}
 */
ui.action = function (name, listener=undefined) {
    const action = new ButtonAction(ALL(`button[name="${name}"]`));
    ui.actions.set(name, action);
    if (listener) action.addEventListener("invoke", listener);
    return action;
}

/**
 * Get the html select element with the given name.
 * @param {string} name
 * @returns {HTMLSelectElement}
 */
ui.select = (name) => ONE(`select[name="${name}"]`);

/**
 * Get a child element matching CSS selector.
 * @param {string} query 
 * @param {ParentNode} element 
 * @returns {HTMLElement}
 */
const ONE = (query, element = undefined) => (element || document).querySelector(query);

/**
 * Get all children elements matching CSS selector.
 * @param {string} query 
 * @param {HTMLElement | Document} element 
 * @returns {HTMLElement[]}
 */
const ALL = (query, element = undefined) => Array.from((element || document).querySelectorAll(query));

/**
 * @template {any} T
 * @param {T[]} array 
 * @param {T} value
 * @returns {boolean}
 */
 function arrayDiscard(array, value) {
    const index = array.indexOf(value);
    if (index >= 0) array.splice(index, 1);
    return index >= 0;
}

ui.PointerDrag = class extends EventTarget {
    /** 
     * @param {MouseEvent} event
     */
    constructor(event, { clickMovementLimit = 5 } = {}) {
        super();
        this.pointerId = event["pointerId"];
        this.clickMovementLimit = 5;
        this.totalMovement = 0;

        this.downEvent = event;
        this.lastEvent = event;

        this.listeners = {
            "pointerup": (event) => {
                if (event.pointerId !== this.pointerId) return;

                this.lastEvent = event;
                this.unlisten();
                this.dispatchEvent(new CustomEvent("up", { detail: event }));
                if (this.totalMovement <= clickMovementLimit) {
                    this.dispatchEvent(new CustomEvent("click", { detail: event }));
                }
            },

            "pointermove": (event) => {
                if (event.pointerId !== this.pointerId) return;

                this.lastEvent = event;
                this.totalMovement += Math.abs(event.movementX);
                this.totalMovement += Math.abs(event.movementY);
                this.dispatchEvent(new CustomEvent("move", { detail: event }));
            }
        }

        document.addEventListener("pointerup", this.listeners.pointerup);
        document.addEventListener("pointermove", this.listeners.pointermove);
    }

    unlisten() {
        document.removeEventListener("pointerup", this.listeners.pointerup);
        document.removeEventListener("pointermove", this.listeners.pointermove);
    }
}

/**
 * Wrap a pointer down event and track its subsequent movement until release.
 * @param {PointerEvent} event 
 * @returns {ui.PointerDrag}
 */
ui.drag = (event) => new ui.PointerDrag(event);

/**
 * @param {HTMLCanvasElement} canvas 
 * @param {MouseEvent} event 
 */
 function mouseEventToCanvasPixelCoords(canvas, event) {
    const bounds = canvas.getBoundingClientRect();
    const [mx, my] = [event.clientX - bounds.x, event.clientY - bounds.y];
    const scale = canvas.width / canvas.clientWidth; 
    const [px, py] = [Math.floor(mx * scale), Math.floor(my * scale)];
    return { x: px, y: py };
}

/**
 * @param {HTMLCanvasElement} canvas 
 * @param {ui.PointerDrag} drag 
 */
function trackCanvasStroke(canvas, drag) {
    const positions = [mouseEventToCanvasPixelCoords(canvas, drag.downEvent)];
    const update = (event) => positions.push(mouseEventToCanvasPixelCoords(canvas, event.detail));
    drag.addEventListener("up", update);
    drag.addEventListener("move", update);
    return positions;
}

// from https://github.com/ai/nanoid/blob/master/non-secure/index.js
const urlAlphabet = 'ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW';
function nanoid(size = 21) {
    let id = '';
    let i = size;
    while (i--) id += urlAlphabet[(Math.random() * 64) | 0];
    return id
}

/**
 * Deep copy an object by serializing it to json and parsing it again.
 * @template T
 * @param {T} object
 * @returns {T}
 */
const COPY = (object) => JSON.parse(JSON.stringify(object));

/**
 * Create an array of zeroes to the given length.
 * @param {number} length 
 * @returns {number[]}
 */
const ZEROES = (length) => Array(length).fill(0);

/**
 * Create an array of a value repeated to the given length.
 * @template T
 * @param {number} length 
 * @param {T} value
 * @returns {T[]}
 */
 const REPEAT = (length, value) => Array(length).fill(value);

/**
 * Create an html element with the given attributes and children.
 * @template {keyof HTMLElementTagNameMap} K
 * @param {K} tagName 
 * @param {*} attributes 
 * @param  {...(Node | string)} children 
 * @returns {HTMLElementTagNameMap[K]}
 */
 function html(tagName, attributes = {}, ...children) {
    const element = /** @type {HTMLElementTagNameMap[K]} */ (document.createElement(tagName)); 
    Object.entries(attributes).forEach(([name, value]) => element.setAttribute(name, value));
    children.forEach((child) => element.append(child));
    return element;
}

/** @param {number} milliseconds */
function sleep(milliseconds) {
    return new Promise(resolve => setTimeout(resolve, milliseconds));
}

/** 
 * @template T
 * @param {IDBRequest<T>} request 
 * @returns {Promise<T>}
 */
 function promisfyRequest(request) {
    return new Promise((resolve, reject) => {
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
    });
}

/** 
 * @param {IDBTransaction} transaction 
 * @returns {Promise}
 */
 function promisfyTransaction(transaction) {
    return new Promise((resolve, reject) => {
        transaction.oncomplete = () => resolve();
        transaction.onabort = () => reject(transaction.error);
        transaction.onerror = () => reject(transaction.error);
    });
}

maker.ProjectStorage = class {
    constructor(appID, generateMeta=undefined) {
        this.appID = appID;
        this.generateMeta = generateMeta;
        this.error = undefined;

        this.openDatabase().then(
            (request) => request.close(),
            (reason) => this.error = reason,
        );
    }

    get available() {
        return this.error === undefined;
    }

    async openDatabase() {
        const request = indexedDB.open(this.appID);
        request.addEventListener("upgradeneeded", () => {
            request.result.createObjectStore("projects");
            request.result.createObjectStore("projects-meta");
        });
        return promisfyRequest(request);
    }

    async stores(mode) {
        const db = await this.openDatabase();
        const transaction = db.transaction(["projects", "projects-meta"], mode);
        const projects = transaction.objectStore("projects");
        const meta = transaction.objectStore("projects-meta");
        return { transaction, projects, meta };
    }

    /**
     * @returns {Promise<any[]>}
     */
    async list() {
        const stores = await this.stores("readonly");
        return promisfyRequest(stores.meta.getAll());
    }

    /**
     * @param {any} projectData 
     * @returns {Promise}
     */
    async save(projectData, key) {
        const meta = { date: (new Date()).toISOString() };
        if (this.generateMeta) Object.assign(meta, this.generateMeta(projectData)); 
    
        const stores = await this.stores("readwrite");
        stores.projects.put(projectData, key);
        stores.meta.put(meta, key);
        return promisfyTransaction(stores.transaction);
    }

    /**
     * @param {string} key
     * @returns {Promise<any>}
     */
    async load(key) {
        const stores = await this.stores("readonly");
        return promisfyRequest(stores.projects.get(key));
    }

    /**
     * @param {string} key
     */
    async delete(key) {
        const stores = await this.stores("readwrite");
        stores.projects.delete(key);
        stores.meta.delete(key);
        return promisfyTransaction(stores.transaction);
    }
}

    </script>
    <script>/**
 * @param {number} width
 * @param {number} height
 * @returns {CanvasRenderingContext2D}
 */
function createRendering2D(width, height) {
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const context = canvas.getContext('2d');
    context.imageSmoothingEnabled = false;
    return context;
}

/**
 * @param {CanvasRenderingContext2D} rendering 
 * @param {string | CanvasGradient | CanvasPattern | undefined} fillStyle
 */
function fillRendering2D(rendering, fillStyle = undefined) {
    if (fillStyle !== undefined) {
        const prevStyle = rendering.fillStyle;
        rendering.fillStyle = fillStyle;
        rendering.fillRect(0, 0, rendering.canvas.width, rendering.canvas.height);
        rendering.fillStyle = prevStyle;
    } else {
        rendering.clearRect(0, 0, rendering.canvas.width, rendering.canvas.height);
    }
}

/**
 * @param {CanvasRenderingContext2D} source
 * @param {CanvasRenderingContext2D} destination
 * @param {{ x: number, y: number, w: number, h: number }} rect
 */
function copyRendering2D(
    source, 
    destination = undefined,
    rect = undefined,
) {
    rect = rect ?? { x: 0, y: 0, w: source.canvas.width, h: source.canvas.height };
    destination = destination || createRendering2D(rect.w, rect.h);
    destination.canvas.width = rect.w;
    destination.canvas.height = rect.h;

    destination.drawImage(
        source.canvas, 
        rect.x, rect.y, rect.w, rect.h,
        0, 0, rect.w, rect.h,
    );

    return destination;
}

/**
 * @param {CanvasRenderingContext2D} rendering 
 * @param {number} width 
 * @param {number} height 
 */
function resizeRendering2D(rendering, width, height) {
    const copy = copyRendering2D(rendering);
    rendering.canvas.width = width;
    rendering.canvas.height = height;
    rendering.drawImage(copy.canvas, 0, 0);
}

/**
 * @param {CanvasRenderingContext2D} rendering 
 */
function invertMask(rendering) {
    withPixels(rendering, (pixels) => {
        for (let i = 0; i < pixels.length; ++i) {
            pixels[i] = 0xFFFFFFFF - pixels[i];
        }
    });
}

/**
 * @param {CanvasRenderingContext2D} rendering 
 * @param {number} dx
 * @param {number} dy
 */
function cycleRendering2D(rendering, dx, dy) {
    const { width, height } = rendering.canvas;
    const sx = -Math.sign(dx);
    const sy = -Math.sign(dy);

    const temp = copyRendering2D(rendering);

    fillRendering2D(rendering);
    rendering.drawImage(temp.canvas, dx,            dy            );
    rendering.drawImage(temp.canvas, dx + width*sx, dy            ); 
    rendering.drawImage(temp.canvas, dx + width*sx, dy + height*sy); 
    rendering.drawImage(temp.canvas, dx,            dy + height*sy); 
}

/**
 * @param {CanvasRenderingContext2D} rendering 
 */
function mirrorRendering2D(rendering) {
    const prevComposite = rendering.globalCompositeOperation;
    rendering.globalCompositeOperation = "copy";
    rendering.scale(-1, 1);
    rendering.drawImage(rendering.canvas, -rendering.canvas.width, 0);
    rendering.globalCompositeOperation = prevComposite;
}

/**
 * @param {CanvasRenderingContext2D} rendering 
 */
 function flipRendering2D(rendering) {
    const prevComposite = rendering.globalCompositeOperation;
    rendering.globalCompositeOperation = "copy";
    rendering.scale(1, -1);
    rendering.drawImage(rendering.canvas, 0, -rendering.canvas.height);
    rendering.globalCompositeOperation = prevComposite;
}

/**
 * @param {CanvasRenderingContext2D} rendering 
 * @param {number} turns
 */
 function turnRendering2D(rendering, turns=1) {
    const { width, height } = rendering.canvas;
    const prevComposite = rendering.globalCompositeOperation;

    rendering.globalCompositeOperation = "copy";
    rendering.setTransform(1, 0, 0, 1, width/2, height/2);
    rendering.rotate(turns * Math.PI / 2);
    rendering.drawImage(rendering.canvas, -width/2, -height/2);
    rendering.globalCompositeOperation = prevComposite;
}

/**
 * @callback pixelsAction
 * @param {Uint32Array} pixels
 */

/**
 * @param {CanvasRenderingContext2D} rendering 
 * @param {pixelsAction} action 
 */
function withPixels(rendering, action) {
    const imageData = rendering.getImageData(0, 0, rendering.canvas.width, rendering.canvas.height);
    action(new Uint32Array(imageData.data.buffer));
    rendering.putImageData(imageData, 0, 0);
}

/**
 * @param {CanvasRenderingContext2D} mask 
 * @param {string} style 
 * @param {CanvasRenderingContext2D} destination 
 */
function recolorMask(mask, style, destination = undefined) {
    const recolored = copyRendering2D(mask, destination);
    recolored.globalCompositeOperation = "source-in";
    fillRendering2D(recolored, style);
    return recolored;
}

/**
 * @param {number} x0 
 * @param {number} y0 
 * @param {number} x1 
 * @param {number} y1 
 * @param {(x: number, y: number) => void} plot 
 */
// adapted from https://stackoverflow.com/a/34267311
function lineplot(x0, y0, x1, y1, plot) {
    x0 |= 0; y0 |= 0; x1 |= 0; y1 |= 0;

    const steep = Math.abs(y1 - y0) > Math.abs(x1 - x0);
    if (steep) [x0, y0, x1, y1] = [y0, x0, y1, x1];

    const dx = Math.abs(x1 - x0);
    const dy = Math.abs(y1 - y0);
    const ystep = Math.sign(y1 - y0);
    const xstep = Math.sign(x1 - x0);

    let err = Math.floor(dx / 2);
    let y = y0;

    if (dx === 0 && dy === 0) {
        plot(x0, y0);
    }

    for (let x = x0; x != (x1 + xstep); x += xstep) {
        plot(steep ? y : x, steep ? x : y);
        err -= dy;
        if (err < 0) {
            y += ystep;
            err += dx;
        }
    }
}

/**
 * @param {CanvasRenderingContext2D} rendering 
 * @param {number} x 
 * @param {number} y 
 * @param {number} color
 */
function floodfill(rendering, x, y, color, tolerance = 5) {
    const [width, height] = [rendering.canvas.width, rendering.canvas.height];
    withPixels(rendering, pixels => {
        const queue = [[x, y]];
        const done = new Array(width * height);
        const initial = pixels[y * width + x];

        const ir = initial >>>  0 & 0xFF;
        const ig = initial >>>  8 & 0xFF;
        const ib = initial >>> 16 & 0xFF;

        function enqueue(x, y) {
            const within = x >= 0 && y >= 0 && x < width && y < height;

            if (within && !done[y * width + x]) {
                const pixel = pixels[y * width + x];

                const pr = pixel >>>  0 & 0xFF;
                const pg = pixel >>>  8 & 0xFF;
                const pb = pixel >>> 16 & 0xFF;
                const dist = Math.abs(pr - ir) + Math.abs(pg - ig) + Math.abs(pb - ib);
                
                if (dist <= tolerance) queue.push([x, y]);
            }
        }

        while (queue.length > 0) {
            const [x, y] = queue.pop();
            pixels[y * width + x] = color;
            done[y * width + x] = true;

            enqueue(x - 1, y);
            enqueue(x + 1, y);
            enqueue(x, y - 1);
            enqueue(x, y + 1);
        }
    });
};

/**
 * @param {CanvasRenderingContext2D} rendering 
 * @param {number} x 
 * @param {number} y 
 * @param {number} color
 * @returns {CanvasRenderingContext2D}
 */
 function floodfillOutput(rendering, x, y, color) {
    const [width, height] = [rendering.canvas.width, rendering.canvas.height];
    const output = createRendering2D(width, height);
    withPixels(rendering, srcPixels =>
    withPixels(output, dstPixels => {
        const queue = [[x, y]];
        const done = new Array(width * height);
        const initial = srcPixels[y * width + x];

        function enqueue(x, y) {
            const within = x >= 0 && y >= 0 && x < width && y < height;

            if (within && srcPixels[y * width + x] === initial && !done[y * width + x]) {
                queue.push([x, y]);
            }
        }

        while (queue.length > 0) {
            const [x, y] = queue.pop();
            dstPixels[y * width + x] = color;
            done[y * width + x] = true;

            enqueue(x - 1, y);
            enqueue(x + 1, y);
            enqueue(x, y - 1);
            enqueue(x, y + 1);
        }
    }));
    return output;
};

/**
 * @param {{r:number,g:number,b:number}} rgb 
 */
function rgbToHex(rgb) {
    const packed = (0xFF000000 + (rgb.r << 16) + (rgb.g << 8) + (rgb.b << 0));
    return "#" + packed.toString(16).substr(-6);
}

/**
 * @param {string} hex 
 * @param {number} alpha
 */
function hexToUint32(hex, alpha = undefined) {
    if (hex.charAt(0) === '#') hex = hex.substring(1);
    if (alpha === undefined && hex.length === 8) alpha = parseInt(hex.substr(6, 2), 16);
    if (alpha === undefined) alpha = 255;
    hex = hex.substr(4, 2) + hex.substr(2, 2) + hex.substr(0, 2);
    return (parseInt(hex, 16) | (alpha << 24)) >>> 0;
}

/**
 * @param {number} number
 * @param {string} prefix 
 */
function numberToHex(number, prefix = '#') {
    number = (number | 0xff000000) >>> 0;
    let hex = number.toString(16).substring(2, 8);
    hex = hex.substr(4, 2) + hex.substr(2, 2) + hex.substr(0, 2);
    return prefix + hex;
}

const MASK_PALETTE = {
    '_': hexToUint32('#000000', 0),
    default: hexToUint32('#FFFFFF', 255),
};

/**
 * @param {string} text 
 * @param {Record<string, number>} palette 
 * @returns {CanvasRenderingContext2D}
 */
function textToRendering2D(text, palette = MASK_PALETTE) {
    text = text.trim();
    const lines = text.split('\n').map((line) => [...line.trim()]);

    const width = lines[0].length;
    const height = lines.length;

    const rendering = createRendering2D(width, height);
    withPixels(rendering, (pixels) => {
        lines.forEach((line, y) => line.forEach((char, x) => {
            const color = palette[char];
            pixels[y * width + x] = color !== undefined ? color : palette.default;
        }));
    });

    return rendering;
}

/**
 * @param {{ h: number, s: number, v: number }} hsv
 */
function HSVToRGB(hsv) {
    const { h, s, v } = hsv;
    let r, g, b;
    const i = Math.floor(h * 6);
    const f = h * 6 - i;
    const p = (1 - s);
    const q = (1 - f * s);
    const t = (1 - (1 - f) * s);
    switch (i % 6) {
        case 0: r = 1, g = t, b = p; break;
        case 1: r = q, g = 1, b = p; break;
        case 2: r = p, g = 1, b = t; break;
        case 3: r = p, g = q, b = 1; break;
        case 4: r = t, g = p, b = 1; break;
        case 5: r = 1, g = p, b = q; break;
    }

    r *= v * 255;
    g *= v * 255;
    b *= v * 255;

    return { r, g, b };
}

/**
 * @param {{ r: number, g: number, b: number }} rgb
 */
function RGBToHSV(rgb) {
    const { r, g, b } = rgb;
    var max = Math.max(r, g, b), min = Math.min(r, g, b),
        d = max - min,
        h,
        s = (max === 0 ? 0 : d / max),
        v = max / 255;

    switch (max) {
        case min: h = 0; break;
        case r: h = (g - b) + d * (g < b ? 6: 0); h /= 6 * d; break;
        case g: h = (b - r) + d * 2; h /= 6 * d; break;
        case b: h = (r - g) + d * 4; h /= 6 * d; break;
    }

    return { h, s, v };
}

function HSVToCone(hsv) {
    const a = Math.PI * hsv.h;
    const r = hsv.s * .5 * hsv.v;
    const x = Math.cos(a) * r;
    const y = Math.sin(a) * r;
    return { x, y, z: hsv.v };
}


function uint32ToRGB(uint32) {
    return {
        r: uint32 >>>  0 & 0xFF,
        g: uint32 >>>  8 & 0xFF,
        b: uint32 >>> 16 & 0xFF,
        uint32,
    };
}

function hexToRGB(hex) {
    if (hex.charAt(0) === '#') hex = hex.substring(1);
    return {
        b: parseInt(hex.substr(4, 2), 16),
        g: parseInt(hex.substr(2, 2), 16),
        r: parseInt(hex.substr(0, 2), 16),
        uint32: hexToUint32(hex),
    };
}

function RGBToUint32(rgb) {
    return rgb.r | rgb.g << 8 | rgb.b << 16 | 0xFF << 24;
}

/**
 * @param {CanvasRenderingContext2D} rendering 
 * @param {string[]} palette 
 */
function recolorToPalette(rendering, palette) {
    const paletteConverted = palette.map((hex) => { 
        const cone = HSVToCone(RGBToHSV(hexToRGB(hex)));
        const uint32 = hexToUint32(hex);
        return { ...cone, uint32 };
    });
    const mapping = new Map();

    function chooseColor(uint32) {
        const alpha = (uint32 >>> 24) < 16;
        if (alpha) return 0;

        const existing = mapping.get(uint32);
        if (existing) return existing;

        const actual = HSVToCone(RGBToHSV(uint32ToRGB(uint32)));
        let bestSqrDistance = Infinity;
        let best = paletteConverted[0];

        for (let candidate of paletteConverted) {
            const dx = Math.abs(actual.x - candidate.x);
            const dy = Math.abs(actual.y - candidate.y);
            const dz = Math.abs(actual.z - candidate.z);
            const sqrDistance = dx*dx + dy*dy + dz*dz;
            
            if (sqrDistance < bestSqrDistance) {
                bestSqrDistance = sqrDistance;
                best = candidate;
            }
        }

        mapping.set(uint32, best.uint32);
        return best.uint32;
    }

    withPixels(rendering, (pixels) => {
        for (let i = 0; i < pixels.length; ++i) {
            pixels[i] = chooseColor(pixels[i]);
        }
    });
}

/** 
 * Copy image contents to a new canvas rendering context.
 * @param {HTMLImageElement} image 
 */
function imageToRendering2D(image) {
    const rendering = createRendering2D(image.naturalWidth, image.naturalHeight);
    rendering.drawImage(image, 0, 0);
    return rendering;
}

/**
 * Create an html image from a given src (probably a datauri).
 * @param {string} src
 * @returns {Promise<HTMLImageElement>}
 */
async function loadImage(src) {
    return new Promise((resolve, reject) => {
        const image = document.createElement("img");
        image.addEventListener("load", () => resolve(image));
        image.addEventListener("error", reject);
        image.src = src;
    });
}

/**
 * In the given rendering, replace every instance of a color in the prev palette
 * with the corresponding color in the next palette, ignoring colors that don't
 * appear. This is broken in firefox because colors are not stored exactly. 
 * @param {CanvasRenderingContext2D} rendering 
 * @param {string[]} prev 
 * @param {string[]} next 
 */
 function swapPalette(rendering, prev, next) {
    const mapping = new Map();
    prev.forEach((pixel, index) => mapping.set(prev[index], next[index]));

    withPixels(rendering, (pixels) => {
        for (let i = 0; i < pixels.length; ++i) {
            pixels[i] = mapping.get(pixels[i]) || pixels[i];
        }
    });
}

/**
 * Replace every color in the given rendering. Each existing color is matched
 * to the closest color in the prev palette and replaced with the corresponding
 * color in the next palette. 
 * @param {CanvasRenderingContext2D} rendering 
 * @param {number[]} prev 
 * @param {number[]} next 
 */
function swapPaletteSafe(rendering, prev, next) {
    const mapping = new Map();
    for (let i = 0; i < prev.length; ++i) {
        mapping.set(prev[i], next[i % next.length]);
    }

    function addMissing(prevPixel) {
        let bestDistance = Infinity;
        let bestNextPixel = next[0];

        const pr = prevPixel >>>  0 & 0xFF;
        const pg = prevPixel >>>  8 & 0xFF;
        const pb = prevPixel >>> 16 & 0xFF;

        for (let i = 0; i < prev.length; ++i) {
            const target = prev[i];
            const tr = target >>>  0 & 0xFF;
            const tg = target >>>  8 & 0xFF;
            const tb = target >>> 16 & 0xFF;

            const dist = Math.abs(pr - tr) 
                       + Math.abs(pg - tg) 
                       + Math.abs(pb - tb);

            if (dist < bestDistance) {
                bestDistance = dist;
                bestNextPixel = next[i];
            }
        }

        mapping.set(prevPixel, bestNextPixel);
        return bestNextPixel;
    }

    withPixels(rendering, (pixels) => {
        for (let i = 0; i < pixels.length; ++i) {
            const prev = pixels[i];
            pixels[i] = mapping.get(prev) ?? addMissing(prev);
        }
    });
}

/**
 * @param {HTMLCanvasElement} canvas 
 */
async function canvasToBlob(canvas) {
    return new Promise((resolve) => canvas.toBlob(resolve));
}

    </script>
    <script>/**
 * @typedef {Object} Vector2
 * @property {number} x
 * @property {number} y
 */

/**
 * @typedef {Object} Rect
 * @property {number} x
 * @property {number} y
 * @property {number} width
 * @property {number} height
 */

/**
 * @param {number} min 
 * @param {number} max 
 */
 function range(min, max) {
    return Array.from(new Array(max-min+1), (x, i) => i + min);
}

/**
 * @typedef {Object} BlitsyFontCharacter
 * @property {number} codepoint
 * @property {CanvasImageSource} image
 * @property {number} spacing
 */

/**
 * @typedef {Object} BlitsyFont
 * @property {string} name
 * @property {number} lineHeight
 * @property {Map<number, BlitsyFontCharacter>} characters
 */

/**
 * @typedef {Object} BlitsyGlyph
 * @property {HTMLCanvasElement} image
 * @property {Vector2} position
 * @property {Vector2} offset
 * @property {boolean} hidden
 * @property {string} fillStyle
 * @property {Map<string, any>} styles
 */

/**
 * @typedef {Object} BlitsyTextRenderOptions
 * @property {BlitsyFont} font
 * @property {number} lineCount
 * @property {number} lineWidth
 */

/** @typedef {BlitsyGlyph[]} BlitsyPage */

/** @param {HTMLScriptElement} script */
async function loadBasicFont(script) {
    const atlasdata = script.innerHTML;
    const charWidth = parseInt(script.getAttribute("data-char-width"), 10);
    const charHeight = parseInt(script.getAttribute("data-char-height"), 10);
    const indexes = parseRuns(script.getAttribute("data-runs"));

    const atlas = await loadImage(atlasdata);
    const cols = atlas.naturalWidth / charWidth;

    const font = {
        name: "font",
        lineHeight: charHeight,
        characters: new Map(),
    };

    indexes.forEach((codepoint, i) => {
        const col = i % cols;
        const row = Math.floor(i / cols);

        const rect = { 
            x: col * charWidth, 
            y: row * charHeight, 
            width: charWidth, 
            height: charHeight,
        };

        const image = copyImageRect(atlas, rect).canvas;
        font.characters.set(codepoint, { codepoint, image, spacing: charWidth });
    });

    return font;
}

/** @param {string} data */
function parseRuns(data) {
    const runs = data.split(",").map((run) => {
        const [start, end] = run.split("-").map((index) => parseInt(index, 10));
        return [ start, end ?? start ];
    });
    const indexes = [];
    runs.forEach(([min, max]) => indexes.push(...range(min, max)));
    return indexes;
}

/**
 * @param {CanvasImageSource} source 
 * @param {Rect} rect 
 */
function copyImageRect(source, rect) {
    const rendering = createRendering2D(rect.width, rect.height);
    rendering.drawImage(source, rect.x, rect.y, rect.width, rect.height, 0, 0, rect.width, rect.height);
    return rendering;
}

/**
 * @param {BlitsyFont} font 
 * @param {string} char 
 */
function getFontChar(font, char) {
    const codepoint = char.codePointAt(0);
    return font.characters.get(codepoint);
}

/** 
 * @param {BlitsyPage} page 
 * @param {number} width
 * @param {number} height
 * @param {number} ox
 * @param {number} oy
 */
function renderPage(page, width, height, ox = 0, oy = 0)
{
    const result = createRendering2D(width, height);
    const buffer = createRendering2D(width, height);

    for (const glyph of page)
    {
        if (glyph.hidden) continue;

        // padding + position + offset
        const x = ox + glyph.position.x + glyph.offset.x;
        const y = oy + glyph.position.y + glyph.offset.y;
        
        // draw tint layer
        result.fillStyle = glyph.fillStyle;
        result.fillRect(x, y, glyph.image.width, glyph.image.height);
        
        // draw text layer
        buffer.drawImage(glyph.image, x, y);
    }

    // draw text layer in tint color
    result.globalCompositeOperation = 'destination-in';
    result.drawImage(buffer.canvas, 0, 0);

    return result;
}

const defaultStyleHandler = (styles, style) => {
    if (style.substr(0, 1) === "+") {
        styles.set(style.substring(1), true);
    } else if (style.substr(0, 1) === "-") {
        styles.delete(style.substring(1));
    } else if (style.includes("=")) {
        const [key, val] = style.split(/\s*=\s*/);
        styles.set(key, val);
    }
}

/**
 * @param {string} script 
 * @param {BlitsyTextRenderOptions} options 
 * @param {*} styleHandler 
 * @returns {BlitsyPage[]}
 */
function scriptToPages(script, options, styleHandler = defaultStyleHandler) {
    const tokens = tokeniseScript(script);
    const commands = tokensToCommands(tokens);
    return commandsToPages(commands, options, styleHandler);
}

function tokeniseScript(script) {
    const tokens = [];
    let buffer = "";
    let braceDepth = 0;

    function openBrace() {
        if (braceDepth === 0) flushBuffer();
        braceDepth += 1;
    }

    function closeBrace() {
        if (braceDepth === 1) flushBuffer();
        braceDepth -= 1;
    }

    function newLine() {
        flushBuffer();
        tokens.push(["markup", "el"]);
    }

    function flushBuffer() {
        if (buffer.length === 0) return;
        const type = braceDepth > 0 ? "markup" : "text";
        tokens.push([type, buffer]);
        buffer = "";
    }

    const actions = {
        "{": openBrace,
        "}": closeBrace,
        "\n": newLine,
    }

    for (const char of script) {
        if (char in actions)
            actions[char]();
        else
            buffer += char;
    }

    flushBuffer();

    return tokens;
}

function textBufferToCommands(buffer) {
    const chars = Array.from(buffer);
    return chars.map((char) => ({ type: "glyph", char, breakable: char === " " }));
}

function markupBufferToCommands(buffer) {
    if (buffer === "ep") return [{ type: "break", target: "page" }];
    if (buffer === "el") return [{ type: "break", target: "line" }];
    else                 return [{ type: "style", style: buffer }];
}

/** @param {any[]} tokens */
function tokensToCommands(tokens) {
    const handlers = {
        "text": textBufferToCommands,
        "markup": markupBufferToCommands,
    };

    const tokenToCommands = ([type, buffer]) => handlers[type](buffer); 
    return tokens.flatMap(tokenToCommands);
}

/**
 * @param {*} commands 
 * @param {BlitsyTextRenderOptions} options 
 * @param {*} styleHandler 
 */
function commandsToPages(commands, options, styleHandler) {
    commandsBreakLongSpans(commands, options);

    const styles = new Map();
    const pages = [];
    let page = [];
    let currLine = 0;

    function newPage() {
        pages.push(page);
        page = [];
        currLine = 0;
    }

    function endPage() { 
        do { endLine(); } while (currLine % options.lineCount !== 0)
    }

    function endLine() {
        currLine += 1;
        if (currLine === options.lineCount) newPage();
    }

    function doBreak(target) {
             if (target === "line") endLine();
        else if (target === "page") endPage(); 
    }

    function findNextBreakIndex() {
        let width = 0;

        for (let i = 0; i < commands.length; ++i) {
            const command = commands[i];
            if (command.type === "break") return i;
            if (command.type === "style") continue;

            width += computeLineWidth(options.font, command.char);
            // if we overshot, look backward for last possible breakable glyph
            if (width > options.lineWidth) {
                const result = find(commands, i, -1, command => command.type === "glyph" && command.breakable);
                if (result) return result[1];
            }
        };
    }

    function addGlyph(command, offset) {
        const char = getFontChar(options.font, command.char) ?? getFontChar(options.font, "?");
        const position = { x: offset, y: currLine * (options.font.lineHeight + 4) };
        const glyph = { 
            image: char.image,
            position,
            offset: { x: 0, y: 0 },
            hidden: true,
            fillStyle: "white",
            styles: new Map(styles.entries()),
        };

        page.push(glyph);
        return char.spacing;
    }

    function generateGlyphLine(commands) {
        let offset = 0;
        for (const command of commands) {
            if (command.type === "glyph") {
                offset += addGlyph(command, offset);
            } else if (command.type === "style") {
                styleHandler(styles, command.style);
            }
        }
    }

    let index;
    
    while ((index = findNextBreakIndex()) !== undefined) {
        generateGlyphLine(commands.slice(0, index));
        commands = commands.slice(index);

        const command = commands[0];
        if (command.type === "break") {
            doBreak(command.target);
            commands.shift();
        } else {
            if (command.type === "glyph" && command.char === " ") {
                commands.shift();
            }
            endLine();
        }
    }

    generateGlyphLine(commands);
    endPage();

    return pages;
}

/**
 * Find spans of unbreakable commands that are too long to fit within a page 
 * width and amend those spans so that breaking permitted in all positions. 
 * @param {*} commands
 * @param {BlitsyTextRenderOptions} options
 */
function commandsBreakLongSpans(commands, options) {
    const canBreak = (command) => command.type === "break" 
                               || (command.type === "glyph" && command.breakable); 

    const spans = filterToSpans(commands, canBreak);

    for (const span of spans) {
        const glyphs = span.filter(command => command.type === "glyph");
        const charWidths = glyphs.map(command => computeLineWidth(options.font, command.char));
        const spanWidth = charWidths.reduce((x, y) => x + y, 0);

        if (spanWidth > options.lineWidth) {
            for (const command of glyphs) command.breakable = true;
        }
    }
}

/**
 * @param {BlitsyFont} font 
 * @param {string} line 
 */
function computeLineWidth(font, line) {
    const chars = Array.from(line).map((char) => getFontChar(font, char));
    const widths = chars.map((char) => char ? char.spacing : 0);
    return widths.reduce((a, b) => a + b);
}

/**
 * Segment the given array into contiguous runs of elements that are not 
 * considered breakable.
 */
function filterToSpans(array, breakable) {
    const spans = [];
    let buffer = [];

    array.forEach((element, index) => {
        if (!breakable(element, index)) {
            buffer.push(element);
        } else if (buffer.length > 0) {
            spans.push(buffer);
            buffer = [];
        }
    });

    if (buffer.length > 0) {
        spans.push(buffer);
    }

    return spans;
}

function find(array, start, step, predicate) {
    for (let i = start; 0 <= i && i < array.length; i += step) {
        if (predicate(array[i], i)) return [array[i], i];
    }
}

    </script>
    <script>/**
 * @typedef {Object} DialoguePage
 * @property {BlitsyPage} glyphs
 * @property {Partial<DialogueOptions>} options
 */

/**
 * @typedef {Object} DialogueOptions
 * @property {*} font
 * @property {number} anchorX
 * @property {number} anchorY
 * @property {number} lines
 * @property {number} lineGap
 * @property {number} padding
 * @property {number} glyphRevealDelay
 * @property {string} backgroundColor
 * @property {string} panelColor
 * @property {string} textColor
 */

const DIALOGUE_DEFAULTS = {
    anchorX: 0.5,
    anchorY: 0.5,

    lines: 2,
    lineGap: 4,
    padding: 8,

    glyphRevealDelay: .05,

    backgroundColor: undefined,
    panelColor: "#000000",
    textColor: "#FFFFFF",
};

const CONT_ICON_DATA = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAGCAYAAAD68A/GAAAAAXNSR0IArs4c6QAAADNJREFUCJmNzrENACAMA0E/++/8NAhRBEg6yyc5SePUoNqwDICnWP04ww1tWOHfUqqf1UwGcw4T9WFhtgAAAABJRU5ErkJggg==";
const STOP_ICON_DATA = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAGCAYAAAD68A/GAAAAAXNSR0IArs4c6QAAACJJREFUCJljZICC/////2fAAhgZGRn////PwIRNEhsYCgoBIkQHCf7H+yAAAAAASUVORK5CYII="

class DialoguePlayback extends EventTarget {
    constructor(width, height) {
        super();
        this.dialogueRendering = createRendering2D(width, height);

        /** @type {DialoguePage[]} */
        this.queuedPages = [];
        this.pagesSeen = 0;
        
        this.options = {};

        // an awaitable that generates a new promise that resolves once no dialogue is active
        /** @type {PromiseLike<void>} */
        this.waiter = {
            then: (resolve, reject) => {
                if (this.empty) {
                    resolve();
                } else {
                    return wait(this, "empty").then(resolve, reject);
                }
            },
        }

        this.clear();
    }

    get empty() {
        return this.currentPage === undefined;
    }

    async load() {
        this.contIcon = imageToRendering2D(await loadImage(CONT_ICON_DATA));
        this.stopIcon = imageToRendering2D(await loadImage(STOP_ICON_DATA));
    }

    clear() {
        this.queuedPages = [];
        this.pagesSeen = 0;

        this.setPage(undefined);
    }

    /** @param {DialoguePage} page */
    setPage(page) {
        const prev = this.currentPage;
        this.currentPage = page;
        this.pageTime = 0;
        this.showGlyphCount = 0;
        this.showGlyphElapsed = 0;
        this.pageGlyphCount = page ? page.glyphs.length : 0;

        this.dispatchEvent(new CustomEvent("next-page", { detail: { prev, next: page } }));

        if (page === undefined) {
            this.dispatchEvent(new CustomEvent("empty"));
        }
    }

    /**
     * @param {string} script 
     * @param {Partial<DialogueOptions>} options 
     * @returns {Promise}
     */
    async queue(script, options={}) {
        const { font, lines } = this.getOptions(options);
        const lineWidth = 192;

        script = parseFakedown(script);
        const glyphPages = scriptToPages(script, { font, lineWidth, lineCount: lines });
        const pages = glyphPages.map((glyphs) => ({ glyphs, options }));
        this.queuedPages.push(...pages);
        
        if (this.empty) this.moveToNextPage();
    
        const last = pages[pages.length - 1];
        return new Promise((resolve) => {
            const onNextPage = (event) => {
                const { prev, next } = event.detail;
                if (prev === last) {
                    this.removeEventListener("next-page", onNextPage);
                    resolve();
                }
            };

            this.addEventListener("next-page", onNextPage);
        });
    }

    /** @param {number} dt */
    update(dt) {
        if (this.empty) return;

        this.pageTime += dt;
        this.showGlyphElapsed += dt;

        this.applyStyle();

        const options = this.getOptions(this.currentPage.options);

        while (this.showGlyphElapsed > options.glyphRevealDelay && this.showGlyphCount < this.pageGlyphCount) {
            this.showGlyphElapsed -= options.glyphRevealDelay;
            this.revealNextChar();
            this.applyStyle();
        }
    }

    render() {
        const options = this.getOptions(this.currentPage.options);
        const height = options.padding * 2 
                     + (options.font.lineHeight + options.lineGap) * options.lines;
        const width = 208;

        fillRendering2D(this.dialogueRendering, options.backgroundColor);
        
        const { width: displayWidth, height: displayHeight } = this.dialogueRendering.canvas;
        const spaceX = displayWidth - width;
        const spaceY = displayHeight - height;
        const margin = Math.ceil(Math.min(spaceX, spaceY) / 2);

        const minX = margin;
        const maxX = displayWidth - margin;

        const minY = margin;
        const maxY = displayHeight - margin;

        const x = Math.floor(minX + (maxX - minX - width ) * options.anchorX);
        const y = Math.floor(minY + (maxY - minY - height) * options.anchorY);

        this.dialogueRendering.fillStyle = options.panelColor;
        this.dialogueRendering.fillRect(x, y, width, height);
        
        this.applyStyle();
        const render = renderPage(
            this.currentPage.glyphs, 
            width, height, 
            options.padding, options.padding,
        );
        this.dialogueRendering.drawImage(render.canvas, x, y);

        if (this.showGlyphCount === this.pageGlyphCount) {
            const prompt = this.queuedPages.length > 0 
                         ? this.contIcon 
                         : this.stopIcon;
            this.dialogueRendering.drawImage(
                recolorMask(prompt, options.textColor).canvas, 
                x+width-options.padding-prompt.canvas.width, 
                y+height-options.lineGap-prompt.canvas.height,
            );
        }
    }

    getOptions(options) {
        return Object.assign({}, DIALOGUE_DEFAULTS, this.options, options);
    }

    revealNextChar() {
        if (this.empty) return;

        this.showGlyphCount = Math.min(this.showGlyphCount + 1, this.pageGlyphCount);
        this.currentPage.glyphs.forEach((glyph, i) => {
            if (i < this.showGlyphCount) glyph.hidden = false;
        });
    }

    revealAll() {
        if (this.empty) return;

        this.showGlyphCount = this.currentPage.glyphs.length;
        this.revealNextChar();
    }

    cancel() {
        this.queuedPages.length = 0;
        this.currentPage = undefined;
    }

    skip() {
        if (this.empty) return;
        
        if (this.showGlyphCount === this.pageGlyphCount) {
            this.moveToNextPage();
        } else {
            this.showGlyphCount = this.pageGlyphCount;
            this.currentPage.glyphs.forEach((glyph) => glyph.hidden = false);
        }
    }

    moveToNextPage() {
        const nextPage = this.queuedPages.shift();
        this.pagesSeen += 1;
        this.setPage(nextPage);
    }

    applyStyle() {
        if (this.empty) return;

        const currentGlyph = this.currentPage.glyphs[this.showGlyphCount];
        const options = this.getOptions(this.currentPage.options);

        if (currentGlyph) {
            if (currentGlyph.styles.has("delay")) {
                this.showCharTime = parseFloat(currentGlyph.styles.get("delay"));
            } else {
                this.showCharTime = this.currentPage.options.glyphRevealDelay;
            }
        }

        this.currentPage.glyphs.forEach((glyph, i) => {
            glyph.fillStyle = glyph.styles.get("clr") ?? options.textColor;

            if (glyph.styles.has("r"))
                glyph.hidden = false;
            if (glyph.styles.has("shk")) 
                glyph.offset = { x: getRandomInt(-1, 2), y: getRandomInt(-1, 2) };
            if (glyph.styles.has("wvy"))
                glyph.offset.y = (Math.sin(i + this.pageTime * 5) * 3) | 0;
            if (glyph.styles.has("rbw")) {
                const h = Math.abs(Math.sin(performance.now() / 600 - i / 8));
                glyph.fillStyle = rgbToHex(HSVToRGB({ h, s: 1, v: 1 }));
            }
        });
    }
}

/**
 * @param {EventTarget} target 
 * @param {string} event 
 * @returns 
 */
 async function wait(target, event) {
    return new Promise((resolve) => {
        target.addEventListener(event, resolve, { once: true });
    });
}

/**
 * Return a random integer at least min and below max. Why is that the normal
 * way to do random ints? I have no idea.
 * @param {number} min 
 * @param {number} max 
 * @returns {number}
 */
 function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min)) + min;
}

    </script>
    <script>// browser saves will be stored under the id "bipsi"
const storage = new maker.ProjectStorage("bipsi");

// type definitions for the structure of bipsi project data. useful for the
// code editor, ignored by the browser 
/**
 * @typedef {Object} BipsiDataSettings
 * @property {string} title
 */

/**
 * @typedef {Object} BipsiDataEventField
 * @property {string} key
 * @property {string} type
 * @property {any} data
 */

/**
 * @typedef {Object} BipsiDataEvent
 * @property {number} id
 * @property {number[]} position
 * @property {BipsiDataEventField[]} fields
 */

/**
 * @typedef {Object} BipsiDataRoom
 * @property {number} id
 * @property {number} palette
 * @property {number[][]} tilemap
 * @property {number[][]} backmap
 * @property {number[][]} foremap
 * @property {number[][]} wallmap
 * @property {BipsiDataEvent[]} events
 */

/**
 * @typedef {Object} BipsiDataTile
 * @property {number} id
 * @property {number[]} frames
 */

/**
 * @typedef {Object} BipsiDataProject
 * @property {BipsiDataRoom[]} rooms
 * @property {string[][]} palettes
 * @property {string} tileset
 * @property {BipsiDataTile[]} tiles
 */

/**
 * @typedef {Object} BipsiDataLocation 
 * @property {number} room
 * @property {number[]} position
 */

/**
 * Return a list of resource ids that a particular bipsi project depends on. 
 * @param {BipsiDataProject} data 
 * @returns {string[]}
 */
function getManifest(data) {
    // all embedded files
    const files = allEvents(data)
        .flatMap((event) => event.fields)
        .filter((field) => field.type === "file")
        .map((field) => field.data);

    // + tileset
    return [data.tileset, ...files];
}

const constants = {
    tileSize: 8,
    roomSize: 16,
    frameInterval: 400,

    tileset: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAAjUlEQVR42u3XMQ4AEBAEwPv/p2kUIo5ScmYqQWU3QsSkDbu5TFBHVoDTfqemAFQKfy3BOs7WKBT+HLQCfBB+dgPcHnoKULAIp7ECfFoA30AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOCFDjCu5xlD93/uAAAAAElFTkSuQmCC",

    wallTile: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAAXNSR0IArs4c6QAAAAlQTFRFAAAA////AAAAc8aDcQAAAAN0Uk5TAP//RFDWIQAAADlJREFUGJVlj0EOACAIw2D/f7QmLAa7XeyaKFgVkfSjum1M9xhDeN24+pjdbVYPwSt8lGMDcnV+DjlaUACpjVBfxAAAAABJRU5ErkJggg==",
    eventTile: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAAXNSR0IArs4c6QAAAAlQTFRFAAAA////AAAAc8aDcQAAAAN0Uk5TAP//RFDWIQAAACVJREFUGJVjYMAATCgAJMCIBCACCHmYAFz3AAugOwzd6eieQwMAdfAA3XvBXggAAAAASUVORK5CYII=",
    startTile: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAAXNSR0IArs4c6QAAAAZQTFRFAAAA////pdmf3QAAAAJ0Uk5TAP9bkSK1AAAAJUlEQVQYlWNgwACMKAC7ALJqnALIqkEETD8lAhiGEnIHIb+gAQBFEACBGFbz9wAAAABJRU5ErkJggg==",

    colorwheelMargin: 12,
}
const TEMP_128 = createRendering2D(128, 128);
const TEMP_256 = createRendering2D(256, 256);

/**
 * @param {HTMLCanvasElement} tileset 
 * @param {number} index 
 */
function getTileCoords(tileset, index) {
    const size = constants.tileSize;
    const columns = tileset.width / size;

    return {
        x: size * (index % columns),
        y: size * Math.floor(index / columns),
        size,
    }
}

/**
 * @param {CanvasRenderingContext2D} tileset 
 * @param {number} tileIndex 
 * @param {CanvasRenderingContext2D} destination 
 * @returns {CanvasRenderingContext2D}
 */
function copyTile(tileset, tileIndex, destination = undefined) {
    const { x, y, size } = getTileCoords(tileset.canvas, tileIndex);
    const tile = copyRendering2D(tileset, destination, { x, y, w: size, h: size });
    return tile;
}

/**
 * @param {CanvasRenderingContext2D} tileset 
 * @param {number} tileIndex
 * @param {CanvasRenderingContext2D} tile 
 */
function drawTile(tileset, tileIndex, tile) {
    const { x, y, size } = getTileCoords(tileset.canvas, tileIndex);
    tileset.clearRect(x, y, size, size);
    tileset.drawImage(tile.canvas, x, y);
}

/**
 * @param {BipsiDataTile[]} tiles 
 * @param {number} frame 
 * @returns {Map<number, number>} 
 */
function makeTileToFrameMap(tiles, frame) {
    /** @type {[number, number][]} */
    return new Map(tiles.map((tile) => [
        tile.id, 
        tile.frames[frame] ?? tile.frames[0],
    ]));
}

function drawTilemapLayer(destination, tileset, tileToFrame, palette, { tilemap, backmap, foremap }) {
    drawRecolorLayer(destination, (backg, color, tiles) => {
        for (let ty = 0; ty < 16; ++ty) {
            for (let tx = 0; tx < 16; ++tx) {
                const back = backmap[ty][tx];
                const fore = foremap[ty][tx];
                const tileIndex = tilemap[ty][tx];
                
                const frameIndex = tileToFrame.get(tileIndex);
                const { x, y, size } = getTileCoords(tileset.canvas, frameIndex);

                if (tileIndex === 0) continue;

                backg.fillStyle = palette[back];
                backg.fillRect(tx * size, ty * size, size, size);

                color.fillStyle = palette[fore];
                color.fillRect(tx * size, ty * size, size, size);

                tiles.drawImage(
                    tileset.canvas,
                    x, y, size, size, 
                    tx * size, ty * size, size, size,
                );
            }
        }
    });
}

function drawEventLayer(destination, tileset, tileToFrame, palette, events) {
    const [background, foreground, highlight] = palette;

    drawRecolorLayer(destination, (backg, color, tiles) => {
        events.forEach((event) => {
            const [tx, ty] = event.position;
            const graphicField = oneField(event, "graphic", "tile");
            if (graphicField) {
                const frameIndex = tileToFrame.get(graphicField.data) ?? 0;
                const { x, y, size } = getTileCoords(tileset.canvas, frameIndex);
    
                if (background && !eventIsTagged(event, "transparent")) {
                    backg.fillStyle = background;
                    backg.fillRect(tx * size, ty * size, size, size);
                }

                color.fillStyle = highlight;
                color.fillRect(tx * size, ty * size, size, size);

                tiles.drawImage(
                    tileset.canvas,
                    x, y, size, size, 
                    tx * size, ty * size, size, size,
                );
            }
        });
    });
}

/**
 * @param {any[][]} map 
 * @param {number} dx 
 * @param {number} dy 
 */
function cycleMap(map, dx, dy) {
    const x = dx > 0 ? dx : 16 + dx;
    const y = dy > 0 ? dy : 16 + dy;
    
    map.push(...map.splice(0, y));
    map.forEach((row) => {
        row.push(...row.splice(0, x));
    });
}

/**
 * @param {BipsiDataEvent[]} events 
 * @param {number} dx
 * @param {number} dy 
 */
function cycleEvents(events, dx, dy) {
    events.forEach((event) => {
        event.position[0] = (event.position[0] + 16 + dx) % 16;
        event.position[1] = (event.position[1] + 16 + dy) % 16;
    });
}

/**
 * @param {BipsiDataEvent[]} events 
 * @param {number} x
 * @param {number} y 
 */
function getEventsAt(events, x, y, ignore=undefined) {
    return events.filter((event) => event.position[0] === x 
                                 && event.position[1] === y 
                                 && event !== ignore);
}

/**
 * @template {{id: number}} T
 * @param {T[]} items 
 * @param {number} id 
 * @returns {T}
 */
function getById(items, id) {
    return items.find((item) => item.id === id);
}

/** 
 * @param {BipsiDataProject} data 
 * @param {number} id
 */
function getRoomById(data, id) {
    return getById(data.rooms, id);
}

/** 
 * @param {BipsiDataProject} data 
 * @param {number} id
 */
function getEventById(data, id) {
    return getById(allEvents(data), id);
}

/** 
 * @param {BipsiDataProject} data 
 * @param {number} id
 */
function getTileById(data, id) {
    return getById(data.tiles, id);
}

/**
 * @param {BipsiDataTile[]} tiles
 */
function findFreeFrame(tiles) {
    const frames = new Set(tiles.flatMap((tile) => tile.frames));
    const max = Math.max(...frames);

    for (let i = 0; i < max; ++i) {
        if (!frames.has(i)) return i;
    }

    return max + 1;
}

/**
 * @param {{id: number}[]} items 
 * @returns {number}
 */
function nextId(items) {
    const max = Math.max(0, ...items.map((item) => item.id ?? 0));
    return max + 1;
}

/** @param {BipsiDataProject} data */
const nextRoomId = (data) => nextId(data.rooms);

/** @param {BipsiDataProject} data */
const nextTileId = (data) => nextId(data.tiles);

/** @param {BipsiDataProject} data */
const nextEventId = (data) => nextId(data.rooms.flatMap((room) => room.events));

/**
 * @param {CanvasRenderingContext2D} tileset 
 * @param {BipsiDataTile[]} tiles
 */
function resizeTileset(tileset, tiles) {
    const maxFrame = Math.max(...tiles.flatMap((tile) => tile.frames));
    const size = 8
    const cols = 16;
    const rows = Math.ceil((maxFrame + 1) / cols);
    resizeRendering2D(tileset, cols * size, rows * size);
}

    </script>
    <script>/**
 * Use inline style to resize canvas to fit its parent, preserving the aspect
 * ratio of its internal dimensions.
 * @param {HTMLCanvasElement} canvas 
 */
 function fitCanvasToParent(canvas) {
    const [tw, th] = [canvas.parentElement.clientWidth, canvas.parentElement.clientHeight];
    const [sw, sh] = [tw / canvas.width, th / canvas.height];
    let scale = Math.min(sw, sh);
    if (canvas.width * scale > 512) scale = Math.floor(scale); 

    canvas.style.setProperty("width", `${canvas.width * scale}px`);
    canvas.style.setProperty("height", `${canvas.height * scale}px`);
}

// async equivalent of Function constructor
const AsyncFunction = Object.getPrototypeOf(async function(){}).constructor

/**
 * @param {any} message 
 * @param {string} origin 
 */
function postMessageParent(message, origin) {
    const target = window.parent ?? window.opener;
    target?.postMessage(message, origin);
}

/**
 * @param {BipsiDataEvent} event 
 * @param {string} key 
 */
function eventIsTagged(event, key) {
    return oneField(event, key, "tag") !== undefined;
}

/**
 * @param {BipsiDataRoom} room
 * @param {number} x 
 * @param {number} y 
 */
function cellIsSolid(room, x, y) {
    const wall = room.wallmap[y][x] > 0;
    const solid = getEventsAt(room.events, x, y).some((event) => eventIsTagged(event, "solid"));
    return solid || wall;
}

/**
 * 
 * @param {BipsiDataEvent} event 
 * @param {string} name 
 * @param {string} type 
 */
function allFields(event, name, type=undefined) {
    return event.fields.filter((field) => field.key === name && field.type === (type ?? field.type));
}

/**
 * 
 * @param {BipsiDataEvent} event
 */
 function allTags(event) {
    return event.fields.filter((field) => field.type === "tag").map((field) => field.key);
}

/**
 * 
 * @param {BipsiDataEvent} event 
 * @param {string} name 
 * @param {string} type 
 */
function oneField(event, name, type=undefined) {
    return event.fields.find((field) => field.key === name && field.type === (type ?? field.type));
}

/**
 * @param {BipsiDataProject} data 
 */
function allEvents(data) {
    return data.rooms.flatMap((room) => room.events);
}

/**
 * @param {BipsiDataProject} data 
 * @param {BipsiDataEvent} event 
 */
function roomFromEvent(data, event) {
    return data.rooms.find((room) => room.events.includes(event));
}

/**
 * @param {BipsiDataProject} data 
 * @param {BipsiDataLocation} location 
 * @returns {BipsiDataEvent?}
 */
function getEventAtLocation(data, location) {
    const room = data.rooms[location.room];
    const [x, y] = location.position;
    const [event] = getEventsAt(room.events, x, y);
    return event;
} 

/**
 * @param {BipsiDataProject} data 
 * @param {BipsiDataEvent} event 
 * @returns {BipsiDataLocation}
 */
function getLocationOfEvent(data, event) {
    const room = roomFromEvent(data, event);
    return { room: room.id, position: [...event.position] };
}

/**
 * @param {BipsiDataProject} data 
 * @param {BipsiDataEvent} event 
 * @param {BipsiDataLocation} location
 */
function moveEvent(data, event, location) {
    const room = data.rooms.find((room) => room.id === location.room);
    
    if (!room) throw Error("NO ROOM WITH ID " + location.room);
    
    removeEvent(data, event);
    room.events.push(event);
    event.position = [...location.position];
}

/**
 * @param {BipsiDataProject} data 
 * @param {BipsiDataEvent} event
 */
function removeEvent(data, event) {
    const prevRoom = roomFromEvent(data, event);
    arrayDiscard(prevRoom.events, event);
}

function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
}

function findEventsByTag(data, tag) {
    return allEvents(data).filter((event) => eventIsTagged(event, tag));
}

function findEventByTag(data, tag) {
    return allEvents(data).filter((event) => eventIsTagged(event, tag))[0];
}

const ERROR_STYLE = {
    glyphRevealDelay: 0,
    lines: 8,
    panelColor: "#FF0000",
    textColor: "#FFFFFF",

    anchorX: .5, anchorY: .5,
}

const BEHAVIOUR_PAGE_COLOR = `
let color = FIELD(EVENT, "page-color", "text");
if (color) {
    SET_CSS("--page-color", color);
}
`;

const BEHAVIOUR_IMAGES = `
let background = FIELD_OR_LIBRARY("background");
if (background) {
    SHOW_IMAGE("BACKGROUND", background, 1, 0, 0);
} else if (IS_TAGGED(EVENT, "clear-background")) {
    HIDE_IMAGE("BACKGROUND");
}

let foreground = FIELD_OR_LIBRARY("foreground");
if (foreground) {
    SHOW_IMAGE("FOREGROUND", foreground, 2, 0, 0);
} else if (IS_TAGGED(EVENT, "clear-foreground")) {
    HIDE_IMAGE("FOREGROUND");
}

let overlay = FIELD_OR_LIBRARY("overlay");
if (overlay) {
    SHOW_IMAGE("OVERLAY", overlay, 3, 0, 0);
} else if (IS_TAGGED(EVENT, "clear-overlay")) {
    HIDE_IMAGE("OVERLAY");
}
`;

const BEHAVIOUR_MUSIC = `
let music = FIELD_OR_LIBRARY("music");

if (music) {
    PLAY_MUSIC(music);
} else if (IS_TAGGED(EVENT, "stop-music")) {
    STOP_MUSIC();
}
`;

const BEHAVIOUR_TITLE = `
let title = FIELD(EVENT, "title", "dialogue");
if (title) {
    await TITLE(title);
}
`;

const BEHAVIOUR_DIALOGUE = `
let id = FIELD(EVENT, "say-shared-id", "text") ?? "SAY-ITERATORS/" + EVENT_ID(EVENT);
let mode = FIELD(EVENT, "say-mode", "text") ?? "cycle";
let say = SAMPLE(id, mode, FIELDS(EVENT, "say", "dialogue"));
if (say) {
    await SAY(say, FIELD(EVENT, "say-style", "json"));
}
`;

const BEHAVIOUR_EXIT = `
let destination = FIELD(EVENT, "exit", "location");
if (destination) {
    MOVE(AVATAR, destination);
}
`;

const BEHAVIOUR_REMOVE = `
if (IS_TAGGED(EVENT, "one-time")) {
    REMOVE(EVENT);
}
`;

const BEHAVIOUR_ENDING = `
let ending = FIELD(EVENT, "ending", "dialogue");
if (ending !== undefined) {
    if (ending.length > 0) {
        await TITLE(ending);
    }
    RESTART();
}
`;

const BEHAVIOUR_SET_AVATAR = `
let graphic = FIELD(EVENT, "set-avatar", "tile");
if (graphic) {
    SET_GRAPHIC(AVATAR, graphic);
}
`;

const STANDARD_SCRIPTS = [
    BEHAVIOUR_PAGE_COLOR,
    BEHAVIOUR_IMAGES,
    BEHAVIOUR_MUSIC,
    BEHAVIOUR_TITLE,
    BEHAVIOUR_DIALOGUE,
    BEHAVIOUR_EXIT, 
    BEHAVIOUR_REMOVE, 
    BEHAVIOUR_ENDING, 
    BEHAVIOUR_SET_AVATAR,
];

const BACKG_PAGE = createRendering2D(128, 128); 
const COLOR_PAGE = createRendering2D(128, 128);
const TILES_PAGE = createRendering2D(128, 128);

function drawRecolorLayer(destination, render) {
    fillRendering2D(BACKG_PAGE);
    fillRendering2D(COLOR_PAGE);
    fillRendering2D(TILES_PAGE);

    render(BACKG_PAGE, COLOR_PAGE, TILES_PAGE);

    COLOR_PAGE.globalCompositeOperation = "destination-in";
    COLOR_PAGE.drawImage(TILES_PAGE.canvas, 0, 0);
    COLOR_PAGE.globalCompositeOperation = "source-over";
    destination.drawImage(BACKG_PAGE.canvas, 0, 0);
    destination.drawImage(COLOR_PAGE.canvas, 0, 0);
}

class BipsiPlayback extends EventTarget {
    constructor(font) {
        super();
        // home for data of the project we're playing
        this.stateManager = new maker.StateManager(getManifest);
        this.stateBackup = new maker.StateManager(getManifest);
        // final composite of any graphics
        this.rendering = createRendering2D(256, 256);

        this.font = font;
        this.dialoguePlayback = new DialoguePlayback(256, 256);
        this.dialoguePlayback.options.font = font;

        this.time = 0;
        this.frameCount = 0;
        
        this.ready = false;
        this.busy = false;
        this.error = false;


        this.objectURLs = new Map();
        this.imageElements = new Map();

        this.music = document.createElement("audio");
        this.music.loop = true;
        this.autoplay = false;

        this.variables = new Map();
        this.images = new Map();

        this.story = undefined
        this.preventMoving = false;
    }

    async init() {
        await this.dialoguePlayback.load();
    }

    async initWithStory(story){
        await this.init()
        this.story = story;
    }

    /** @type {BipsiDataProject} */
    get data() {
        return this.stateManager.present;
    }

    async backup() {
        await this.stateBackup.copyFrom(this.stateManager);
    }

    /**
     * @param {maker.StateManager<BipsiDataProject>} stateManager 
     */
    async copyFrom(stateManager) {
        this.clear();
        await this.stateManager.copyFrom(stateManager);
        await this.backup();
    }

    /**
     * @param {maker.ProjectBundle<BipsiDataProject>} bundle
     */
    async loadBundle(bundle) {
        this.clear();
        await this.stateManager.loadBundle(bundle);
        await this.backup();
    }

    clear() {
        this.ready = false;
        this.error = false;
        this.ended = false;
        this.dialoguePlayback.clear();
        this.variables.clear();

        this.music.removeAttribute("src");
        this.music.pause();
        this.images.clear();
        this.imageElements.clear();
        this.objectURLs.forEach((url) => URL.revokeObjectURL(url));
    }

    getFileObjectURL(id) {
        const url = this.objectURLs.get(id) 
                 ?? URL.createObjectURL(this.stateManager.resources.get(id));
        this.objectURLs.set(id, url);
        return url;
    } 

    async getFileImageElement(id) {
        const image = this.imageElements.get(id) ?? await loadImage(this.getFileObjectURL(id));
        this.imageElements.set(id, image);
        return image;
    }

    async restart() {
        this.clear();
        await this.stateManager.copyFrom(this.stateBackup);
        this.start();
    }

    async start() {
        // player avatar is event tagged "is-player" at the beginning of the game
        const avatar = findEventByTag(this.data, "is-player");
        if (avatar === undefined) {
            this.showError("NO EVENT WITH is-player TAG FOUND");
            return;
        }

        // move avatar to last event (render on top)
        const room = roomFromEvent(this.data, avatar);
        moveEvent(this.data, avatar, { room: room.id, position: [...avatar.position] });

        this.avatarId = avatar.id;
        this.libraryId = findEventByTag(this.data, "is-library")?.id;
        this.ready = true;

        // game starts by running the touch behaviour of the player avatar
        //await this.touch(avatar);
        await this.continueStory();
    }

    async continueStory(){
        console.log("continuing")
        const story = this.story;
        while(story.canContinue) {
            // Get ink to generate the next paragraph
            var paragraphText = this.story.Continue().trim();
            var tags = story.currentTags;

            if(paragraphText.length > 0){
                if(tags.includes("TITLE")){
                    await this.title(paragraphText)
                }else{
                    await this.say(paragraphText)
                }
            }
        }

        const choices = this.story.currentChoices;

        const autoChoice = choices.find( (choice) => choice.text.startsWith("auto:"))
        if(autoChoice !== undefined){
            story.ChooseChoiceIndex(autoChoice.index)
            return await this.continueStory();
        }

        const dialogChoices = choices.filter( (choice) => {
            if(choice.text.startsWith("auto:")) return false;
            if(choice.text.startsWith("tag:")) return false;
            return true;
        })

        const continueStory = this.continueStory.bind(this)

        if(dialogChoices.length > 0){
            console.log("Choices present : prevent player from moving freely !")

            const choiceListContainer = ONE("#player-choices-list");
            this.preventMoving = true;
            dialogChoices.forEach(function(choice) {

                // Create paragraph with anchor element
                var choiceParagraphElement = document.createElement('li');
                choiceParagraphElement.classList.add("choice");
                choiceParagraphElement.innerHTML = `<a href='#'>${choice.text}</a>`
                choiceListContainer.appendChild(choiceParagraphElement);
    
                // Click on choice
                var choiceAnchorEl = choiceParagraphElement.querySelectorAll("a")[0];
                choiceAnchorEl.addEventListener("click", function(event) {
    
                    // Don't follow <a> link
                    event.preventDefault();
    
                    // Remove all existing choices
                    choiceListContainer.innerHTML = "";
    
                    // Tell the story where to go next
                    story.ChooseChoiceIndex(choice.index);
    
                    // Aaand loop
                    continueStory();
                });
            });
        }else{
            this.preventMoving = false
        }
    }

    update(dt) {
        if (!this.ready) return;

        // tile animation
        this.time += dt;
        while (this.time >= .400) {
            this.frameCount += 1;
            this.time -= .4;
        }

        // dialogue animation
        this.dialoguePlayback.update(dt);
        
        // rerender
        this.render();
    }

    render() {
        // find avatar, current room, current palette
        const avatar = getEventById(this.data, this.avatarId);
        const room = roomFromEvent(this.data, avatar);
        const palette = this.getActivePalette();
        const [background] = palette;
        const tileset = this.stateManager.resources.get(this.data.tileset);

        // find current animation frame for each tile
        const frame = this.frameCount % 2;
        const tileToFrame = makeTileToFrameMap(this.data.tiles, frame);

        // sort images
        const images = Array.from(this.images.values());
        images.sort((a, b) => a.layer - b.layer);
        const images_below_all    = images.filter((image) => image.layer < 1);
        const images_below_events = images.filter((image) => image.layer >= 1 && image.layer < 2);
        const images_above_events = images.filter((image) => image.layer >= 2 && image.layer < 3);
        const images_above_all    = images.filter((image) => image.layer >= 3);

        fillRendering2D(this.rendering);
        fillRendering2D(TEMP_128, background);
        images_below_all.forEach(({ image, x, y }) => TEMP_128.drawImage(image, x, y));
        drawTilemapLayer(TEMP_128, tileset, tileToFrame, palette, room);
        images_below_events.forEach(({ image, x, y }) => TEMP_128.drawImage(image, x, y));
        drawEventLayer(TEMP_128, tileset, tileToFrame, palette, room.events);
        images_above_events.forEach(({ image, x, y }) => TEMP_128.drawImage(image, x, y));

        // upscale tilemaps to display area
        this.rendering.drawImage(TEMP_128.canvas, 0, 0, 256, 256);

        // render dialogue box if necessary
        if (!this.dialoguePlayback.empty) {
            // change default dialogue position based on avatar position
            const top = avatar.position[1] >= 8;
            this.dialoguePlayback.options.anchorY = top ? 0 : 1;

            // redraw dialogue and copy to display area
            this.dialoguePlayback.render();
            this.rendering.drawImage(this.dialoguePlayback.dialogueRendering.canvas, 0, 0);
        }
        
        fillRendering2D(TEMP_128);
        images_above_all.forEach(({ image, x, y }) => TEMP_128.drawImage(image, x, y));
        this.rendering.drawImage(TEMP_128.canvas, 0, 0, 256, 256);

        if (this.ended) {
            fillRendering2D(this.rendering);
        }

        // signal, to anyone listening, that rendering happened
        this.dispatchEvent(new CustomEvent("render"));
    }

    end() {
        this.ended = true;
    }

    async proceed() {
        if (!this.ready) return;

        if (this.ended) {
            this.restart();
        }

        this.dialoguePlayback.skip();

        if (this.autoplay) {
            this.music.play();
            this.autoplay = false;
        }
    }

    async title(script, options={}) {
        const [background] = this.getActivePalette();
        options = { anchorY: .5, backgroundColor: background, ...options };
        return this.say(script, options);
    }

    async say(script, options={}) {
        await this.dialoguePlayback.queue(script, options);
    }

    async move(dx, dy) {
        if (this.ended) this.proceed();
        if (!this.ready || !this.dialoguePlayback.empty || this.busy || this.ended) return;

        this.busy = true;

        const avatar = getEventById(this.data, this.avatarId);
        const room = roomFromEvent(this.data, avatar);

        // determine move destination
        const [px, py] = avatar.position;
        const [tx, ty] = [px+dx, py+dy];

        // is the movement stopped by the room edge or solid cells?
        const bounded = tx < 0 || tx >= 16 || ty < 0 || ty >= 16;
        const blocked = bounded ? false : cellIsSolid(room, tx, ty);

        // if not, then update avatar position
        if (!blocked && !bounded) avatar.position = [tx, ty];

        // find if there's an event that should be touched. prefer an event at
        // the cell the avatar tried to move into but settle for the cell 
        // they're already standing on otherwise
        const [fx, fy] = avatar.position;
        const [event0] = getEventsAt(room.events, tx, ty, avatar);
        const [event1] = getEventsAt(room.events, fx, fy, avatar);
        const event = event0 ?? event1;

        // if there was such an event, touch it
        if (event) await this.touch(event);

        this.busy = false;
    }

    async touch(event) {
        const touch = oneField(event, "touch", "javascript")?.data;

        const tags = allTags(event);

        // do we have a choice that can be triggered by this event ?
        const choices = this.story.currentChoices
        const taggedChoice = choices.find(choice => {
            if(choice.text.substr(0,4) == "tag:"){
                const tagvalue = choice.text.substr(4).trim();
                if(tags.includes(tagvalue)) return true
                return false;
            }
            return false;
        })

        if (touch !== undefined) {
            await this.runJS(event, touch);
        }else if(taggedChoice !== undefined){
            this.story.ChooseChoiceIndex(taggedChoice.index)
            await this.continueStory();
        } else {
            await standardEventTouch(this, event);
        }
    }

    async runJS(event, js) {
        const defines = generateScriptingDefines(this, event);
        const names = Object.keys(defines).join(", ");
        const preamble = `const { ${names} } = COMMANDS;\n`;

        try {
            const script = new AsyncFunction("COMMANDS", preamble + js);
            await script(defines);
        } catch (e) {
            console.log(e);
            const error = `SCRIPT ERROR:\n${e}`;
            this.showError(error);
        }
    }

    playMusic(src) {
        const playing = !this.music.paused;
        this.music.src = src;
        this.autoplay = true;
        if (playing) this.music.play();
    }

    stopMusic() {
        this.music.pause();
        this.autoplay = false;
    }

    setBackground(image) {
        this.background = image;
    }
    
    async showImage(imageID, fileID, layer, x, y) {
        console.log(fileID);
        const image = await this.getFileImageElement(fileID);
        this.images.set(imageID, { image, layer, x, y });
    }

    hideImage(imageID) {
        this.images.delete(imageID);
    }

    showError(text) {
        this.error = true;
        this.dialoguePlayback.clear();
        this.dialoguePlayback.queue(text, ERROR_STYLE);
        this.dialoguePlayback.skip();
        this.dialoguePlayback.render();
        this.rendering.drawImage(this.dialoguePlayback.dialogueRendering.canvas, 0, 0);
        this.dispatchEvent(new CustomEvent("render"));
    }

    getActivePalette() {
        const avatar = getEventById(this.data, this.avatarId);
        const room = roomFromEvent(this.data, avatar);
        const palette = this.data.palettes[room.palette];
        return palette;
    }
}

/**
 * @param {BipsiPlayback} playback 
 * @param {BipsiDataEvent} event 
 * @returns {Promise}
 */
async function standardEventTouch(playback, event) {
    for (let script of STANDARD_SCRIPTS) {
        await playback.runJS(event, script);
    }
}

function sample(playback, id, type, values) {
    let iterator = playback.variables.get(id);

    if (iterator === undefined) {
        iterator = ITERATOR_FUNCS[type](values);
        playback.variables.set(id, iterator);
    }

    return iterator.next()?.value;
}

const ITERATOR_FUNCS = {
    "shuffle": makeShuffleIterator,
    "cycle": makeCycleIterator,
    "sequence": makeSequenceIterator,
}

function* makeShuffleIterator(values) {
    values = [...values];
    while (values.length > 0) {
        shuffleArray(values);
        for (let value of values) {
            yield value;
        }
    }
}

function* makeCycleIterator(values) {
    values = [...values];
    while (values.length > 0) {
        for (let value of values) {
            yield value;
        }
    }
}

function* makeSequenceIterator(values) {
    values = [...values];
    for (let value of values) {
        yield value;
    }
    while (values.length > 0) {
        yield values[values.length - 1];
    }
}

/**
 * @param {BipsiPlayback} playback 
 * @param {BipsiDataEvent} event 
 * @returns {Promise}
 */
async function runEventRemove(playback, event) {
    if (eventIsTagged(event, "one-time")) {
        removeEvent(playback.data, event);
    }
}

function fakedownToTag(text, fd, tag) {
    const pattern = new RegExp(`${fd}([^${fd}]+)${fd}`, 'g');
    return text.replace(pattern, `{+${tag}}$1{-${tag}}`);
}

function parseFakedown(text) {
    text = fakedownToTag(text, '##', 'shk');
    text = fakedownToTag(text, '~~', 'wvy');
    text = fakedownToTag(text, '==', 'rbw');
    text = fakedownToTag(text, '__', 'r');
    return text;
}

/**
 * @param {BipsiDataEvent} event 
 * @param {string} name 
 * @param {string?} type 
 */
function clearFields(event, name, type=undefined) {
    const fields = allFields(event, name, type);
    fields.forEach((field) => arrayDiscard(event.fields, field));
}

/**
 * @param {BipsiDataEvent} event 
 * @param {string} name 
 * @param {string} type 
 * @param {any[]} values
 */
function replaceFields(event, name, type, ...values) {
    clearFields(event, name, type);
    values.forEach((value) => {
        event.fields.push({
            key: name,
            type,
            data: value,
        });
    });
}

function replace(format) {
    const values = Array.prototype.slice.call(arguments, 1);
    return format.replace(/\[\s*(\d+)\s*\]/g, (match, index) => values[index] ?? match);
};

const WALK_DIRECTIONS = {
    "L": [-1,  0],
    "R": [ 1,  0],
    "U": [ 0, -1],
    "D": [ 0,  1],
    "<": [-1,  0],
    ">": [ 1,  0],
    "^": [ 0, -1],
    "v": [ 0,  1],
}

/**
 * @param {BipsiPlayback} playback 
 * @param {BipsiDataEvent} event 
 */
function generateScriptingDefines(playback, event) {
    // edit here to add new scripting functions
    const defines = {};
    
    defines.PLAYBACK = playback;
    defines.AVATAR = getEventById(playback.data, playback.avatarId);
    defines.LIBRARY = getEventById(playback.data, playback.libraryId);
    defines.EVENT = event;
    defines.PALETTE = playback.getActivePalette();

    defines.DO_STANDARD = () => standardEventTouch(playback, event);

    defines.SET_FIELDS = (event, name, type, ...values) => replaceFields(event, name, type, ...values);
    defines.FIELD = (event, name, type=undefined) => oneField(event, name, type)?.data;
    defines.FIELDS = (event, name, type=undefined) => allFields(event, name, type).map((field) => field.data);
    
    defines.IS_TAGGED = (event, name) => eventIsTagged(event, name);
    defines.TAG = (event, name) => replaceFields(event, name, "tag", true);
    defines.UNTAG = (event, name) => clearFields(event, name, "tag");

    defines.SET_GRAPHIC = (event, tile) => replaceFields(event, "graphic", "tile", tile);

    defines.WALK = async (event, sequence, delay=.4, wait=.4) => {
        const dirs = Array.from(sequence);
        for (const dir of dirs) {
            if (dir === ".") {
                await sleep(wait * 1000);
            } else {
                let [x, y] = event.position;
                const [dx, dy] = WALK_DIRECTIONS[dir];
                x = Math.max(0, Math.min(15, x + dx));
                y = Math.max(0, Math.min(15, y + dy));
                event.position = [x, y];
                await sleep(delay * 1000);
            }
        }
    };
    defines.MOVE = (event, location) => moveEvent(playback.data, event, location);
    defines.REMOVE = (event) => removeEvent(playback.data, event);

    defines.TOUCH = (event) => playback.touch(event);
    defines.EVENT_AT = (location) => getEventAtLocation(playback.data, location);
    defines.LOCATION_OF = (event) => getLocationOfEvent(playback.data, event);
    defines.FIND_EVENTS = (tag) => findEventsByTag(playback.data, tag); 
    defines.FIND_EVENT = (tag) => findEventByTag(playback.data, tag); 

    defines.GET = (key, fallback=undefined) => playback.variables.get(key) ?? fallback;
    defines.SET = (key, value) => playback.variables.set(key, value);

    defines.EVENT_ID = (event) => event.id;

    defines.TEXT_REPLACE = (text, ...values) => replace(text, ...values);

    defines.SAY = async (dialogue, options) => playback.say(dialogue, options);
    defines.SAY_FIELD = async (name, options) => {
        let text = oneField(event, name, "dialogue")?.data ?? `[FIELD MISSING: ${name}]`;
        await playback.say(text, options);
    }

    defines.TITLE = async (dialogue, options) => playback.title(dialogue, options);
    defines.DIALOGUE = playback.dialoguePlayback.waiter;
    defines.DIALOG = defines.DIALOGUE;

    defines.LOG = (text) => console.log(text);
    defines.DELAY = async (seconds) => sleep(seconds * 1000);

    defines.RESTART = () => playback.end();

    defines.SAMPLE = (id, type, ...values) => sample(playback, id, type, ...values);
    defines.SET_CSS = (name, value) => ONE(":root").style.setProperty(name, value);

    defines.RUN_JS = (script, event=defines.EVENT) => playback.runJS(event, script);

    defines.PLAY_MUSIC = (file) => playback.playMusic(playback.getFileObjectURL(file));
    defines.STOP_MUSIC = () => playback.stopMusic();

    defines.SHOW_IMAGE = (id, file, layer, x, y) => playback.showImage(id, file, layer, x, y);
    defines.HIDE_IMAGE = (id) => playback.hideImage(id);

    defines.FIELD_OR_LIBRARY = (field, event=defines.EVENT) => {
        let file = oneField(event, field, "file")?.data;
        let name = oneField(event, field, "text")?.data;

        if (!file && name && defines.LIBRARY) {
            file = oneField(defines.LIBRARY, name, "file")?.data;
        } else if (!file && defines.LIBRARY) {
            file = oneField(defines.LIBRARY, field, "file")?.data;
        }

        return file;
    };

    defines.POST = (message, origin="*") => postMessageParent(message, origin);

    //binksi
    defines.STORY = playback.story;
    defines.SET_INK_VAR = (field, value) => playback.story.variablesState.$(field, value);
    defines.GET_INK_VAR = (field) => playback.story.variablesState.$(field);
    defines.DIVERT_TO = (knot_name) => {
        playback.story.ChoosePathString(knot_name);
        return playback.continueStory();
    }

    return defines;
}

    </script>
    <script>!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).inkjs={})}(this,function(a){"use strict";function P(t){return(P="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function m(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}function u(t,e,n){return e&&i(t.prototype,e),n&&i(t,n),t}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&o(t,e)}function r(t){return(r=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function o(t,e){return(o=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function l(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch(t){return!1}}function h(t,e,n){return(h=l()?Reflect.construct:function(t,e,n){var i=[null];i.push.apply(i,e);var r=new(Function.bind.apply(t,i));return n&&o(r,n.prototype),r}).apply(null,arguments)}function c(t){var i="function"==typeof Map?new Map:void 0;return(c=function(t){if(null===t||(e=t,-1===Function.toString.call(e).indexOf("[native code]")))return t;var e;if("function"!=typeof t)throw new TypeError("Super expression must either be null or a function");if(void 0!==i){if(i.has(t))return i.get(t);i.set(t,n)}function n(){return h(t,arguments,r(this).constructor)}return n.prototype=Object.create(t.prototype,{constructor:{value:n,enumerable:!1,writable:!0,configurable:!0}}),o(n,t)})(t)}function f(t,e){return!e||"object"!=typeof e&&"function"!=typeof e?function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t):e}function v(n){var i=l();return function(){var t,e=r(n);return f(this,i?(t=r(this).constructor,Reflect.construct(e,arguments,t)):e.apply(this,arguments))}}function S(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){var n=t&&("undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"]);if(null==n)return;var i,r,a=[],s=!0,o=!1;try{for(n=n.call(t);!(s=(i=n.next()).done)&&(a.push(i.value),!e||a.length!==e);s=!0);}catch(t){o=!0,r=t}finally{try{s||null==n.return||n.return()}finally{if(o)throw r}}return a}(t,e)||p(t,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function d(t){return function(t){if(Array.isArray(t))return y(t)}(t)||function(t){if("undefined"!=typeof Symbol&&null!=t[Symbol.iterator]||null!=t["@@iterator"])return Array.from(t)}(t)||p(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function p(t,e){if(t){if("string"==typeof t)return y(t,e);var n=Object.prototype.toString.call(t).slice(8,-1);return"Object"===n&&t.constructor&&(n=t.constructor.name),"Map"===n||"Set"===n?Array.from(t):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?y(t,e):void 0}}function y(t,e){(null==e||e>t.length)&&(e=t.length);for(var n=0,i=new Array(e);n<e;n++)i[n]=t[n];return i}function pt(t,e){var n="undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(!n){if(Array.isArray(t)||(n=p(t))||e&&t&&"number"==typeof t.length){n&&(t=n);var i=0,r=function(){};return{s:r,n:function(){return i>=t.length?{done:!0}:{done:!1,value:t[i++]}},e:function(t){throw t},f:r}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var a,s=!0,o=!1;return{s:function(){n=n.call(t)},n:function(){var t=n.next();return s=t.done,t},e:function(t){o=!0,a=t},f:function(){try{s||null==n.return||n.return()}finally{if(o)throw a}}}}var t,e,k,n,O=function(){function s(){var t,e,n,i,r;m(this,s),this._components=[],this._componentsString=null,this._isRelative=!1,"string"==typeof arguments[0]?(t=arguments[0],this.componentsString=t):arguments[0]instanceof s.Component&&arguments[1]instanceof s?(e=arguments[0],n=arguments[1],this._components.push(e),this._components=this._components.concat(n._components)):arguments[0]instanceof Array&&(i=arguments[0],r=!!arguments[1],this._components=this._components.concat(i),this._isRelative=r)}return u(s,[{key:"isRelative",get:function(){return this._isRelative}},{key:"componentCount",get:function(){return this._components.length}},{key:"head",get:function(){return 0<this._components.length?this._components[0]:null}},{key:"tail",get:function(){return 2<=this._components.length?new s(this._components.slice(1,this._components.length)):s.self}},{key:"length",get:function(){return this._components.length}},{key:"lastComponent",get:function(){var t=this._components.length-1;return 0<=t?this._components[t]:null}},{key:"containsNamedComponent",get:function(){for(var t=0,e=this._components.length;t<e;t++)if(!this._components[t].isIndex)return!0;return!1}},{key:"GetComponent",value:function(t){return this._components[t]}},{key:"PathByAppendingPath",value:function(t){for(var e=new s,n=0,i=0;i<t._components.length&&t._components[i].isParent;++i)n++;for(var r=0;r<this._components.length-n;++r)e._components.push(this._components[r]);for(var a=n;a<t._components.length;++a)e._components.push(t._components[a]);return e}},{key:"componentsString",get:function(){return null==this._componentsString&&(this._componentsString=this._components.join("."),this.isRelative&&(this._componentsString="."+this._componentsString)),this._componentsString},set:function(t){if(this._components.length=0,this._componentsString=t,null!=this._componentsString&&""!=this._componentsString){"."==this._componentsString[0]&&(this._isRelative=!0,this._componentsString=this._componentsString.substring(1));var e,n=pt(this._componentsString.split("."));try{for(n.s();!(e=n.n()).done;){var i=e.value;/^(\-|\+)?([0-9]+|Infinity)$/.test(i)?this._components.push(new s.Component(parseInt(i))):this._components.push(new s.Component(i))}}catch(t){n.e(t)}finally{n.f()}}}},{key:"toString",value:function(){return this.componentsString}},{key:"Equals",value:function(t){if(null==t)return!1;if(t._components.length!=this._components.length)return!1;if(t.isRelative!=this.isRelative)return!1;for(var e=0,n=t._components.length;e<n;e++)if(!t._components[e].Equals(this._components[e]))return!1;return!0}},{key:"PathByAppendingComponent",value:function(t){var e,n=new s;return(e=n._components).push.apply(e,d(this._components)),n._components.push(t),n}}],[{key:"self",get:function(){var t=new s;return t._isRelative=!0,t}}]),s}();function g(t,e){if(!t)throw void 0!==e&&console.warn(e),console.trace&&console.trace(),new Error("")}function yt(t,e){return t instanceof e?t:null}function mt(t,e){if(t instanceof e)return t;throw new Error("".concat(t," is not of type ").concat(e))}function C(t){return t.hasValidName&&t.name?t:null}function b(t){return void 0===t?null:t}function _(t){return"object"===P(t)&&"function"==typeof t.Equals}O.parentId="^",t=O=O||{},e=function(){function e(t){m(this,e),this.index=-1,this.name=null,"string"==typeof t?this.name=t:this.index=t}return u(e,[{key:"isIndex",get:function(){return 0<=this.index}},{key:"isParent",get:function(){return this.name==t.parentId}},{key:"toString",value:function(){return this.isIndex?this.index.toString():this.name}},{key:"Equals",value:function(t){return null!=t&&t.isIndex==this.isIndex&&(this.isIndex?this.index==t.index:this.name==t.name)}}],[{key:"ToParent",value:function(){return new e(t.parentId)}}]),e}(),t.Component=e,(n=k=k||{}).AssertType=function(t,e,n){g(t instanceof e,n)},n.Assert=g;var w=function(){s(e,c(Error));var t=v(e);function e(){return m(this,e),t.apply(this,arguments)}return e}();function gt(t){throw new w("".concat(t," is null or undefined"))}var T=function(){function t(){m(this,t),this.parent=null,this._debugMetadata=null,this._path=null}return u(t,[{key:"debugMetadata",get:function(){return null===this._debugMetadata&&this.parent?this.parent.debugMetadata:this._debugMetadata},set:function(t){this._debugMetadata=t}},{key:"ownDebugMetadata",get:function(){return this._debugMetadata}},{key:"DebugLineNumberOfPath",value:function(t){if(null===t)return null;var e=this.rootContentContainer;if(e){var n=e.ContentAtPath(t).obj;if(n){var i=n.debugMetadata;if(null!==i)return i.startLineNumber}}return null}},{key:"path",get:function(){if(null==this._path)if(null==this.parent)this._path=new O;else{for(var t=[],e=this,n=yt(e.parent,Ot);null!==n;){var i=C(e);null!=i&&i.hasValidName?t.unshift(new O.Component(i.name)):t.unshift(new O.Component(n.content.indexOf(e))),n=yt((e=n).parent,Ot)}this._path=new O(t)}return this._path}},{key:"ResolvePath",value:function(t){if(null===t)return gt("path");if(t.isRelative){var e=yt(this,Ot);return null===e&&(k.Assert(null!==this.parent,"Can't resolve relative path because we don't have a parent"),e=yt(this.parent,Ot),k.Assert(null!==e,"Expected parent to be a container"),k.Assert(t.GetComponent(0).isParent),t=t.tail),null===e?gt("nearestContainer"):e.ContentAtPath(t)}var n=this.rootContentContainer;return null===n?gt("contentContainer"):n.ContentAtPath(t)}},{key:"ConvertPathToRelative",value:function(t){for(var e=this.path,n=Math.min(t.length,e.length),i=-1,r=0;r<n;++r){var a=e.GetComponent(r),s=t.GetComponent(r);if(!a.Equals(s))break;i=r}if(-1==i)return t;for(var o=e.componentCount-1-i,u=[],l=0;l<o;++l)u.push(O.Component.ToParent());for(var h=i+1;h<t.componentCount;++h)u.push(t.GetComponent(h));return new O(u,!0)}},{key:"CompactPathString",value:function(t){var e=null,n=null;return e=t.isRelative?(n=t.componentsString,this.path.PathByAppendingPath(t).componentsString):(n=this.ConvertPathToRelative(t).componentsString,t.componentsString),n.length<e.length?n:e}},{key:"rootContentContainer",get:function(){for(var t=this;t.parent;)t=t.parent;return yt(t,Ot)}},{key:"Copy",value:function(){throw Error("Not Implemented: Doesn't support copying")}},{key:"SetChild",value:function(t,e,n){t[e]&&(t[e]=null),t[e]=n,t[e]&&(t[e].parent=this)}}]),t}(),St=function(){function e(t){m(this,e),t=void 0!==t?t.toString():"",this.string=t}return u(e,[{key:"Length",get:function(){return this.string.length}},{key:"Append",value:function(t){null!==t&&(this.string+=t)}},{key:"AppendLine",value:function(t){void 0!==t&&this.Append(t),this.string+="\n"}},{key:"AppendFormat",value:function(t){for(var e=arguments.length,n=new Array(1<e?e-1:0),i=1;i<e;i++)n[i-1]=arguments[i];this.string+=t.replace(/{(\d+)}/g,function(t,e){return void 0!==n[e]?n[e]:t})}},{key:"toString",value:function(){return this.string}}]),e}(),kt=function(){function i(){var t,e,n;m(this,i),this.originName=null,this.itemName=null,void 0!==arguments[1]?(t=arguments[0],e=arguments[1],this.originName=t,this.itemName=e):arguments[0]&&(n=arguments[0].toString().split("."),this.originName=n[0],this.itemName=n[1])}return u(i,[{key:"isNull",get:function(){return null==this.originName&&null==this.itemName}},{key:"fullName",get:function(){return(null!==this.originName?this.originName:"?")+"."+this.itemName}},{key:"toString",value:function(){return this.fullName}},{key:"Equals",value:function(t){return t instanceof i&&(t.itemName==this.itemName&&t.originName==this.originName)}},{key:"copy",value:function(){return new i(this.originName,this.itemName)}},{key:"serialized",value:function(){return JSON.stringify({originName:this.originName,itemName:this.itemName})}}],[{key:"Null",get:function(){return new i(null,null)}},{key:"fromSerializedKey",value:function(t){var e=JSON.parse(t);if(!i.isLikeInkListItem(e))return i.Null;return new i(e.originName,e.itemName)}},{key:"isLikeInkListItem",value:function(t){return"object"===P(t)&&(!(!t.hasOwnProperty("originName")||!t.hasOwnProperty("itemName"))&&(("string"==typeof t.originName||null===typeof t.originName)&&("string"==typeof t.itemName||null===typeof t.itemName)))}}]),i}(),Ct=function(){s(l,c(Map));var o=v(l);function l(){var t,e,n=arguments;if(m(this,l),(t=o.call(this,n[0]instanceof l?n[0]:[])).origins=null,t._originNames=[],arguments[0]instanceof l){var i=arguments[0];t._originNames=i.originNames,null!==i.origins&&(t.origins=i.origins.slice())}else if("string"==typeof arguments[0]){var r=arguments[0],a=arguments[1];if(t.SetInitialOriginName(r),null===a.listDefinitions)return f(t,gt("originStory.listDefinitions"));var s=a.listDefinitions.TryListGetDefinition(r,null);if(!s.exists)throw new Error("InkList origin could not be found in story when constructing new list: "+r);if(null===s.result)return f(t,gt("def.result"));t.origins=[s.result]}else{"object"===P(arguments[0])&&arguments[0].hasOwnProperty("Key")&&arguments[0].hasOwnProperty("Value")&&(e=arguments[0],t.Add(e.Key,e.Value))}return t}return u(l,[{key:"AddItem",value:function(t){if(t instanceof kt){var e=t;if(null==e.originName)return void this.AddItem(e.itemName);if(null===this.origins)return gt("this.origins");var n,i=pt(this.origins);try{for(i.s();!(n=i.n()).done;){var r=n.value;if(r.name==e.originName){var a=r.TryGetValueForItem(e,0);if(a.exists)return void this.Add(e,a.result);throw new Error("Could not add the item "+e+" to this list because it doesn't exist in the original list definition in ink.")}}}catch(t){i.e(t)}finally{i.f()}throw new Error("Failed to add item to list because the item was from a new list definition that wasn't previously known to this list. Only items from previously known lists can be used, so that the int value can be found.")}var s=t,o=null;if(null===this.origins)return gt("this.origins");var u,l=pt(this.origins);try{for(l.s();!(u=l.n()).done;){var h=u.value;if(null===s)return gt("itemName");if(h.ContainsItemWithName(s)){if(null!=o)throw new Error("Could not add the item "+s+" to this list because it could come from either "+h.name+" or "+o.name);o=h}}}catch(t){l.e(t)}finally{l.f()}if(null==o)throw new Error("Could not add the item "+s+" to this list because it isn't known to any list definitions previously associated with this list.");var c=new kt(o.name,s),f=o.ValueForItem(c);this.Add(c,f)}},{key:"ContainsItemNamed",value:function(t){var e,n=pt(this);try{for(n.s();!(e=n.n()).done;){var i=S(e.value,1)[0];if(kt.fromSerializedKey(i).itemName==t)return!0}}catch(t){n.e(t)}finally{n.f()}return!1}},{key:"ContainsKey",value:function(t){return this.has(t.serialized())}},{key:"Add",value:function(t,e){var n=t.serialized();if(this.has(n))throw new Error("The Map already contains an entry for ".concat(t));this.set(n,e)}},{key:"Remove",value:function(t){return this.delete(t.serialized())}},{key:"Count",get:function(){return this.size}},{key:"originOfMaxItem",get:function(){if(null==this.origins)return null;var e=this.maxItem.Key.originName,n=null;return this.origins.every(function(t){return t.name!=e||(n=t,!1)}),n}},{key:"originNames",get:function(){if(0<this.Count){null==this._originNames&&0<this.Count?this._originNames=[]:(this._originNames||(this._originNames=[]),this._originNames.length=0);var t,e=pt(this);try{for(e.s();!(t=e.n()).done;){var n=S(t.value,1)[0],i=kt.fromSerializedKey(n);if(null===i.originName)return gt("item.originName");this._originNames.push(i.originName)}}catch(t){e.e(t)}finally{e.f()}}return this._originNames}},{key:"SetInitialOriginName",value:function(t){this._originNames=[t]}},{key:"SetInitialOriginNames",value:function(t){this._originNames=null==t?null:t.slice()}},{key:"maxItem",get:function(){var t,e={Key:kt.Null,Value:0},n=pt(this);try{for(n.s();!(t=n.n()).done;){var i=S(t.value,2),r=i[0],a=i[1],s=kt.fromSerializedKey(r);(e.Key.isNull||a>e.Value)&&(e={Key:s,Value:a})}}catch(t){n.e(t)}finally{n.f()}return e}},{key:"minItem",get:function(){var t,e={Key:kt.Null,Value:0},n=pt(this);try{for(n.s();!(t=n.n()).done;){var i=S(t.value,2),r=i[0],a=i[1],s=kt.fromSerializedKey(r);(e.Key.isNull||a<e.Value)&&(e={Key:s,Value:a})}}catch(t){n.e(t)}finally{n.f()}return e}},{key:"inverse",get:function(){var t=new l;if(null!=this.origins){var e,n=pt(this.origins);try{for(n.s();!(e=n.n()).done;){var i,r=pt(e.value.items);try{for(r.s();!(i=r.n()).done;){var a=S(i.value,2),s=a[0],o=a[1],u=kt.fromSerializedKey(s);this.ContainsKey(u)||t.Add(u,o)}}catch(t){r.e(t)}finally{r.f()}}}catch(t){n.e(t)}finally{n.f()}}return t}},{key:"all",get:function(){var t=new l;if(null!=this.origins){var e,n=pt(this.origins);try{for(n.s();!(e=n.n()).done;){var i,r=pt(e.value.items);try{for(r.s();!(i=r.n()).done;){var a=S(i.value,2),s=a[0],o=a[1],u=kt.fromSerializedKey(s);t.set(u.serialized(),o)}}catch(t){r.e(t)}finally{r.f()}}}catch(t){n.e(t)}finally{n.f()}}return t}},{key:"Union",value:function(t){var e,n=new l(this),i=pt(t);try{for(i.s();!(e=i.n()).done;){var r=S(e.value,2),a=r[0],s=r[1];n.set(a,s)}}catch(t){i.e(t)}finally{i.f()}return n}},{key:"Intersect",value:function(t){var e,n=new l,i=pt(this);try{for(i.s();!(e=i.n()).done;){var r=S(e.value,2),a=r[0],s=r[1];t.has(a)&&n.set(a,s)}}catch(t){i.e(t)}finally{i.f()}return n}},{key:"Without",value:function(t){var e,n=new l(this),i=pt(t);try{for(i.s();!(e=i.n()).done;){var r=S(e.value,1)[0];n.delete(r)}}catch(t){i.e(t)}finally{i.f()}return n}},{key:"Contains",value:function(t){var e,n=pt(t);try{for(n.s();!(e=n.n()).done;){var i=S(e.value,1)[0];if(!this.has(i))return!1}}catch(t){n.e(t)}finally{n.f()}return!0}},{key:"GreaterThan",value:function(t){return 0!=this.Count&&(0==t.Count||this.minItem.Value>t.maxItem.Value)}},{key:"GreaterThanOrEquals",value:function(t){return 0!=this.Count&&(0==t.Count||this.minItem.Value>=t.minItem.Value&&this.maxItem.Value>=t.maxItem.Value)}},{key:"LessThan",value:function(t){return 0!=t.Count&&(0==this.Count||this.maxItem.Value<t.minItem.Value)}},{key:"LessThanOrEquals",value:function(t){return 0!=t.Count&&(0==this.Count||this.maxItem.Value<=t.maxItem.Value&&this.minItem.Value<=t.minItem.Value)}},{key:"MaxAsList",value:function(){return 0<this.Count?new l(this.maxItem):new l}},{key:"MinAsList",value:function(){return 0<this.Count?new l(this.minItem):new l}},{key:"ListWithSubRange",value:function(t,e){if(0==this.Count)return new l;var n=this.orderedItems,i=0,r=Number.MAX_SAFE_INTEGER;Number.isInteger(t)?i=t:t instanceof l&&0<t.Count&&(i=t.minItem.Value),Number.isInteger(e)?r=e:t instanceof l&&0<t.Count&&(r=e.maxItem.Value);var a=new l;a.SetInitialOriginNames(this.originNames);var s,o=pt(n);try{for(o.s();!(s=o.n()).done;){var u=s.value;u.Value>=i&&u.Value<=r&&a.Add(u.Key,u.Value)}}catch(t){o.e(t)}finally{o.f()}return a}},{key:"Equals",value:function(t){if(t instanceof l==!1)return!1;if(t.Count!=this.Count)return!1;var e,n=pt(this);try{for(n.s();!(e=n.n()).done;){var i=S(e.value,1)[0];if(!t.has(i))return!1}}catch(t){n.e(t)}finally{n.f()}return!0}},{key:"orderedItems",get:function(){var t,e=new Array,n=pt(this);try{for(n.s();!(t=n.n()).done;){var i=S(t.value,2),r=i[0],a=i[1],s=kt.fromSerializedKey(r);e.push({Key:s,Value:a})}}catch(t){n.e(t)}finally{n.f()}return e.sort(function(t,e){return null===t.Key.originName?gt("x.Key.originName"):null===e.Key.originName?gt("y.Key.originName"):t.Value==e.Value?t.Key.originName.localeCompare(e.Key.originName):t.Value<e.Value?-1:t.Value>e.Value?1:0}),e}},{key:"toString",value:function(){for(var t=this.orderedItems,e=new St,n=0;n<t.length;n++){0<n&&e.Append(", ");var i=t[n].Key;if(null===i.itemName)return gt("item.itemName");e.Append(i.itemName)}return e.toString()}},{key:"valueOf",value:function(){return NaN}}],[{key:"FromString",value:function(t,e){var n,i=null===(n=e.listDefinitions)||void 0===n?void 0:n.FindSingleItemListWithName(t);if(i)return null===i.value?gt("listValue.value"):new l(i.value);throw new Error("Could not find the InkListItem from the string '"+t+"' to create an InkList because it doesn't exist in the original list definition in ink.")}}]),l}(),bt=function(){s(i,c(Error));var n=v(i);function i(t){var e;return m(this,i),(e=n.call(this,t)).useEndLineNumber=!1,e.message=t,e.name="StoryException",e}return i}();function E(t,e,n){if(null===t)return{result:n,exists:!1};var i=t.get(e);return void 0===i?{result:n,exists:!1}:{result:i,exists:!0}}var N,A,I=function(){s(e,T);var t=v(e);function e(){return m(this,e),t.apply(this,arguments)}return u(e,[{key:"Copy",value:function(){return mt(e.Create(this),T)}},{key:"BadCastException",value:function(t){return new bt("Can't cast "+this.valueObject+" from "+this.valueType+" to "+t)}}],[{key:"Create",value:function(t,e){if(e){if(e===N.Int&&Number.isInteger(Number(t)))return new wt(Number(t));if(e===N.Float&&!isNaN(t))return new F(Number(t))}return"boolean"==typeof t?new x(Boolean(t)):"string"==typeof t?new Tt(String(t)):Number.isInteger(Number(t))?new wt(Number(t)):isNaN(t)?t instanceof O?new Et(mt(t,O)):t instanceof Ct?new Pt(mt(t,Ct)):null:new F(Number(t))}}]),e}(),_t=function(){s(i,I);var n=v(i);function i(t){var e;return m(this,i),(e=n.call(this)).value=t,e}return u(i,[{key:"valueObject",get:function(){return this.value}},{key:"toString",value:function(){return null===this.value?gt("Value.value"):this.value.toString()}}]),i}(),x=function(){s(n,_t);var e=v(n);function n(t){return m(this,n),e.call(this,t||!1)}return u(n,[{key:"isTruthy",get:function(){return Boolean(this.value)}},{key:"valueType",get:function(){return N.Bool}},{key:"Cast",value:function(t){if(null===this.value)return gt("Value.value");if(t==this.valueType)return this;if(t==N.Int)return new wt(this.value?1:0);if(t==N.Float)return new F(this.value?1:0);if(t==N.String)return new Tt(this.value?"true":"false");throw this.BadCastException(t)}},{key:"toString",value:function(){return this.value?"true":"false"}}]),n}(),wt=function(){s(n,_t);var e=v(n);function n(t){return m(this,n),e.call(this,t||0)}return u(n,[{key:"isTruthy",get:function(){return 0!=this.value}},{key:"valueType",get:function(){return N.Int}},{key:"Cast",value:function(t){if(null===this.value)return gt("Value.value");if(t==this.valueType)return this;if(t==N.Bool)return new x(0!==this.value);if(t==N.Float)return new F(this.value);if(t==N.String)return new Tt(""+this.value);throw this.BadCastException(t)}}]),n}(),F=function(){s(n,_t);var e=v(n);function n(t){return m(this,n),e.call(this,t||0)}return u(n,[{key:"isTruthy",get:function(){return 0!=this.value}},{key:"valueType",get:function(){return N.Float}},{key:"Cast",value:function(t){if(null===this.value)return gt("Value.value");if(t==this.valueType)return this;if(t==N.Bool)return new x(0!==this.value);if(t==N.Int)return new wt(this.value);if(t==N.String)return new Tt(""+this.value);throw this.BadCastException(t)}}]),n}(),Tt=function(){s(i,_t);var n=v(i);function i(t){var e;return m(this,i),(e=n.call(this,t||""))._isNewline="\n"==e.value,e._isInlineWhitespace=!0,null===e.value?f(e,gt("Value.value")):(0<e.value.length&&e.value.split("").every(function(t){return" "==t||"\t"==t||(e._isInlineWhitespace=!1)}),e)}return u(i,[{key:"valueType",get:function(){return N.String}},{key:"isTruthy",get:function(){return null===this.value?gt("Value.value"):0<this.value.length}},{key:"isNewline",get:function(){return this._isNewline}},{key:"isInlineWhitespace",get:function(){return this._isInlineWhitespace}},{key:"isNonWhitespace",get:function(){return!this.isNewline&&!this.isInlineWhitespace}},{key:"Cast",value:function(t){if(t==this.valueType)return this;if(t==N.Int){var e=function(t,e){var n=1<arguments.length&&void 0!==e?e:0,i=parseInt(t);return Number.isNaN(i)?{result:n,exists:!1}:{result:i,exists:!0}}(this.value);if(e.exists)return new wt(e.result);throw this.BadCastException(t)}if(t!=N.Float)throw this.BadCastException(t);var n=function(t,e){var n=1<arguments.length&&void 0!==e?e:0,i=parseFloat(t);return Number.isNaN(i)?{result:n,exists:!1}:{result:i,exists:!0}}(this.value);if(n.exists)return new F(n.result);throw this.BadCastException(t)}}]),i}(),Et=function(){s(n,_t);var e=v(n);function n(t){return m(this,n),e.call(this,t)}return u(n,[{key:"valueType",get:function(){return N.DivertTarget}},{key:"targetPath",get:function(){return null===this.value?gt("Value.value"):this.value},set:function(t){this.value=t}},{key:"isTruthy",get:function(){throw new Error("Shouldn't be checking the truthiness of a divert target")}},{key:"Cast",value:function(t){if(t==this.valueType)return this;throw this.BadCastException(t)}},{key:"toString",value:function(){return"DivertTargetValue("+this.targetPath+")"}}]),n}(),W=function(){s(r,_t);var i=v(r);function r(t){var e,n=1<arguments.length&&void 0!==arguments[1]?arguments[1]:-1;return m(this,r),(e=i.call(this,t))._contextIndex=n,e}return u(r,[{key:"contextIndex",get:function(){return this._contextIndex},set:function(t){this._contextIndex=t}},{key:"variableName",get:function(){return null===this.value?gt("Value.value"):this.value},set:function(t){this.value=t}},{key:"valueType",get:function(){return N.VariablePointer}},{key:"isTruthy",get:function(){throw new Error("Shouldn't be checking the truthiness of a variable pointer")}},{key:"Cast",value:function(t){if(t==this.valueType)return this;throw this.BadCastException(t)}},{key:"toString",value:function(){return"VariablePointerValue("+this.variableName+")"}},{key:"Copy",value:function(){return new r(this.variableName,this.contextIndex)}}]),r}(),Pt=function(){s(r,_t);var i=v(r);function r(t,e){var n;return m(this,r),n=i.call(this,null),t||e?t instanceof Ct?n.value=new Ct(t):t instanceof kt&&"number"==typeof e&&(n.value=new Ct({Key:t,Value:e})):n.value=new Ct,n}return u(r,[{key:"isTruthy",get:function(){return null===this.value?gt("this.value"):0<this.value.Count}},{key:"valueType",get:function(){return N.List}},{key:"Cast",value:function(t){if(null===this.value)return gt("Value.value");if(t==N.Int){var e=this.value.maxItem;return e.Key.isNull?new wt(0):new wt(e.Value)}if(t==N.Float){var n=this.value.maxItem;return n.Key.isNull?new F(0):new F(n.Value)}if(t==N.String){var i=this.value.maxItem;return i.Key.isNull?new Tt(""):new Tt(i.Key.toString())}if(t==this.valueType)return this;throw this.BadCastException(t)}}],[{key:"RetainListOriginsForAssignment",value:function(t,e){var n=yt(t,r),i=yt(e,r);return i&&null===i.value?gt("newList.value"):n&&null===n.value?gt("oldList.value"):void(n&&i&&0==i.value.Count&&i.value.SetInitialOriginNames(n.value.originNames))}}]),r}();(A=N=N||{})[A.Bool=-1]="Bool",A[A.Int=0]="Int",A[A.Float=1]="Float",A[A.List=2]="List",A[A.String=3]="String",A[A.DivertTarget=4]="DivertTarget",A[A.VariablePointer=5]="VariablePointer";var V,L,R=function(){function e(){m(this,e),this.obj=null,this.approximate=!1}return u(e,[{key:"correctObj",get:function(){return this.approximate?null:this.obj}},{key:"container",get:function(){return this.obj instanceof Ot?this.obj:null}},{key:"copy",value:function(){var t=new e;return t.obj=this.obj,t.approximate=this.approximate,t}}]),e}(),Ot=function(){s(g,T);var e=v(g);function g(){var t;return m(this,g),(t=e.apply(this,arguments)).name="",t._content=[],t.namedContent=new Map,t.visitsShouldBeCounted=!1,t.turnIndexShouldBeCounted=!1,t.countingAtStartOnly=!1,t._pathToFirstLeafContent=null,t}return u(g,[{key:"hasValidName",get:function(){return null!=this.name&&0<this.name.length}},{key:"content",get:function(){return this._content},set:function(t){this.AddContent(t)}},{key:"namedOnlyContent",get:function(){var t,e=new Map,n=pt(this.namedContent);try{for(n.s();!(t=n.n()).done;){var i=S(t.value,2),r=i[0],a=mt(i[1],T);e.set(r,a)}}catch(t){n.e(t)}finally{n.f()}var s,o=pt(this.content);try{for(o.s();!(s=o.n()).done;){var u=C(s.value);null!=u&&u.hasValidName&&e.delete(u.name)}}catch(t){o.e(t)}finally{o.f()}return 0==e.size&&(e=null),e},set:function(t){var e=this.namedOnlyContent;if(null!=e){var n,i=pt(e);try{for(i.s();!(n=i.n()).done;){var r=S(n.value,1)[0];this.namedContent.delete(r)}}catch(t){i.e(t)}finally{i.f()}}if(null!=t){var a,s=pt(t);try{for(s.s();!(a=s.n()).done;){var o=C(S(a.value,2)[1]);null!=o&&this.AddToNamedContentOnly(o)}}catch(t){s.e(t)}finally{s.f()}}}},{key:"countFlags",get:function(){var t=0;return this.visitsShouldBeCounted&&(t|=g.CountFlags.Visits),this.turnIndexShouldBeCounted&&(t|=g.CountFlags.Turns),this.countingAtStartOnly&&(t|=g.CountFlags.CountStartOnly),t==g.CountFlags.CountStartOnly&&(t=0),t},set:function(t){var e=t;0<(e&g.CountFlags.Visits)&&(this.visitsShouldBeCounted=!0),0<(e&g.CountFlags.Turns)&&(this.turnIndexShouldBeCounted=!0),0<(e&g.CountFlags.CountStartOnly)&&(this.countingAtStartOnly=!0)}},{key:"pathToFirstLeafContent",get:function(){return null==this._pathToFirstLeafContent&&(this._pathToFirstLeafContent=this.path.PathByAppendingPath(this.internalPathToFirstLeafContent)),this._pathToFirstLeafContent}},{key:"internalPathToFirstLeafContent",get:function(){for(var t=[],e=this;e instanceof g;)0<e.content.length&&(t.push(new O.Component(0)),e=e.content[0]);return new O(t)}},{key:"AddContent",value:function(t){if(t instanceof Array){var e,n=pt(t);try{for(n.s();!(e=n.n()).done;){var i=e.value;this.AddContent(i)}}catch(t){n.e(t)}finally{n.f()}}else{var r=t;if(this._content.push(r),r.parent)throw new Error("content is already in "+r.parent);(r.parent=this).TryAddNamedContent(r)}}},{key:"TryAddNamedContent",value:function(t){var e=C(t);null!=e&&e.hasValidName&&this.AddToNamedContentOnly(e)}},{key:"AddToNamedContentOnly",value:function(t){k.AssertType(t,T,"Can only add Runtime.Objects to a Runtime.Container"),(mt(t,T).parent=this).namedContent.set(t.name,t)}},{key:"ContentAtPath",value:function(t,e,n){var i=1<arguments.length&&void 0!==e?e:0,r=2<arguments.length&&void 0!==n?n:-1;-1==r&&(r=t.length);var a=new R;a.approximate=!1;for(var s=this,o=this,u=i;u<r;++u){var l=t.GetComponent(u);if(null==s){a.approximate=!0;break}var h=s.ContentWithPathComponent(l);if(null==h){a.approximate=!0;break}s=yt(o=h,g)}return a.obj=o,a}},{key:"InsertContent",value:function(t,e){if((this.content[e]=t).parent)throw new Error("content is already in "+t.parent);(t.parent=this).TryAddNamedContent(t)}},{key:"AddContentsOfContainer",value:function(t){this.content=this.content.concat(t.content);var e,n=pt(t.content);try{for(n.s();!(e=n.n()).done;){var i=e.value;(i.parent=this).TryAddNamedContent(i)}}catch(t){n.e(t)}finally{n.f()}}},{key:"ContentWithPathComponent",value:function(t){if(t.isIndex)return 0<=t.index&&t.index<this.content.length?this.content[t.index]:null;if(t.isParent)return this.parent;if(null===t.name)return gt("component.name");var e=E(this.namedContent,t.name,null);return e.exists?mt(e.result,T):null}},{key:"BuildStringOfHierarchy",value:function(t,e,n){var i;if(0==arguments.length)return i=new St,this.BuildStringOfHierarchy(i,0,null),i.toString();i=t;var r=e,a=n;function s(){for(var t=0;t<4*r;++t)i.Append(" ")}s(),i.Append("["),this.hasValidName&&i.AppendFormat(" ({0})",this.name),this==a&&i.Append("  <---"),i.AppendLine(),r++;for(var o=0;o<this.content.length;++o){var u=this.content[o];u instanceof g?u.BuildStringOfHierarchy(i,r,a):(s(),u instanceof Tt?(i.Append('"'),i.Append(u.toString().replace("\n","\\n")),i.Append('"')):i.Append(u.toString())),o!=this.content.length-1&&i.Append(","),u instanceof g||u!=a||i.Append("  <---"),i.AppendLine()}var l,h=new Map,c=pt(this.namedContent);try{for(c.s();!(l=c.n()).done;){var f=S(l.value,2),v=f[0],d=f[1];0<=this.content.indexOf(mt(d,T))||h.set(v,d)}}catch(t){c.e(t)}finally{c.f()}if(0<h.size){s(),i.AppendLine("-- named: --");var p,y=pt(h);try{for(y.s();!(p=y.n()).done;){var m=S(p.value,2)[1];k.AssertType(m,g,"Can only print out named Containers"),m.BuildStringOfHierarchy(i,r,a),i.AppendLine()}}catch(t){y.e(t)}finally{y.f()}}r--,s(),i.Append("]")}}]),g}();V=Ot=Ot||{},(L=V.CountFlags||(V.CountFlags={}))[L.Visits=1]="Visits",L[L.Turns=2]="Turns",L[L.CountStartOnly=4]="CountStartOnly";var j,D,Nt,B,G=function(){s(e,T);var t=v(e);function e(){return m(this,e),t.apply(this,arguments)}return u(e,[{key:"toString",value:function(){return"Glue"}}]),e}(),At=function(){s(i,T);var n=v(i);function i(){var t,e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:i.CommandType.NotSet;return m(this,i),(t=n.call(this))._commandType=e,t}return u(i,[{key:"commandType",get:function(){return this._commandType}},{key:"Copy",value:function(){return new i(this.commandType)}},{key:"toString",value:function(){return this.commandType.toString()}}],[{key:"EvalStart",value:function(){return new i(i.CommandType.EvalStart)}},{key:"EvalOutput",value:function(){return new i(i.CommandType.EvalOutput)}},{key:"EvalEnd",value:function(){return new i(i.CommandType.EvalEnd)}},{key:"Duplicate",value:function(){return new i(i.CommandType.Duplicate)}},{key:"PopEvaluatedValue",value:function(){return new i(i.CommandType.PopEvaluatedValue)}},{key:"PopFunction",value:function(){return new i(i.CommandType.PopFunction)}},{key:"PopTunnel",value:function(){return new i(i.CommandType.PopTunnel)}},{key:"BeginString",value:function(){return new i(i.CommandType.BeginString)}},{key:"EndString",value:function(){return new i(i.CommandType.EndString)}},{key:"NoOp",value:function(){return new i(i.CommandType.NoOp)}},{key:"ChoiceCount",value:function(){return new i(i.CommandType.ChoiceCount)}},{key:"Turns",value:function(){return new i(i.CommandType.Turns)}},{key:"TurnsSince",value:function(){return new i(i.CommandType.TurnsSince)}},{key:"ReadCount",value:function(){return new i(i.CommandType.ReadCount)}},{key:"Random",value:function(){return new i(i.CommandType.Random)}},{key:"SeedRandom",value:function(){return new i(i.CommandType.SeedRandom)}},{key:"VisitIndex",value:function(){return new i(i.CommandType.VisitIndex)}},{key:"SequenceShuffleIndex",value:function(){return new i(i.CommandType.SequenceShuffleIndex)}},{key:"StartThread",value:function(){return new i(i.CommandType.StartThread)}},{key:"Done",value:function(){return new i(i.CommandType.Done)}},{key:"End",value:function(){return new i(i.CommandType.End)}},{key:"ListFromInt",value:function(){return new i(i.CommandType.ListFromInt)}},{key:"ListRange",value:function(){return new i(i.CommandType.ListRange)}},{key:"ListRandom",value:function(){return new i(i.CommandType.ListRandom)}}]),i}();j=At=At||{},(D=j.CommandType||(j.CommandType={}))[D.NotSet=-1]="NotSet",D[D.EvalStart=0]="EvalStart",D[D.EvalOutput=1]="EvalOutput",D[D.EvalEnd=2]="EvalEnd",D[D.Duplicate=3]="Duplicate",D[D.PopEvaluatedValue=4]="PopEvaluatedValue",D[D.PopFunction=5]="PopFunction",D[D.PopTunnel=6]="PopTunnel",D[D.BeginString=7]="BeginString",D[D.EndString=8]="EndString",D[D.NoOp=9]="NoOp",D[D.ChoiceCount=10]="ChoiceCount",D[D.Turns=11]="Turns",D[D.TurnsSince=12]="TurnsSince",D[D.Random=13]="Random",D[D.SeedRandom=14]="SeedRandom",D[D.VisitIndex=15]="VisitIndex",D[D.SequenceShuffleIndex=16]="SequenceShuffleIndex",D[D.StartThread=17]="StartThread",D[D.Done=18]="Done",D[D.End=19]="End",D[D.ListFromInt=20]="ListFromInt",D[D.ListRange=21]="ListRange",D[D.ListRandom=22]="ListRandom",D[D.ReadCount=23]="ReadCount",D[D.TOTAL_VALUES=24]="TOTAL_VALUES",(B=Nt=Nt||{})[B.Tunnel=0]="Tunnel",B[B.Function=1]="Function",B[B.FunctionEvaluationFromGame=2]="FunctionEvaluationFromGame";var It=function(){function e(){m(this,e),this.container=null,this.index=-1,2===arguments.length&&(this.container=arguments[0],this.index=arguments[1])}return u(e,[{key:"Resolve",value:function(){return this.index<0?this.container:null==this.container?null:0==this.container.content.length?this.container:this.index>=this.container.content.length?null:this.container.content[this.index]}},{key:"isNull",get:function(){return null==this.container}},{key:"path",get:function(){return this.isNull?null:0<=this.index?this.container.path.PathByAppendingComponent(new O.Component(this.index)):this.container.path}},{key:"toString",value:function(){return this.container?"Ink Pointer -> "+this.container.path.toString()+" -- index "+this.index:"Ink Pointer (null)"}},{key:"copy",value:function(){return new e(this.container,this.index)}}],[{key:"StartOf",value:function(t){return new e(t,0)}},{key:"Null",get:function(){return new e(null,-1)}}]),e}(),xt=function(){s(i,T);var n=v(i);function i(t){var e;return m(this,i),(e=n.call(this))._targetPath=null,e._targetPointer=It.Null,e.variableDivertName=null,e.pushesToStack=!1,e.stackPushType=0,e.isExternal=!1,e.externalArgs=0,e.isConditional=!1,e.pushesToStack=!1,void 0!==t&&(e.pushesToStack=!0,e.stackPushType=t),e}return u(i,[{key:"targetPath",get:function(){var t;return null==this._targetPath||!this._targetPath.isRelative||(t=this.targetPointer.Resolve())&&(this._targetPath=t.path),this._targetPath},set:function(t){this._targetPath=t,this._targetPointer=It.Null}},{key:"targetPointer",get:function(){if(this._targetPointer.isNull){var t=this.ResolvePath(this._targetPath).obj;if(null===this._targetPath)return gt("this._targetPath");if(null===this._targetPath.lastComponent)return gt("this._targetPath.lastComponent");if(this._targetPath.lastComponent.isIndex){if(null===t)return gt("targetObj");this._targetPointer.container=t.parent instanceof Ot?t.parent:null,this._targetPointer.index=this._targetPath.lastComponent.index}else this._targetPointer=It.StartOf(t instanceof Ot?t:null)}return this._targetPointer.copy()}},{key:"targetPathString",get:function(){return null==this.targetPath?null:this.CompactPathString(this.targetPath)},set:function(t){this.targetPath=null==t?null:new O(t)}},{key:"hasVariableTarget",get:function(){return null!=this.variableDivertName}},{key:"Equals",value:function(t){var e=t;return e instanceof i&&this.hasVariableTarget==e.hasVariableTarget&&(this.hasVariableTarget?this.variableDivertName==e.variableDivertName:null===this.targetPath?gt("this.targetPath"):this.targetPath.Equals(e.targetPath))}},{key:"toString",value:function(){if(this.hasVariableTarget)return"Divert(variable: "+this.variableDivertName+")";if(null==this.targetPath)return"Divert(null)";var t=new St,e=this.targetPath.toString();return t.Append("Divert"),this.isConditional&&t.Append("?"),this.pushesToStack&&(this.stackPushType==Nt.Function?t.Append(" function"):t.Append(" tunnel")),t.Append(" -> "),t.Append(this.targetPathString),t.Append(" ("),t.Append(e),t.Append(")"),t.toString()}}]),i}(),M=function(){s(i,T);var n=v(i);function i(){var t,e=!(0<arguments.length&&void 0!==arguments[0])||arguments[0];return m(this,i),(t=n.call(this))._pathOnChoice=null,t.hasCondition=!1,t.hasStartContent=!1,t.hasChoiceOnlyContent=!1,t.isInvisibleDefault=!1,t.onceOnly=!0,t.onceOnly=e,t}return u(i,[{key:"pathOnChoice",get:function(){var t;return null==this._pathOnChoice||!this._pathOnChoice.isRelative||(t=this.choiceTarget)&&(this._pathOnChoice=t.path),this._pathOnChoice},set:function(t){this._pathOnChoice=t}},{key:"choiceTarget",get:function(){return null===this._pathOnChoice?gt("ChoicePoint._pathOnChoice"):this.ResolvePath(this._pathOnChoice).container}},{key:"pathStringOnChoice",get:function(){return null===this.pathOnChoice?gt("ChoicePoint.pathOnChoice"):this.CompactPathString(this.pathOnChoice)},set:function(t){this.pathOnChoice=new O(t)}},{key:"flags",get:function(){var t=0;return this.hasCondition&&(t|=1),this.hasStartContent&&(t|=2),this.hasChoiceOnlyContent&&(t|=4),this.isInvisibleDefault&&(t|=8),this.onceOnly&&(t|=16),t},set:function(t){this.hasCondition=0<(1&t),this.hasStartContent=0<(2&t),this.hasChoiceOnlyContent=0<(4&t),this.isInvisibleDefault=0<(8&t),this.onceOnly=0<(16&t)}},{key:"toString",value:function(){return null===this.pathOnChoice?gt("ChoicePoint.pathOnChoice"):"Choice: -> "+this.pathOnChoice.toString()}}]),i}(),Ft=function(){s(i,T);var n=v(i);function i(){var t,e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:null;return m(this,i),(t=n.call(this)).pathForCount=null,t.name=e,t}return u(i,[{key:"containerForCount",get:function(){return null===this.pathForCount?null:this.ResolvePath(this.pathForCount).container}},{key:"pathStringForCount",get:function(){return null===this.pathForCount?null:this.CompactPathString(this.pathForCount)},set:function(t){this.pathForCount=null===t?null:new O(t)}},{key:"toString",value:function(){return null!=this.name?"var("+this.name+")":"read_count("+this.pathStringForCount+")"}}]),i}(),Wt=function(){s(r,T);var i=v(r);function r(t,e){var n;return m(this,r),(n=i.call(this)).variableName=t||null,n.isNewDeclaration=!!e,n.isGlobal=!1,n}return u(r,[{key:"toString",value:function(){return"VarAssign to "+this.variableName}}]),r}(),Vt=function(){s(e,T);var t=v(e);function e(){return m(this,e),t.apply(this,arguments)}return e}(),Lt=function(){s(f,T);var r=v(f);function f(){var t,e,n,i;return m(this,f),(t=r.call(this))._name=null,t._numberOfParameters=0,t._prototype=null,t._isPrototype=!1,t._operationFuncs=null,0===arguments.length?f.GenerateNativeFunctionsIfNecessary():1===arguments.length?(e=arguments[0],f.GenerateNativeFunctionsIfNecessary(),t.name=e):2===arguments.length&&(n=arguments[0],i=arguments[1],t._isPrototype=!0,t.name=n,t.numberOfParameters=i),t}return u(f,[{key:"name",get:function(){return null===this._name?gt("NativeFunctionCall._name"):this._name},set:function(t){this._name=t,this._isPrototype||(null===f._nativeFunctions?gt("NativeFunctionCall._nativeFunctions"):this._prototype=f._nativeFunctions.get(this._name)||null)}},{key:"numberOfParameters",get:function(){return this._prototype?this._prototype.numberOfParameters:this._numberOfParameters},set:function(t){this._numberOfParameters=t}},{key:"Call",value:function(t){if(this._prototype)return this._prototype.Call(t);if(this.numberOfParameters!=t.length)throw new Error("Unexpected number of parameters");var e,n=!1,i=pt(t);try{for(i.s();!(e=i.n()).done;){var r=e.value;if(r instanceof Vt)throw new bt('Attempting to perform operation on a void value. Did you forget to "return" a value from a function you called here?');r instanceof Pt&&(n=!0)}}catch(t){i.e(t)}finally{i.f()}if(2==t.length&&n)return this.CallBinaryListOperation(t);var a=this.CoerceValuesToSingleType(t),s=a[0].valueType;return s==N.Int||s==N.Float||s==N.String||s==N.DivertTarget||s==N.List?this.CallType(a):null}},{key:"CallType",value:function(t){var e=mt(t[0],_t),n=e.valueType,i=e,r=t.length;if(2!=r&&1!=r)throw new Error("Unexpected number of parameters to NativeFunctionCall: "+t.length);if(null===this._operationFuncs)return gt("NativeFunctionCall._operationFuncs");var a=this._operationFuncs.get(n);if(!a){var s=N[n];throw new bt("Cannot perform operation "+this.name+" on "+s)}if(2==r){var o=mt(t[1],_t),u=a;if(null===i.value||null===o.value)return gt("NativeFunctionCall.Call BinaryOp values");var l=u(i.value,o.value);return _t.Create(l)}var h=a;if(null===i.value)return gt("NativeFunctionCall.Call UnaryOp value");var c=h(i.value);return this.name===f.Int?_t.Create(c,N.Int):this.name===f.Float?_t.Create(c,N.Float):_t.Create(c,e.valueType)}},{key:"CallBinaryListOperation",value:function(t){if(("+"==this.name||"-"==this.name)&&t[0]instanceof Pt&&t[1]instanceof wt)return this.CallListIncrementOperation(t);var e=mt(t[0],_t),n=mt(t[1],_t);if(!("&&"!=this.name&&"||"!=this.name||e.valueType==N.List&&n.valueType==N.List)){if(null===this._operationFuncs)return gt("NativeFunctionCall._operationFuncs");var i=this._operationFuncs.get(N.Int);if(null===i)return gt("NativeFunctionCall.CallBinaryListOperation op");var r=function(t){if("boolean"==typeof t)return t;throw new Error("".concat(t," is not a boolean"))}(i(e.isTruthy?1:0,n.isTruthy?1:0));return new x(r)}if(e.valueType==N.List&&n.valueType==N.List)return this.CallType([e,n]);throw new bt("Can not call use "+this.name+" operation on "+N[e.valueType]+" and "+N[n.valueType])}},{key:"CallListIncrementOperation",value:function(t){var e=mt(t[0],Pt),n=mt(t[1],wt),i=new Ct;if(null===e.value)return gt("NativeFunctionCall.CallListIncrementOperation listVal.value");var r,a=pt(e.value);try{for(a.s();!(r=a.n()).done;){var s=S(r.value,2),o=s[0],u=s[1],l=kt.fromSerializedKey(o);if(null===this._operationFuncs)return gt("NativeFunctionCall._operationFuncs");var h=this._operationFuncs.get(N.Int);if(null===n.value)return gt("NativeFunctionCall.CallListIncrementOperation intVal.value");var c=h(u,n.value),f=null;if(null===e.value.origins)return gt("NativeFunctionCall.CallListIncrementOperation listVal.value.origins");var v,d,p=pt(e.value.origins);try{for(p.s();!(v=p.n()).done;){var y=v.value;if(y.name==l.originName){f=y;break}}}catch(t){p.e(t)}finally{p.f()}null==f||(d=f.TryGetItemWithValue(c,kt.Null)).exists&&i.Add(d.result,c)}}catch(t){a.e(t)}finally{a.f()}return new Pt(i)}},{key:"CoerceValuesToSingleType",value:function(t){var e,n=N.Int,i=null,r=pt(t);try{for(r.s();!(e=r.n()).done;){var a=mt(e.value,_t);a.valueType>n&&(n=a.valueType),a.valueType==N.List&&(i=yt(a,Pt))}}catch(t){r.e(t)}finally{r.f()}var s=[];if(N[n]==N[N.List]){var o,u=pt(t);try{for(u.s();!(o=u.n()).done;){var l=mt(o.value,_t);if(l.valueType==N.List)s.push(l);else{if(l.valueType!=N.Int){var h=N[l.valueType];throw new bt("Cannot mix Lists and "+h+" values in this operation")}var c=parseInt(l.valueObject);if(null===(i=mt(i,Pt)).value)return gt("NativeFunctionCall.CoerceValuesToSingleType specialCaseList.value");var f=i.value.originOfMaxItem;if(null===f)return gt("NativeFunctionCall.CoerceValuesToSingleType list");var v=f.TryGetItemWithValue(c,kt.Null);if(!v.exists)throw new bt("Could not find List item with the value "+c+" in "+f.name);var d=new Pt(v.result,c);s.push(d)}}}catch(t){u.e(t)}finally{u.f()}}else{var p,y=pt(t);try{for(y.s();!(p=y.n()).done;){var m=mt(p.value,_t).Cast(n);s.push(m)}}catch(t){y.e(t)}finally{y.f()}}return s}},{key:"AddOpFuncForType",value:function(t,e){null==this._operationFuncs&&(this._operationFuncs=new Map),this._operationFuncs.set(t,e)}},{key:"toString",value:function(){return'Native "'+this.name+'"'}}],[{key:"CallWithName",value:function(t){return new f(t)}},{key:"CallExistsWithName",value:function(t){return this.GenerateNativeFunctionsIfNecessary(),this._nativeFunctions.get(t)}},{key:"Identity",value:function(t){return t}},{key:"GenerateNativeFunctionsIfNecessary",value:function(){null==this._nativeFunctions&&(this._nativeFunctions=new Map,this.AddIntBinaryOp(this.Add,function(t,e){return t+e}),this.AddIntBinaryOp(this.Subtract,function(t,e){return t-e}),this.AddIntBinaryOp(this.Multiply,function(t,e){return t*e}),this.AddIntBinaryOp(this.Divide,function(t,e){return Math.floor(t/e)}),this.AddIntBinaryOp(this.Mod,function(t,e){return t%e}),this.AddIntUnaryOp(this.Negate,function(t){return-t}),this.AddIntBinaryOp(this.Equal,function(t,e){return t==e}),this.AddIntBinaryOp(this.Greater,function(t,e){return e<t}),this.AddIntBinaryOp(this.Less,function(t,e){return t<e}),this.AddIntBinaryOp(this.GreaterThanOrEquals,function(t,e){return e<=t}),this.AddIntBinaryOp(this.LessThanOrEquals,function(t,e){return t<=e}),this.AddIntBinaryOp(this.NotEquals,function(t,e){return t!=e}),this.AddIntUnaryOp(this.Not,function(t){return 0==t}),this.AddIntBinaryOp(this.And,function(t,e){return 0!=t&&0!=e}),this.AddIntBinaryOp(this.Or,function(t,e){return 0!=t||0!=e}),this.AddIntBinaryOp(this.Max,function(t,e){return Math.max(t,e)}),this.AddIntBinaryOp(this.Min,function(t,e){return Math.min(t,e)}),this.AddIntBinaryOp(this.Pow,function(t,e){return Math.pow(t,e)}),this.AddIntUnaryOp(this.Floor,f.Identity),this.AddIntUnaryOp(this.Ceiling,f.Identity),this.AddIntUnaryOp(this.Int,f.Identity),this.AddIntUnaryOp(this.Float,function(t){return t}),this.AddFloatBinaryOp(this.Add,function(t,e){return t+e}),this.AddFloatBinaryOp(this.Subtract,function(t,e){return t-e}),this.AddFloatBinaryOp(this.Multiply,function(t,e){return t*e}),this.AddFloatBinaryOp(this.Divide,function(t,e){return t/e}),this.AddFloatBinaryOp(this.Mod,function(t,e){return t%e}),this.AddFloatUnaryOp(this.Negate,function(t){return-t}),this.AddFloatBinaryOp(this.Equal,function(t,e){return t==e}),this.AddFloatBinaryOp(this.Greater,function(t,e){return e<t}),this.AddFloatBinaryOp(this.Less,function(t,e){return t<e}),this.AddFloatBinaryOp(this.GreaterThanOrEquals,function(t,e){return e<=t}),this.AddFloatBinaryOp(this.LessThanOrEquals,function(t,e){return t<=e}),this.AddFloatBinaryOp(this.NotEquals,function(t,e){return t!=e}),this.AddFloatUnaryOp(this.Not,function(t){return 0==t}),this.AddFloatBinaryOp(this.And,function(t,e){return 0!=t&&0!=e}),this.AddFloatBinaryOp(this.Or,function(t,e){return 0!=t||0!=e}),this.AddFloatBinaryOp(this.Max,function(t,e){return Math.max(t,e)}),this.AddFloatBinaryOp(this.Min,function(t,e){return Math.min(t,e)}),this.AddFloatBinaryOp(this.Pow,function(t,e){return Math.pow(t,e)}),this.AddFloatUnaryOp(this.Floor,function(t){return Math.floor(t)}),this.AddFloatUnaryOp(this.Ceiling,function(t){return Math.ceil(t)}),this.AddFloatUnaryOp(this.Int,function(t){return Math.floor(t)}),this.AddFloatUnaryOp(this.Float,f.Identity),this.AddStringBinaryOp(this.Add,function(t,e){return t+e}),this.AddStringBinaryOp(this.Equal,function(t,e){return t===e}),this.AddStringBinaryOp(this.NotEquals,function(t,e){return!(t===e)}),this.AddStringBinaryOp(this.Has,function(t,e){return t.includes(e)}),this.AddStringBinaryOp(this.Hasnt,function(t,e){return!t.includes(e)}),this.AddListBinaryOp(this.Add,function(t,e){return t.Union(e)}),this.AddListBinaryOp(this.Subtract,function(t,e){return t.Without(e)}),this.AddListBinaryOp(this.Has,function(t,e){return t.Contains(e)}),this.AddListBinaryOp(this.Hasnt,function(t,e){return!t.Contains(e)}),this.AddListBinaryOp(this.Intersect,function(t,e){return t.Intersect(e)}),this.AddListBinaryOp(this.Equal,function(t,e){return t.Equals(e)}),this.AddListBinaryOp(this.Greater,function(t,e){return t.GreaterThan(e)}),this.AddListBinaryOp(this.Less,function(t,e){return t.LessThan(e)}),this.AddListBinaryOp(this.GreaterThanOrEquals,function(t,e){return t.GreaterThanOrEquals(e)}),this.AddListBinaryOp(this.LessThanOrEquals,function(t,e){return t.LessThanOrEquals(e)}),this.AddListBinaryOp(this.NotEquals,function(t,e){return!t.Equals(e)}),this.AddListBinaryOp(this.And,function(t,e){return 0<t.Count&&0<e.Count}),this.AddListBinaryOp(this.Or,function(t,e){return 0<t.Count||0<e.Count}),this.AddListUnaryOp(this.Not,function(t){return 0==t.Count?1:0}),this.AddListUnaryOp(this.Invert,function(t){return t.inverse}),this.AddListUnaryOp(this.All,function(t){return t.all}),this.AddListUnaryOp(this.ListMin,function(t){return t.MinAsList()}),this.AddListUnaryOp(this.ListMax,function(t){return t.MaxAsList()}),this.AddListUnaryOp(this.Count,function(t){return t.Count}),this.AddListUnaryOp(this.ValueOfList,function(t){return t.maxItem.Value}),this.AddOpToNativeFunc(this.Equal,2,N.DivertTarget,function(t,e){return t.Equals(e)}),this.AddOpToNativeFunc(this.NotEquals,2,N.DivertTarget,function(t,e){return!t.Equals(e)}))}},{key:"AddOpToNativeFunc",value:function(t,e,n,i){if(null===this._nativeFunctions)return gt("NativeFunctionCall._nativeFunctions");var r=this._nativeFunctions.get(t);r||(r=new f(t,e),this._nativeFunctions.set(t,r)),r.AddOpFuncForType(n,i)}},{key:"AddIntBinaryOp",value:function(t,e){this.AddOpToNativeFunc(t,2,N.Int,e)}},{key:"AddIntUnaryOp",value:function(t,e){this.AddOpToNativeFunc(t,1,N.Int,e)}},{key:"AddFloatBinaryOp",value:function(t,e){this.AddOpToNativeFunc(t,2,N.Float,e)}},{key:"AddFloatUnaryOp",value:function(t,e){this.AddOpToNativeFunc(t,1,N.Float,e)}},{key:"AddStringBinaryOp",value:function(t,e){this.AddOpToNativeFunc(t,2,N.String,e)}},{key:"AddListBinaryOp",value:function(t,e){this.AddOpToNativeFunc(t,2,N.List,e)}},{key:"AddListUnaryOp",value:function(t,e){this.AddOpToNativeFunc(t,1,N.List,e)}}]),f}();Lt.Add="+",Lt.Subtract="-",Lt.Divide="/",Lt.Multiply="*",Lt.Mod="%",Lt.Negate="_",Lt.Equal="==",Lt.Greater=">",Lt.Less="<",Lt.GreaterThanOrEquals=">=",Lt.LessThanOrEquals="<=",Lt.NotEquals="!=",Lt.Not="!",Lt.And="&&",Lt.Or="||",Lt.Min="MIN",Lt.Max="MAX",Lt.Pow="POW",Lt.Floor="FLOOR",Lt.Ceiling="CEILING",Lt.Int="INT",Lt.Float="FLOAT",Lt.Has="?",Lt.Hasnt="!?",Lt.Intersect="^",Lt.ListMin="LIST_MIN",Lt.ListMax="LIST_MAX",Lt.All="LIST_ALL",Lt.Count="LIST_COUNT",Lt.ValueOfList="LIST_VALUE",Lt.Invert="LIST_INVERT",Lt._nativeFunctions=null;var J=function(){s(i,T);var n=v(i);function i(t){var e;return m(this,i),(e=n.call(this)).text=t.toString()||"",e}return u(i,[{key:"toString",value:function(){return"# "+this.text}}]),i}(),U=function(){s(n,T);var e=v(n);function n(){var t;return m(this,n),(t=e.apply(this,arguments)).text="",t.index=0,t.threadAtGeneration=null,t.sourcePath="",t.targetPath=null,t.isInvisibleDefault=!1,t.originalThreadIndex=0,t}return u(n,[{key:"pathStringOnChoice",get:function(){return null===this.targetPath?gt("Choice.targetPath"):this.targetPath.toString()},set:function(t){this.targetPath=new O(t)}}]),n}(),q=function(){function n(t,e){m(this,n),this._name=t||"",this._items=null,this._itemNameToValues=e||new Map}return u(n,[{key:"name",get:function(){return this._name}},{key:"items",get:function(){if(null==this._items){this._items=new Map;var t,e=pt(this._itemNameToValues);try{for(e.s();!(t=e.n()).done;){var n=S(t.value,2),i=n[0],r=n[1],a=new kt(this.name,i);this._items.set(a.serialized(),r)}}catch(t){e.e(t)}finally{e.f()}}return this._items}},{key:"ValueForItem",value:function(t){if(!t.itemName)return 0;var e=this._itemNameToValues.get(t.itemName);return void 0!==e?e:0}},{key:"ContainsItem",value:function(t){return!!t.itemName&&(t.originName==this.name&&this._itemNameToValues.has(t.itemName))}},{key:"ContainsItemWithName",value:function(t){return this._itemNameToValues.has(t)}},{key:"TryGetItemWithValue",value:function(t){var e,n=pt(this._itemNameToValues);try{for(n.s();!(e=n.n()).done;){var i=S(e.value,2),r=i[0];if(i[1]==t)return{result:new kt(this.name,r),exists:!0}}}catch(t){n.e(t)}finally{n.f()}return{result:kt.Null,exists:!1}}},{key:"TryGetValueForItem",value:function(t){if(!t.itemName)return{result:0,exists:!1};var e=this._itemNameToValues.get(t.itemName);return e?{result:e,exists:!0}:{result:0,exists:!1}}}]),n}(),K=function(){function c(t){m(this,c),this._lists=new Map,this._allUnambiguousListValueCache=new Map;var e,n=pt(t);try{for(n.s();!(e=n.n()).done;){var i=e.value;this._lists.set(i.name,i);var r,a=pt(i.items);try{for(a.s();!(r=a.n()).done;){var s=S(r.value,2),o=s[0],u=s[1],l=kt.fromSerializedKey(o),h=new Pt(l,u);if(!l.itemName)throw new Error("item.itemName is null or undefined.");this._allUnambiguousListValueCache.set(l.itemName,h),this._allUnambiguousListValueCache.set(l.fullName,h)}}catch(t){a.e(t)}finally{a.f()}}}catch(t){n.e(t)}finally{n.f()}}return u(c,[{key:"lists",get:function(){var t,e=[],n=pt(this._lists);try{for(n.s();!(t=n.n()).done;){var i=S(t.value,2)[1];e.push(i)}}catch(t){n.e(t)}finally{n.f()}return e}},{key:"TryListGetDefinition",value:function(t,e){if(null===t)return{result:e,exists:!1};var n=this._lists.get(t);return n?{result:n,exists:!0}:{result:e,exists:!1}}},{key:"FindSingleItemListWithName",value:function(t){if(null===t)return gt("name");var e=this._allUnambiguousListValueCache.get(t);return void 0!==e?e:null}}]),c}(),z=function(){function E(){m(this,E)}return u(E,null,[{key:"JArrayToRuntimeObjList",value:function(t,e){var n=1<arguments.length&&void 0!==e&&e,i=t.length;n&&i--;for(var r=[],a=0;a<i;a++){var s=t[a],o=this.JTokenToRuntimeObject(s);if(null===o)return gt("runtimeObj");r.push(o)}return r}},{key:"WriteDictionaryRuntimeObjs",value:function(t,e){t.WriteObjectStart();var n,i=pt(e);try{for(i.s();!(n=i.n()).done;){var r=S(n.value,2),a=r[0],s=r[1];t.WritePropertyStart(a),this.WriteRuntimeObject(t,s),t.WritePropertyEnd()}}catch(t){i.e(t)}finally{i.f()}t.WriteObjectEnd()}},{key:"WriteListRuntimeObjs",value:function(t,e){t.WriteArrayStart();var n,i=pt(e);try{for(i.s();!(n=i.n()).done;){var r=n.value;this.WriteRuntimeObject(t,r)}}catch(t){i.e(t)}finally{i.f()}t.WriteArrayEnd()}},{key:"WriteIntDictionary",value:function(t,e){t.WriteObjectStart();var n,i=pt(e);try{for(i.s();!(n=i.n()).done;){var r=S(n.value,2),a=r[0],s=r[1];t.WriteIntProperty(a,s)}}catch(t){i.e(t)}finally{i.f()}t.WriteObjectEnd()}},{key:"WriteRuntimeObject",value:function(t,e){var n=yt(e,Ot);if(n)this.WriteRuntimeContainer(t,n);else{var i=yt(e,xt);if(i){var r,a="->";return i.isExternal?a="x()":i.pushesToStack&&(i.stackPushType==Nt.Function?a="f()":i.stackPushType==Nt.Tunnel&&(a="->t->")),r=i.hasVariableTarget?i.variableDivertName:i.targetPathString,t.WriteObjectStart(),t.WriteProperty(a,r),i.hasVariableTarget&&t.WriteProperty("var",!0),i.isConditional&&t.WriteProperty("c",!0),0<i.externalArgs&&t.WriteIntProperty("exArgs",i.externalArgs),void t.WriteObjectEnd()}var s=yt(e,M);if(s)return t.WriteObjectStart(),t.WriteProperty("*",s.pathStringOnChoice),t.WriteIntProperty("flg",s.flags),void t.WriteObjectEnd();var o=yt(e,x);if(o)t.WriteBool(o.value);else{var u=yt(e,wt);if(u)t.WriteInt(u.value);else{var l=yt(e,F);if(l)t.WriteFloat(l.value);else{var h=yt(e,Tt);if(h)h.isNewline?t.Write("\n",!1):(t.WriteStringStart(),t.WriteStringInner("^"),t.WriteStringInner(h.value),t.WriteStringEnd());else{var c=yt(e,Pt);if(c)this.WriteInkList(t,c);else{var f=yt(e,Et);if(f)return t.WriteObjectStart(),null===f.value?gt("divTargetVal.value"):(t.WriteProperty("^->",f.value.componentsString),void t.WriteObjectEnd());var v=yt(e,W);if(v)return t.WriteObjectStart(),t.WriteProperty("^var",v.value),t.WriteIntProperty("ci",v.contextIndex),void t.WriteObjectEnd();if(yt(e,G))t.Write("<>");else{var d=yt(e,At);if(d)t.Write(E._controlCommandNames[d.commandType]);else{var p=yt(e,Lt);if(p){var y=p.name;return"^"==y&&(y="L^"),void t.Write(y)}var m=yt(e,Ft);if(m){t.WriteObjectStart();var g=m.pathStringForCount;return null!=g?t.WriteProperty("CNT?",g):t.WriteProperty("VAR?",m.name),void t.WriteObjectEnd()}var S=yt(e,Wt);if(S){t.WriteObjectStart();var k=S.isGlobal?"VAR=":"temp=";return t.WriteProperty(k,S.variableName),S.isNewDeclaration||t.WriteProperty("re",!0),void t.WriteObjectEnd()}if(yt(e,Vt))t.Write("void");else{var C=yt(e,J);if(C)return t.WriteObjectStart(),t.WriteProperty("#",C.text),void t.WriteObjectEnd();var b=yt(e,U);if(!b)throw new Error("Failed to convert runtime object to Json token: "+e);this.WriteChoice(t,b)}}}}}}}}}}},{key:"JObjectToDictionaryRuntimeObjs",value:function(t){var e=new Map;for(var n in t)if(t.hasOwnProperty(n)){var i=this.JTokenToRuntimeObject(t[n]);if(null===i)return gt("inkObject");e.set(n,i)}return e}},{key:"JObjectToIntDictionary",value:function(t){var e=new Map;for(var n in t)t.hasOwnProperty(n)&&e.set(n,parseInt(t[n]));return e}},{key:"JTokenToRuntimeObject",value:function(t){if("number"==typeof t&&!isNaN(t)||"boolean"==typeof t)return _t.Create(t);if("string"==typeof t){var e=t.toString(),n=e[0];if("^"==n)return new Tt(e.substring(1));if("\n"==n&&1==e.length)return new Tt("\n");if("<>"==e)return new G;for(var i=0;i<E._controlCommandNames.length;++i){if(e==E._controlCommandNames[i])return new At(i)}if("L^"==e&&(e="^"),Lt.CallExistsWithName(e))return Lt.CallWithName(e);if("->->"==e)return At.PopTunnel();if("~ret"==e)return At.PopFunction();if("void"==e)return new Vt}if("object"===P(t)&&!Array.isArray(t)){var r,a=t;if(a["^->"])return r=a["^->"],new Et(new O(r.toString()));if(a["^var"]){r=a["^var"];var s=new W(r.toString());return"ci"in a&&(r=a.ci,s.contextIndex=parseInt(r)),s}var o=!1,u=!1,l=Nt.Function,h=!1;if((r=a["->"])?o=!0:(r=a["f()"])?(u=o=!0,l=Nt.Function):(r=a["->t->"])?(u=o=!0,l=Nt.Tunnel):(r=a["x()"])&&(u=!(h=o=!0),l=Nt.Function),o){var c=new xt;c.pushesToStack=u,c.stackPushType=l,c.isExternal=h;var f=r.toString();return(r=a.var)?c.variableDivertName=f:c.targetPathString=f,c.isConditional=!!a.c,h&&(r=a.exArgs)&&(c.externalArgs=parseInt(r)),c}if(r=a["*"]){var v=new M;return v.pathStringOnChoice=r.toString(),(r=a.flg)&&(v.flags=parseInt(r)),v}if(r=a["VAR?"])return new Ft(r.toString());if(r=a["CNT?"]){var d=new Ft;return d.pathStringForCount=r.toString(),d}var p=!1,y=!1;if((r=a["VAR="])?y=p=!0:(r=a["temp="])&&(y=!(p=!0)),p){var m=r.toString(),g=!a.re,S=new Wt(m,g);return S.isGlobal=y,S}if(void 0!==a["#"])return r=a["#"],new J(r.toString());if(r=a.list){var k,C,b,_=r,w=new Ct;for(var T in(r=a.origins)&&w.SetInitialOriginNames(r),_){_.hasOwnProperty(T)&&(k=_[T],C=new kt(T),b=parseInt(k),w.Add(C,b))}return new Pt(w)}if(null!=a.originalChoicePath)return this.JObjectToChoice(a)}if(Array.isArray(t))return this.JArrayToContainer(t);if(null==t)return null;throw new Error("Failed to convert token to runtime object: "+JSON.stringify(t))}},{key:"WriteRuntimeContainer",value:function(t,e,n){var i=2<arguments.length&&void 0!==n&&n;if(t.WriteArrayStart(),null===e)return gt("container");var r,a=pt(e.content);try{for(a.s();!(r=a.n()).done;){var s=r.value;this.WriteRuntimeObject(t,s)}}catch(t){a.e(t)}finally{a.f()}var o=e.namedOnlyContent,u=e.countFlags,l=null!=e.name&&!i,h=null!=o||0<u||l;if(h&&t.WriteObjectStart(),null!=o){var c,f=pt(o);try{for(f.s();!(c=f.n()).done;){var v=S(c.value,2),d=v[0],p=yt(v[1],Ot);t.WritePropertyStart(d),this.WriteRuntimeContainer(t,p,!0),t.WritePropertyEnd()}}catch(t){f.e(t)}finally{f.f()}}l&&t.WriteProperty("#n",e.name),h?t.WriteObjectEnd():t.WriteNull(),t.WriteArrayEnd()}},{key:"JArrayToContainer",value:function(t){var e=new Ot;e.content=this.JArrayToRuntimeObjList(t,!0);var n=t[t.length-1];if(null!=n){var i,r,a=new Map;for(var s in n){"#f"==s?e.countFlags=parseInt(n[s]):"#n"==s?e.name=n[s].toString():((r=yt(i=this.JTokenToRuntimeObject(n[s]),Ot))&&(r.name=s),a.set(s,i))}e.namedOnlyContent=a}return e}},{key:"JObjectToChoice",value:function(t){var e=new U;return e.text=t.text.toString(),e.index=parseInt(t.index),e.sourcePath=t.originalChoicePath.toString(),e.originalThreadIndex=parseInt(t.originalThreadIndex),e.pathStringOnChoice=t.targetPath.toString(),e}},{key:"WriteChoice",value:function(t,e){t.WriteObjectStart(),t.WriteProperty("text",e.text),t.WriteIntProperty("index",e.index),t.WriteProperty("originalChoicePath",e.sourcePath),t.WriteIntProperty("originalThreadIndex",e.originalThreadIndex),t.WriteProperty("targetPath",e.pathStringOnChoice),t.WriteObjectEnd()}},{key:"WriteInkList",value:function(t,e){var n=e.value;if(null===n)return gt("rawList");t.WriteObjectStart(),t.WritePropertyStart("list"),t.WriteObjectStart();var i,r=pt(n);try{for(r.s();!(i=r.n()).done;){var a=S(i.value,2),s=a[0],o=a[1],u=kt.fromSerializedKey(s),l=o;if(null===u.itemName)return gt("item.itemName");t.WritePropertyNameStart(),t.WritePropertyNameInner(u.originName?u.originName:"?"),t.WritePropertyNameInner("."),t.WritePropertyNameInner(u.itemName),t.WritePropertyNameEnd(),t.Write(l),t.WritePropertyEnd()}}catch(t){r.e(t)}finally{r.f()}if(t.WriteObjectEnd(),t.WritePropertyEnd(),0==n.Count&&null!=n.originNames&&0<n.originNames.length){t.WritePropertyStart("origins"),t.WriteArrayStart();var h,c=pt(n.originNames);try{for(c.s();!(h=c.n()).done;){var f=h.value;t.Write(f)}}catch(t){c.e(t)}finally{c.f()}t.WriteArrayEnd(),t.WritePropertyEnd()}t.WriteObjectEnd()}},{key:"ListDefinitionsToJToken",value:function(t){var e,n={},i=pt(t.lists);try{for(i.s();!(e=i.n()).done;){var r,a=e.value,s={},o=pt(a.items);try{for(o.s();!(r=o.n()).done;){var u=S(r.value,2),l=u[0],h=u[1],c=kt.fromSerializedKey(l);if(null===c.itemName)return gt("item.itemName");s[c.itemName]=h}}catch(t){o.e(t)}finally{o.f()}n[a.name]=s}}catch(t){i.e(t)}finally{i.f()}return n}},{key:"JTokenToListDefinitions",value:function(t){var e=t,n=[];for(var i in e)if(e.hasOwnProperty(i)){var r,a=i.toString(),s=e[i],o=new Map;for(var u in s){e.hasOwnProperty(i)&&(r=s[u],o.set(u,parseInt(r)))}var l=new q(a,o);n.push(l)}return new K(n)}}]),E}();z._controlCommandNames=function(){var t=[];t[At.CommandType.EvalStart]="ev",t[At.CommandType.EvalOutput]="out",t[At.CommandType.EvalEnd]="/ev",t[At.CommandType.Duplicate]="du",t[At.CommandType.PopEvaluatedValue]="pop",t[At.CommandType.PopFunction]="~ret",t[At.CommandType.PopTunnel]="->->",t[At.CommandType.BeginString]="str",t[At.CommandType.EndString]="/str",t[At.CommandType.NoOp]="nop",t[At.CommandType.ChoiceCount]="choiceCnt",t[At.CommandType.Turns]="turn",t[At.CommandType.TurnsSince]="turns",t[At.CommandType.ReadCount]="readc",t[At.CommandType.Random]="rnd",t[At.CommandType.SeedRandom]="srnd",t[At.CommandType.VisitIndex]="visit",t[At.CommandType.SequenceShuffleIndex]="seq",t[At.CommandType.StartThread]="thread",t[At.CommandType.Done]="done",t[At.CommandType.End]="end",t[At.CommandType.ListFromInt]="listInt",t[At.CommandType.ListRange]="range",t[At.CommandType.ListRandom]="lrnd";for(var e=0;e<At.CommandType.TOTAL_VALUES;++e)if(null==t[e])throw new Error("Control command not accounted for in serialisation");return t}();var H=function(){function s(){if(m(this,s),this._threadCounter=0,this._startOfRoot=It.Null,arguments[0]instanceof a.Story){var t=arguments[0];this._startOfRoot=It.StartOf(t.rootContentContainer),this.Reset()}else{var e=arguments[0];this._threads=[];var n,i=pt(e._threads);try{for(i.s();!(n=i.n()).done;){var r=n.value;this._threads.push(r.Copy())}}catch(t){i.e(t)}finally{i.f()}this._threadCounter=e._threadCounter,this._startOfRoot=e._startOfRoot.copy()}}return u(s,[{key:"elements",get:function(){return this.callStack}},{key:"depth",get:function(){return this.elements.length}},{key:"currentElement",get:function(){var t=this._threads[this._threads.length-1].callstack;return t[t.length-1]}},{key:"currentElementIndex",get:function(){return this.callStack.length-1}},{key:"currentThread",get:function(){return this._threads[this._threads.length-1]},set:function(t){k.Assert(1==this._threads.length,"Shouldn't be directly setting the current thread when we have a stack of them"),this._threads.length=0,this._threads.push(t)}},{key:"canPop",get:function(){return 1<this.callStack.length}},{key:"Reset",value:function(){this._threads=[],this._threads.push(new s.Thread),this._threads[0].callstack.push(new s.Element(Nt.Tunnel,this._startOfRoot))}},{key:"SetJsonToken",value:function(t,e){this._threads.length=0;var n,i=pt(t.threads);try{for(i.s();!(n=i.n()).done;){var r=n.value,a=new s.Thread(r,e);this._threads.push(a)}}catch(t){i.e(t)}finally{i.f()}this._threadCounter=parseInt(t.threadCounter),this._startOfRoot=It.StartOf(e.rootContentContainer)}},{key:"WriteJson",value:function(t){var i=this;t.WriteObject(function(t){t.WritePropertyStart("threads"),t.WriteArrayStart();var e,n=pt(i._threads);try{for(n.s();!(e=n.n()).done;){e.value.WriteJson(t)}}catch(t){n.e(t)}finally{n.f()}t.WriteArrayEnd(),t.WritePropertyEnd(),t.WritePropertyStart("threadCounter"),t.WriteInt(i._threadCounter),t.WritePropertyEnd()})}},{key:"PushThread",value:function(){var t=this.currentThread.Copy();this._threadCounter++,t.threadIndex=this._threadCounter,this._threads.push(t)}},{key:"ForkThread",value:function(){var t=this.currentThread.Copy();return this._threadCounter++,t.threadIndex=this._threadCounter,t}},{key:"PopThread",value:function(){if(!this.canPopThread)throw new Error("Can't pop thread");this._threads.splice(this._threads.indexOf(this.currentThread),1)}},{key:"canPopThread",get:function(){return 1<this._threads.length&&!this.elementIsEvaluateFromGame}},{key:"elementIsEvaluateFromGame",get:function(){return this.currentElement.type==Nt.FunctionEvaluationFromGame}},{key:"Push",value:function(t,e,n){var i=1<arguments.length&&void 0!==e?e:0,r=2<arguments.length&&void 0!==n?n:0,a=new s.Element(t,this.currentElement.currentPointer,!1);a.evaluationStackHeightWhenPushed=i,a.functionStartInOutputStream=r,this.callStack.push(a)}},{key:"CanPop",value:function(t){var e=0<arguments.length&&void 0!==t?t:null;return!!this.canPop&&(null==e||this.currentElement.type==e)}},{key:"Pop",value:function(t){var e=0<arguments.length&&void 0!==t?t:null;if(!this.CanPop(e))throw new Error("Mismatched push/pop in Callstack");this.callStack.pop()}},{key:"GetTemporaryVariableWithName",value:function(t,e){var n=1<arguments.length&&void 0!==e?e:-1;-1==n&&(n=this.currentElementIndex+1);var i=E(this.callStack[n-1].temporaryVariables,t,null);return i.exists?i.result:null}},{key:"SetTemporaryVariable",value:function(t,e,n,i){var r=3<arguments.length&&void 0!==i?i:-1;-1==r&&(r=this.currentElementIndex+1);var a=this.callStack[r-1];if(!n&&!a.temporaryVariables.get(t))throw new Error("Could not find temporary variable to set: "+t);var s=E(a.temporaryVariables,t,null);s.exists&&Pt.RetainListOriginsForAssignment(s.result,e),a.temporaryVariables.set(t,e)}},{key:"ContextForVariableNamed",value:function(t){return this.currentElement.temporaryVariables.get(t)?this.currentElementIndex+1:0}},{key:"ThreadWithIndex",value:function(e){var t=this._threads.filter(function(t){if(t.threadIndex==e)return t});return 0<t.length?t[0]:null}},{key:"callStack",get:function(){return this.currentThread.callstack}},{key:"callStackTrace",get:function(){for(var t=new St,e=0;e<this._threads.length;e++){var n=this._threads[e],i=e==this._threads.length-1;t.AppendFormat("=== THREAD {0}/{1} {2}===\n",e+1,this._threads.length,i?"(current) ":"");for(var r=0;r<n.callstack.length;r++){n.callstack[r].type==Nt.Function?t.Append("  [FUNCTION] "):t.Append("  [TUNNEL] ");var a=n.callstack[r].currentPointer;if(!a.isNull){if(t.Append("<SOMEWHERE IN "),null===a.container)return gt("pointer.container");t.Append(a.container.path.toString()),t.AppendLine(">")}}}return t.toString()}}]),s}();!function(t){var y=function(){function i(t,e){var n=2<arguments.length&&void 0!==arguments[2]&&arguments[2];m(this,i),this.evaluationStackHeightWhenPushed=0,this.functionStartInOutputStream=0,this.currentPointer=e.copy(),this.inExpressionEvaluation=n,this.temporaryVariables=new Map,this.type=t}return u(i,[{key:"Copy",value:function(){var t=new i(this.type,this.currentPointer,this.inExpressionEvaluation);return t.temporaryVariables=new Map(this.temporaryVariables),t.evaluationStackHeightWhenPushed=this.evaluationStackHeightWhenPushed,t.functionStartInOutputStream=this.functionStartInOutputStream,t}}]),i}();t.Element=y;var e=function(){function p(){if(m(this,p),this.threadIndex=0,this.previousPointer=It.Null,this.callstack=[],arguments[0]&&arguments[1]){var t=arguments[0],e=arguments[1];this.threadIndex=parseInt(t.threadIndex);var n,i=pt(t.callstack);try{for(i.s();!(n=i.n()).done;){var r=n.value,a=parseInt(r.type),s=It.Null,o=void 0,u=r.cPath;if(void 0!==u){o=u.toString();var l=e.ContentAtPath(new O(o));if(s.container=l.container,s.index=parseInt(r.idx),null==l.obj)throw new Error("When loading state, internal story location couldn't be found: "+o+". Has the story changed since this save data was created?");if(l.approximate){if(null===s.container)return gt("pointer.container");e.Warning("When loading state, exact internal story location couldn't be found: '"+o+"', so it was approximated to '"+s.container.path.toString()+"' to recover. Has the story changed since this save data was created?")}}var h=!!r.exp,c=new y(a,s,h),f=r.temp;void 0!==f?c.temporaryVariables=z.JObjectToDictionaryRuntimeObjs(f):c.temporaryVariables.clear(),this.callstack.push(c)}}catch(t){i.e(t)}finally{i.f()}var v,d=t.previousContentObject;void 0!==d&&(v=new O(d.toString()),this.previousPointer=e.PointerAtPath(v))}}return u(p,[{key:"Copy",value:function(){var t=new p;t.threadIndex=this.threadIndex;var e,n=pt(this.callstack);try{for(n.s();!(e=n.n()).done;){var i=e.value;t.callstack.push(i.Copy())}}catch(t){n.e(t)}finally{n.f()}return t.previousPointer=this.previousPointer.copy(),t}},{key:"WriteJson",value:function(t){t.WriteObjectStart(),t.WritePropertyStart("callstack"),t.WriteArrayStart();var e,n=pt(this.callstack);try{for(n.s();!(e=n.n()).done;){var i=e.value;if(t.WriteObjectStart(),!i.currentPointer.isNull){if(null===i.currentPointer.container)return gt("el.currentPointer.container");t.WriteProperty("cPath",i.currentPointer.container.path.componentsString),t.WriteIntProperty("idx",i.currentPointer.index)}t.WriteProperty("exp",i.inExpressionEvaluation),t.WriteIntProperty("type",i.type),0<i.temporaryVariables.size&&(t.WritePropertyStart("temp"),z.WriteDictionaryRuntimeObjs(t,i.temporaryVariables),t.WritePropertyEnd()),t.WriteObjectEnd()}}catch(t){n.e(t)}finally{n.f()}if(t.WriteArrayEnd(),t.WritePropertyEnd(),t.WriteIntProperty("threadIndex",this.threadIndex),!this.previousPointer.isNull){var r=this.previousPointer.Resolve();if(null===r)return gt("this.previousPointer.Resolve()");t.WriteProperty("previousContentObject",r.path.toString())}t.WriteObjectEnd()}}]),p}();t.Thread=e}(H=H||{});var X=function(){function l(t,e){m(this,l),this.variableChangedEventCallbacks=[],this.patch=null,this._batchObservingVariableChanges=!1,this._defaultGlobalVariables=new Map,this._changedVariablesForBatchObs=new Set,this._globalVariables=new Map,this._callStack=t,this._listDefsOrigin=e;try{return new Proxy(this,{get:function(t,e){return e in t?t[e]:t.$(e)},set:function(t,e,n){return e in t?t[e]=n:t.$(e,n),!0}})}catch(t){}}return u(l,[{key:"variableChangedEvent",value:function(t,e){var n,i=pt(this.variableChangedEventCallbacks);try{for(i.s();!(n=i.n()).done;){(0,n.value)(t,e)}}catch(t){i.e(t)}finally{i.f()}}},{key:"batchObservingVariableChanges",get:function(){return this._batchObservingVariableChanges},set:function(t){if(this._batchObservingVariableChanges=t)this._changedVariablesForBatchObs=new Set;else if(null!=this._changedVariablesForBatchObs){var e,n=pt(this._changedVariablesForBatchObs);try{for(n.s();!(e=n.n()).done;){var i=e.value,r=this._globalVariables.get(i);r?this.variableChangedEvent(i,r):gt("currentValue")}}catch(t){n.e(t)}finally{n.f()}this._changedVariablesForBatchObs=null}}},{key:"callStack",get:function(){return this._callStack},set:function(t){this._callStack=t}},{key:"$",value:function(t,e){if(void 0===e){var n=null;return null!==this.patch&&(n=this.patch.TryGetGlobal(t,null)).exists?n.result.valueObject:(void 0===(n=this._globalVariables.get(t))&&(n=this._defaultGlobalVariables.get(t)),void 0!==n?n.valueObject:null)}if(void 0===this._defaultGlobalVariables.get(t))throw new bt("Cannot assign to a variable ("+t+") that hasn't been declared in the story");var i=_t.Create(e);if(null==i)throw null==e?new Error("Cannot pass null to VariableState"):new Error("Invalid value passed to VariableState: "+e.toString());this.SetGlobal(t,i)}},{key:"ApplyPatch",value:function(){if(null===this.patch)return gt("this.patch");var t,e=pt(this.patch.globals);try{for(e.s();!(t=e.n()).done;){var n=S(t.value,2),i=n[0],r=n[1];this._globalVariables.set(i,r)}}catch(t){e.e(t)}finally{e.f()}if(null!==this._changedVariablesForBatchObs){var a,s=pt(this.patch.changedVariables);try{for(s.s();!(a=s.n()).done;){var o=a.value;this._changedVariablesForBatchObs.add(o)}}catch(t){s.e(t)}finally{s.f()}}this.patch=null}},{key:"SetJsonToken",value:function(t){this._globalVariables.clear();var e,n=pt(this._defaultGlobalVariables);try{for(n.s();!(e=n.n()).done;){var i=S(e.value,2),r=i[0],a=i[1],s=t[r];if(void 0!==s){var o=z.JTokenToRuntimeObject(s);if(null===o)return gt("tokenInkObject");this._globalVariables.set(r,o)}else this._globalVariables.set(r,a)}}catch(t){n.e(t)}finally{n.f()}}},{key:"WriteJson",value:function(t){t.WriteObjectStart();var e,n=pt(this._globalVariables);try{for(n.s();!(e=n.n()).done;){var i=S(e.value,2),r=i[0],a=i[1],s=r,o=a;if(l.dontSaveDefaultValues&&this._defaultGlobalVariables.has(s)){var u=this._defaultGlobalVariables.get(s);if(this.RuntimeObjectsEqual(o,u))continue}t.WritePropertyStart(s),z.WriteRuntimeObject(t,o),t.WritePropertyEnd()}}catch(t){n.e(t)}finally{n.f()}t.WriteObjectEnd()}},{key:"RuntimeObjectsEqual",value:function(t,e){if(null===t)return gt("obj1");if(null===e)return gt("obj2");if(t.constructor!==e.constructor)return!1;var n=yt(t,x);if(null!==n)return n.value===mt(e,x).value;var i=yt(t,wt);if(null!==i)return i.value===mt(e,wt).value;var r=yt(t,F);if(null!==r)return r.value===mt(e,F).value;var a=yt(t,_t),s=yt(e,_t);if(null!==a&&null!==s)return _(a.valueObject)&&_(s.valueObject)?a.valueObject.Equals(s.valueObject):a.valueObject===s.valueObject;throw new Error("FastRoughDefinitelyEquals: Unsupported runtime object type: "+t.constructor.name)}},{key:"GetVariableWithName",value:function(t,e){var n=1<arguments.length&&void 0!==e?e:-1,i=this.GetRawVariableWithName(t,n),r=yt(i,W);return null!==r&&(i=this.ValueAtVariablePointer(r)),i}},{key:"TryGetDefaultVariableValue",value:function(t){var e=E(this._defaultGlobalVariables,t,null);return e.exists?e.result:null}},{key:"GlobalVariableExistsWithName",value:function(t){return this._globalVariables.has(t)||null!==this._defaultGlobalVariables&&this._defaultGlobalVariables.has(t)}},{key:"GetRawVariableWithName",value:function(t,e){if(0==e||-1==e){var n=null;if(null!==this.patch&&(n=this.patch.TryGetGlobal(t,null)).exists)return n.result;if((n=E(this._globalVariables,t,null)).exists)return n.result;if(null!==this._defaultGlobalVariables&&(n=E(this._defaultGlobalVariables,t,null)).exists)return n.result;if(null===this._listDefsOrigin)return gt("VariablesState._listDefsOrigin");var i=this._listDefsOrigin.FindSingleItemListWithName(t);if(i)return i}return this._callStack.GetTemporaryVariableWithName(t,e)}},{key:"ValueAtVariablePointer",value:function(t){return this.GetVariableWithName(t.variableName,t.contextIndex)}},{key:"Assign",value:function(t,e){var n=t.variableName;if(null===n)return gt("name");var i=-1,r=!1,r=t.isNewDeclaration?t.isGlobal:this.GlobalVariableExistsWithName(n);if(t.isNewDeclaration){var a=yt(e,W);null!==a&&(e=this.ResolveVariablePointer(a))}else for(var s=null;null!=(s=yt(this.GetRawVariableWithName(n,i),W))&&(n=s.variableName,r=0==(i=s.contextIndex)),null!=s;);r?this.SetGlobal(n,e):this._callStack.SetTemporaryVariable(n,e,t.isNewDeclaration,i)}},{key:"SnapshotDefaultGlobals",value:function(){this._defaultGlobalVariables=new Map(this._globalVariables)}},{key:"RetainListOriginsForAssignment",value:function(t,e){var n=mt(t,Pt),i=mt(e,Pt);n.value&&i.value&&0==i.value.Count&&i.value.SetInitialOriginNames(n.value.originNames)}},{key:"SetGlobal",value:function(t,e){var n=null;if(null===this.patch&&(n=E(this._globalVariables,t,null)),null!==this.patch&&((n=this.patch.TryGetGlobal(t,null)).exists||(n=E(this._globalVariables,t,null))),Pt.RetainListOriginsForAssignment(n.result,e),null===t)return gt("variableName");if(null!==this.patch?this.patch.SetGlobal(t,e):this._globalVariables.set(t,e),null!==this.variableChangedEvent&&null!==n&&e!==n.result)if(this.batchObservingVariableChanges){if(null===this._changedVariablesForBatchObs)return gt("this._changedVariablesForBatchObs");null!==this.patch?this.patch.AddChangedVariable(t):null!==this._changedVariablesForBatchObs&&this._changedVariablesForBatchObs.add(t)}else this.variableChangedEvent(t,e)}},{key:"ResolveVariablePointer",value:function(t){var e=t.contextIndex;-1==e&&(e=this.GetContextIndexOfVariableNamed(t.variableName));var n=yt(this.GetRawVariableWithName(t.variableName,e),W);return null!=n?n:new W(t.variableName,e)}},{key:"GetContextIndexOfVariableNamed",value:function(t){return this.GlobalVariableExistsWithName(t)?0:this._callStack.currentElementIndex}},{key:"ObserveVariableChange",value:function(t){this.variableChangedEventCallbacks.push(t)}}]),l}();X.dontSaveDefaultValues=!0;var Rt=function(){function e(t){m(this,e),this.seed=t%2147483647,this.seed<=0&&(this.seed+=2147483646)}return u(e,[{key:"next",value:function(){return this.seed=16807*this.seed%2147483647}},{key:"nextFloat",value:function(){return(this.next()-1)/2147483646}}]),e}(),$=function(){function e(){var t;m(this,e),this._changedVariables=new Set,this._visitCounts=new Map,this._turnIndices=new Map,1===arguments.length&&null!==arguments[0]?(t=arguments[0],this._globals=new Map(t._globals),this._changedVariables=new Set(t._changedVariables),this._visitCounts=new Map(t._visitCounts),this._turnIndices=new Map(t._turnIndices)):(this._globals=new Map,this._changedVariables=new Set,this._visitCounts=new Map,this._turnIndices=new Map)}return u(e,[{key:"globals",get:function(){return this._globals}},{key:"changedVariables",get:function(){return this._changedVariables}},{key:"visitCounts",get:function(){return this._visitCounts}},{key:"turnIndices",get:function(){return this._turnIndices}},{key:"TryGetGlobal",value:function(t,e){return null!==t&&this._globals.has(t)?{result:this._globals.get(t),exists:!0}:{result:e,exists:!1}}},{key:"SetGlobal",value:function(t,e){this._globals.set(t,e)}},{key:"AddChangedVariable",value:function(t){return this._changedVariables.add(t)}},{key:"TryGetVisitCount",value:function(t,e){return this._visitCounts.has(t)?{result:this._visitCounts.get(t),exists:!0}:{result:e,exists:!1}}},{key:"SetVisitCount",value:function(t,e){this._visitCounts.set(t,e)}},{key:"SetTurnIndex",value:function(t,e){this._turnIndices.set(t,e)}},{key:"TryGetTurnIndex",value:function(t,e){return this._turnIndices.has(t)?{result:this._turnIndices.get(t),exists:!0}:{result:e,exists:!1}}}]),e}(),Y=function(){function e(){m(this,e)}return u(e,null,[{key:"TextToDictionary",value:function(t){return new e.Reader(t).ToDictionary()}},{key:"TextToArray",value:function(t){return new e.Reader(t).ToArray()}}]),e}();!function(n){var t=function(){function e(t){m(this,e),this._rootObject=JSON.parse(t)}return u(e,[{key:"ToDictionary",value:function(){return this._rootObject}},{key:"ToArray",value:function(){return this._rootObject}}]),e}();n.Reader=t;var e=function(){function t(){m(this,t),this._currentPropertyName=null,this._currentString=null,this._stateStack=[],this._collectionStack=[],this._propertyNameStack=[],this._jsonObject=null}return u(t,[{key:"WriteObject",value:function(t){this.WriteObjectStart(),t(this),this.WriteObjectEnd()}},{key:"WriteObjectStart",value:function(){this.StartNewObject(!0);var t,e={};this.state===n.Writer.State.Property?(this.Assert(null!==this.currentCollection),this.Assert(null!==this.currentPropertyName),t=this._propertyNameStack.pop(),this.currentCollection[t]=e):this.state===n.Writer.State.Array?(this.Assert(null!==this.currentCollection),this.currentCollection.push(e)):(this.Assert(this.state===n.Writer.State.None),this._jsonObject=e),this._collectionStack.push(e),this._stateStack.push(new n.Writer.StateElement(n.Writer.State.Object))}},{key:"WriteObjectEnd",value:function(){this.Assert(this.state===n.Writer.State.Object),this._collectionStack.pop(),this._stateStack.pop()}},{key:"WriteProperty",value:function(t,e){this.WritePropertyStart(t),e instanceof Function?e(this):this.Write(e),this.WritePropertyEnd()}},{key:"WriteIntProperty",value:function(t,e){this.WritePropertyStart(t),this.WriteInt(e),this.WritePropertyEnd()}},{key:"WriteFloatProperty",value:function(t,e){this.WritePropertyStart(t),this.WriteFloat(e),this.WritePropertyEnd()}},{key:"WritePropertyStart",value:function(t){this.Assert(this.state===n.Writer.State.Object),this._propertyNameStack.push(t),this.IncrementChildCount(),this._stateStack.push(new n.Writer.StateElement(n.Writer.State.Property))}},{key:"WritePropertyEnd",value:function(){this.Assert(this.state===n.Writer.State.Property),this.Assert(1===this.childCount),this._stateStack.pop()}},{key:"WritePropertyNameStart",value:function(){this.Assert(this.state===n.Writer.State.Object),this.IncrementChildCount(),this._currentPropertyName="",this._stateStack.push(new n.Writer.StateElement(n.Writer.State.Property)),this._stateStack.push(new n.Writer.StateElement(n.Writer.State.PropertyName))}},{key:"WritePropertyNameEnd",value:function(){this.Assert(this.state===n.Writer.State.PropertyName),this.Assert(null!==this._currentPropertyName),this._propertyNameStack.push(this._currentPropertyName),this._currentPropertyName=null,this._stateStack.pop()}},{key:"WritePropertyNameInner",value:function(t){this.Assert(this.state===n.Writer.State.PropertyName),this.Assert(null!==this._currentPropertyName),this._currentPropertyName+=t}},{key:"WriteArrayStart",value:function(){this.StartNewObject(!0);var t,e=[];this.state===n.Writer.State.Property?(this.Assert(null!==this.currentCollection),this.Assert(null!==this.currentPropertyName),t=this._propertyNameStack.pop(),this.currentCollection[t]=e):this.state===n.Writer.State.Array?(this.Assert(null!==this.currentCollection),this.currentCollection.push(e)):(this.Assert(this.state===n.Writer.State.None),this._jsonObject=e),this._collectionStack.push(e),this._stateStack.push(new n.Writer.StateElement(n.Writer.State.Array))}},{key:"WriteArrayEnd",value:function(){this.Assert(this.state===n.Writer.State.Array),this._collectionStack.pop(),this._stateStack.pop()}},{key:"Write",value:function(t){null!==t?(this.StartNewObject(!1),this._addToCurrentObject(t)):console.error("Warning: trying to write a null string")}},{key:"WriteBool",value:function(t){null!==t&&(this.StartNewObject(!1),this._addToCurrentObject(t))}},{key:"WriteInt",value:function(t){null!==t&&(this.StartNewObject(!1),this._addToCurrentObject(Math.floor(t)))}},{key:"WriteFloat",value:function(t){null!==t&&(this.StartNewObject(!1),t==Number.POSITIVE_INFINITY?this._addToCurrentObject(34e37):t==Number.NEGATIVE_INFINITY?this._addToCurrentObject(-34e37):isNaN(t)?this._addToCurrentObject(0):this._addToCurrentObject(t))}},{key:"WriteNull",value:function(){this.StartNewObject(!1),this._addToCurrentObject(null)}},{key:"WriteStringStart",value:function(){this.StartNewObject(!1),this._currentString="",this._stateStack.push(new n.Writer.StateElement(n.Writer.State.String))}},{key:"WriteStringEnd",value:function(){this.Assert(this.state==n.Writer.State.String),this._stateStack.pop(),this._addToCurrentObject(this._currentString),this._currentString=null}},{key:"WriteStringInner",value:function(t){this.Assert(this.state===n.Writer.State.String),null!==t?this._currentString+=t:console.error("Warning: trying to write a null string")}},{key:"ToString",value:function(){return null===this._jsonObject?"":JSON.stringify(this._jsonObject)}},{key:"StartNewObject",value:function(t){t?this.Assert(this.state===n.Writer.State.None||this.state===n.Writer.State.Property||this.state===n.Writer.State.Array):this.Assert(this.state===n.Writer.State.Property||this.state===n.Writer.State.Array),this.state===n.Writer.State.Property&&this.Assert(0===this.childCount),this.state!==n.Writer.State.Array&&this.state!==n.Writer.State.Property||this.IncrementChildCount()}},{key:"state",get:function(){return 0<this._stateStack.length?this._stateStack[this._stateStack.length-1].type:n.Writer.State.None}},{key:"childCount",get:function(){return 0<this._stateStack.length?this._stateStack[this._stateStack.length-1].childCount:0}},{key:"currentCollection",get:function(){return 0<this._collectionStack.length?this._collectionStack[this._collectionStack.length-1]:null}},{key:"currentPropertyName",get:function(){return 0<this._propertyNameStack.length?this._propertyNameStack[this._propertyNameStack.length-1]:null}},{key:"IncrementChildCount",value:function(){this.Assert(0<this._stateStack.length);var t=this._stateStack.pop();t.childCount++,this._stateStack.push(t)}},{key:"Assert",value:function(t){if(!t)throw Error("Assert failed while writing JSON")}},{key:"_addToCurrentObject",value:function(t){this.Assert(null!==this.currentCollection),this.state===n.Writer.State.Array?(this.Assert(Array.isArray(this.currentCollection)),this.currentCollection.push(t)):this.state===n.Writer.State.Property&&(this.Assert(!Array.isArray(this.currentCollection)),this.Assert(null!==this.currentPropertyName),this.currentCollection[this.currentPropertyName]=t,this._propertyNameStack.pop())}}]),t}();n.Writer=e,function(t){var e;(e=t.State||(t.State={}))[e.None=0]="None",e[e.Object=1]="Object",e[e.Array=2]="Array",e[e.Property=3]="Property",e[e.PropertyName=4]="PropertyName",e[e.String=5]="String";t.StateElement=function t(e){m(this,t),this.type=n.Writer.State.None,this.childCount=0,this.type=e}}(e=n.Writer||(n.Writer={}))}(Y=Y||{});var Q,Z,tt,et,nt=function(){function r(){m(this,r);var t,e,n=arguments[0],i=arguments[1];this.name=n,this.callStack=new H(i),arguments[2]?(t=arguments[2],this.callStack.SetJsonToken(t.callstack,i),this.outputStream=z.JArrayToRuntimeObjList(t.outputStream),this.currentChoices=z.JArrayToRuntimeObjList(t.currentChoices),void 0!==(e=t.choiceThreads)&&this.LoadFlowChoiceThreads(e,i)):(this.outputStream=[],this.currentChoices=[])}return u(r,[{key:"WriteJson",value:function(t){var r=this;t.WriteObjectStart(),t.WriteProperty("callstack",function(t){return r.callStack.WriteJson(t)}),t.WriteProperty("outputStream",function(t){return z.WriteListRuntimeObjs(t,r.outputStream)});var e,n=!1,i=pt(this.currentChoices);try{for(i.s();!(e=i.n()).done;){var a=e.value;if(null===a.threadAtGeneration)return gt("c.threadAtGeneration");a.originalThreadIndex=a.threadAtGeneration.threadIndex,null===this.callStack.ThreadWithIndex(a.originalThreadIndex)&&(n||(n=!0,t.WritePropertyStart("choiceThreads"),t.WriteObjectStart()),t.WritePropertyStart(a.originalThreadIndex),a.threadAtGeneration.WriteJson(t),t.WritePropertyEnd())}}catch(t){i.e(t)}finally{i.f()}n&&(t.WriteObjectEnd(),t.WritePropertyEnd()),t.WriteProperty("currentChoices",function(t){t.WriteArrayStart();var e,n=pt(r.currentChoices);try{for(n.s();!(e=n.n()).done;){var i=e.value;z.WriteChoice(t,i)}}catch(t){n.e(t)}finally{n.f()}t.WriteArrayEnd()}),t.WriteObjectEnd()}},{key:"LoadFlowChoiceThreads",value:function(t,e){var n,i=pt(this.currentChoices);try{for(i.s();!(n=i.n()).done;){var r,a=n.value,s=this.callStack.ThreadWithIndex(a.originalThreadIndex);null!==s?a.threadAtGeneration=s.Copy():(r=t["".concat(a.originalThreadIndex)],a.threadAtGeneration=new H.Thread(r,e))}}catch(t){i.e(t)}finally{i.f()}}}]),r}(),it=function(){function c(t){m(this,c),this.kInkSaveStateVersion=9,this.kMinCompatibleLoadVersion=8,this.onDidLoadState=null,this._currentErrors=null,this._currentWarnings=null,this.divertedPointer=It.Null,this._currentTurnIndex=0,this.storySeed=0,this.previousRandom=0,this.didSafeExit=!1,this._currentText=null,this._currentTags=null,this._outputStreamTextDirty=!0,this._outputStreamTagsDirty=!0,this._patch=null,this._namedFlows=null,this.kDefaultFlowName="DEFAULT_FLOW",this.story=t,this._currentFlow=new nt(this.kDefaultFlowName,t),this.OutputStreamDirty(),this._evaluationStack=[],this._variablesState=new X(this.callStack,t.listDefinitions),this._visitCounts=new Map,this._turnIndices=new Map,this.currentTurnIndex=-1;var e=(new Date).getTime();this.storySeed=new Rt(e).next()%100,this.previousRandom=0,this.GoToStart()}return u(c,[{key:"ToJson",value:function(){var t=new Y.Writer;return this.WriteJson(t),t.ToString()}},{key:"toJson",value:function(t){var e=0<arguments.length&&void 0!==t&&t;return this.ToJson(e)}},{key:"LoadJson",value:function(t){var e=Y.TextToDictionary(t);this.LoadJsonObj(e),null!==this.onDidLoadState&&this.onDidLoadState()}},{key:"VisitCountAtPathString",value:function(t){var e;if(null!==this._patch){var n=this.story.ContentAtPath(new O(t)).container;if(null===n)throw new Error("Content at path not found: "+t);if((e=this._patch.TryGetVisitCount(n,0)).exists)return e.result}return(e=E(this._visitCounts,t,null)).exists?e.result:0}},{key:"VisitCountForContainer",value:function(t){if(null===t)return gt("container");if(!t.visitsShouldBeCounted)return this.story.Error("Read count for target ("+t.name+" - on "+t.debugMetadata+") unknown. The story may need to be compiled with countAllVisits flag (-c)."),0;if(null!==this._patch){var e=this._patch.TryGetVisitCount(t,0);if(e.exists)return e.result}var n=t.path.toString(),i=E(this._visitCounts,n,null);return i.exists?i.result:0}},{key:"IncrementVisitCountForContainer",value:function(t){if(null!==this._patch){var e=this.VisitCountForContainer(t);return e++,void this._patch.SetVisitCount(t,e)}var n=t.path.toString(),i=E(this._visitCounts,n,null);i.exists?this._visitCounts.set(n,i.result+1):this._visitCounts.set(n,1)}},{key:"RecordTurnIndexVisitToContainer",value:function(t){var e;null===this._patch?(e=t.path.toString(),this._turnIndices.set(e,this.currentTurnIndex)):this._patch.SetTurnIndex(t,this.currentTurnIndex)}},{key:"TurnsSinceForContainer",value:function(t){if(t.turnIndexShouldBeCounted||this.story.Error("TURNS_SINCE() for target ("+t.name+" - on "+t.debugMetadata+") unknown. The story may need to be compiled with countAllVisits flag (-c)."),null!==this._patch){var e=this._patch.TryGetTurnIndex(t,0);if(e.exists)return this.currentTurnIndex-e.result}var n=t.path.toString(),i=E(this._turnIndices,n,0);return i.exists?this.currentTurnIndex-i.result:-1}},{key:"callstackDepth",get:function(){return this.callStack.depth}},{key:"outputStream",get:function(){return this._currentFlow.outputStream}},{key:"currentChoices",get:function(){return this.canContinue?[]:this._currentFlow.currentChoices}},{key:"generatedChoices",get:function(){return this._currentFlow.currentChoices}},{key:"currentErrors",get:function(){return this._currentErrors}},{key:"currentWarnings",get:function(){return this._currentWarnings}},{key:"variablesState",get:function(){return this._variablesState},set:function(t){this._variablesState=t}},{key:"callStack",get:function(){return this._currentFlow.callStack}},{key:"evaluationStack",get:function(){return this._evaluationStack}},{key:"currentTurnIndex",get:function(){return this._currentTurnIndex},set:function(t){this._currentTurnIndex=t}},{key:"currentPathString",get:function(){var t=this.currentPointer;return t.isNull?null:null===t.path?gt("pointer.path"):t.path.toString()}},{key:"currentPointer",get:function(){return this.callStack.currentElement.currentPointer.copy()},set:function(t){this.callStack.currentElement.currentPointer=t.copy()}},{key:"previousPointer",get:function(){return this.callStack.currentThread.previousPointer.copy()},set:function(t){this.callStack.currentThread.previousPointer=t.copy()}},{key:"canContinue",get:function(){return!this.currentPointer.isNull&&!this.hasError}},{key:"hasError",get:function(){return null!=this.currentErrors&&0<this.currentErrors.length}},{key:"hasWarning",get:function(){return null!=this.currentWarnings&&0<this.currentWarnings.length}},{key:"currentText",get:function(){if(this._outputStreamTextDirty){var t,e=new St,n=pt(this.outputStream);try{for(n.s();!(t=n.n()).done;){var i=yt(t.value,Tt);null!==i&&e.Append(i.value)}}catch(t){n.e(t)}finally{n.f()}this._currentText=this.CleanOutputWhitespace(e.toString()),this._outputStreamTextDirty=!1}return this._currentText}},{key:"CleanOutputWhitespace",value:function(t){for(var e=new St,n=-1,i=0,r=0;r<t.length;r++){var a=t.charAt(r),s=" "==a||"\t"==a;s&&-1==n&&(n=r),s||("\n"!=a&&0<n&&n!=i&&e.Append(" "),n=-1),"\n"==a&&(i=r+1),s||e.Append(a)}return e.toString()}},{key:"currentTags",get:function(){if(this._outputStreamTagsDirty){this._currentTags=[];var t,e=pt(this.outputStream);try{for(e.s();!(t=e.n()).done;){var n=yt(t.value,J);null!==n&&this._currentTags.push(n.text)}}catch(t){e.e(t)}finally{e.f()}this._outputStreamTagsDirty=!1}return this._currentTags}},{key:"currentFlowName",get:function(){return this._currentFlow.name}},{key:"inExpressionEvaluation",get:function(){return this.callStack.currentElement.inExpressionEvaluation},set:function(t){this.callStack.currentElement.inExpressionEvaluation=t}},{key:"GoToStart",value:function(){this.callStack.currentElement.currentPointer=It.StartOf(this.story.mainContentContainer)}},{key:"SwitchFlow_Internal",value:function(t){if(null===t)throw new Error("Must pass a non-null string to Story.SwitchFlow");var e,n;null===this._namedFlows&&(this._namedFlows=new Map,this._namedFlows.set(this.kDefaultFlowName,this._currentFlow)),t!==this._currentFlow.name&&((n=E(this._namedFlows,t,null)).exists?e=n.result:(e=new nt(t,this.story),this._namedFlows.set(t,e)),this._currentFlow=e,this.variablesState.callStack=this._currentFlow.callStack,this.OutputStreamDirty())}},{key:"SwitchToDefaultFlow_Internal",value:function(){null!==this._namedFlows&&this.SwitchFlow_Internal(this.kDefaultFlowName)}},{key:"RemoveFlow_Internal",value:function(t){if(null===t)throw new Error("Must pass a non-null string to Story.DestroyFlow");if(t===this.kDefaultFlowName)throw new Error("Cannot destroy default flow");if(this._currentFlow.name===t&&this.SwitchToDefaultFlow_Internal(),null===this._namedFlows)return gt("this._namedFlows");this._namedFlows.delete(t)}},{key:"CopyAndStartPatching",value:function(){var t,e,n,i,r,a=new c(this.story);if(a._patch=new $(this._patch),a._currentFlow.name=this._currentFlow.name,a._currentFlow.callStack=new H(this._currentFlow.callStack),(t=a._currentFlow.currentChoices).push.apply(t,d(this._currentFlow.currentChoices)),(e=a._currentFlow.outputStream).push.apply(e,d(this._currentFlow.outputStream)),a.OutputStreamDirty(),null!==this._namedFlows){a._namedFlows=new Map;var s,o=pt(this._namedFlows);try{for(o.s();!(s=o.n()).done;){var u=S(s.value,2),l=u[0],h=u[1];a._namedFlows.set(l,h)}}catch(t){o.e(t)}finally{o.f()}a._namedFlows.set(this._currentFlow.name,a._currentFlow)}return this.hasError&&(a._currentErrors=[],(i=a._currentErrors).push.apply(i,d(this.currentErrors||[]))),this.hasWarning&&(a._currentWarnings=[],(r=a._currentWarnings).push.apply(r,d(this.currentWarnings||[]))),a.variablesState=this.variablesState,a.variablesState.callStack=a.callStack,a.variablesState.patch=a._patch,(n=a.evaluationStack).push.apply(n,d(this.evaluationStack)),this.divertedPointer.isNull||(a.divertedPointer=this.divertedPointer.copy()),a.previousPointer=this.previousPointer.copy(),a._visitCounts=this._visitCounts,a._turnIndices=this._turnIndices,a.currentTurnIndex=this.currentTurnIndex,a.storySeed=this.storySeed,a.previousRandom=this.previousRandom,a.didSafeExit=this.didSafeExit,a}},{key:"RestoreAfterPatch",value:function(){this.variablesState.callStack=this.callStack,this.variablesState.patch=this._patch}},{key:"ApplyAnyPatch",value:function(){if(null!==this._patch){this.variablesState.ApplyPatch();var t,e=pt(this._patch.visitCounts);try{for(e.s();!(t=e.n()).done;){var n=S(t.value,2),i=n[0],r=n[1];this.ApplyCountChanges(i,r,!0)}}catch(t){e.e(t)}finally{e.f()}var a,s=pt(this._patch.turnIndices);try{for(s.s();!(a=s.n()).done;){var o=S(a.value,2),u=o[0],l=o[1];this.ApplyCountChanges(u,l,!1)}}catch(t){s.e(t)}finally{s.f()}this._patch=null}}},{key:"ApplyCountChanges",value:function(t,e,n){(n?this._visitCounts:this._turnIndices).set(t.path.toString(),e)}},{key:"WriteJson",value:function(i){var e=this;if(i.WriteObjectStart(),i.WritePropertyStart("flows"),i.WriteObjectStart(),null!==this._namedFlows){var r,n=pt(this._namedFlows);try{var t=function(){var t=S(r.value,2),e=t[0],n=t[1];i.WriteProperty(e,function(t){return n.WriteJson(t)})};for(n.s();!(r=n.n()).done;)t()}catch(t){n.e(t)}finally{n.f()}}else i.WriteProperty(this._currentFlow.name,function(t){return e._currentFlow.WriteJson(t)});if(i.WriteObjectEnd(),i.WritePropertyEnd(),i.WriteProperty("currentFlowName",this._currentFlow.name),i.WriteProperty("variablesState",function(t){return e.variablesState.WriteJson(t)}),i.WriteProperty("evalStack",function(t){return z.WriteListRuntimeObjs(t,e.evaluationStack)}),!this.divertedPointer.isNull){if(null===this.divertedPointer.path)return gt("divertedPointer");i.WriteProperty("currentDivertTarget",this.divertedPointer.path.componentsString)}i.WriteProperty("visitCounts",function(t){return z.WriteIntDictionary(t,e._visitCounts)}),i.WriteProperty("turnIndices",function(t){return z.WriteIntDictionary(t,e._turnIndices)}),i.WriteIntProperty("turnIdx",this.currentTurnIndex),i.WriteIntProperty("storySeed",this.storySeed),i.WriteIntProperty("previousRandom",this.previousRandom),i.WriteIntProperty("inkSaveVersion",this.kInkSaveStateVersion),i.WriteIntProperty("inkFormatVersion",a.Story.inkVersionCurrent),i.WriteObjectEnd()}},{key:"LoadJsonObj",value:function(t){var e=t,n=e.inkSaveVersion;if(null==n)throw new Error("ink save format incorrect, can't load.");if(parseInt(n)<this.kMinCompatibleLoadVersion)throw new Error("Ink save format isn't compatible with the current version (saw '"+n+"', but minimum is "+this.kMinCompatibleLoadVersion+"), so can't load.");var i=e.flows;if(null!=i){var r=i;1===Object.keys(r).length?this._namedFlows=null:null===this._namedFlows?this._namedFlows=new Map:this._namedFlows.clear();for(var a,s=0,o=Object.entries(r);s<o.length;s++){var u=S(o[s],2),l=u[0],h=u[1],c=new nt(l,this.story,h);if(1===Object.keys(r).length)this._currentFlow=new nt(l,this.story,h);else{if(null===this._namedFlows)return gt("this._namedFlows");this._namedFlows.set(l,c)}}null!=this._namedFlows&&1<this._namedFlows.size&&(a=e.currentFlowName,this._currentFlow=this._namedFlows.get(a))}else{this._namedFlows=null,this._currentFlow.name=this.kDefaultFlowName,this._currentFlow.callStack.SetJsonToken(e.callstackThreads,this.story),this._currentFlow.outputStream=z.JArrayToRuntimeObjList(e.outputStream),this._currentFlow.currentChoices=z.JArrayToRuntimeObjList(e.currentChoices);var f=e.choiceThreads;this._currentFlow.LoadFlowChoiceThreads(f,this.story)}this.OutputStreamDirty(),this.variablesState.SetJsonToken(e.variablesState),this.variablesState.callStack=this._currentFlow.callStack,this._evaluationStack=z.JArrayToRuntimeObjList(e.evalStack);var v,d=e.currentDivertTarget;null!=d&&(v=new O(d.toString()),this.divertedPointer=this.story.PointerAtPath(v)),this._visitCounts=z.JObjectToIntDictionary(e.visitCounts),this._turnIndices=z.JObjectToIntDictionary(e.turnIndices),this.currentTurnIndex=parseInt(e.turnIdx),this.storySeed=parseInt(e.storySeed),this.previousRandom=parseInt(e.previousRandom)}},{key:"ResetErrors",value:function(){this._currentErrors=null,this._currentWarnings=null}},{key:"ResetOutput",value:function(t){var e,n=0<arguments.length&&void 0!==t?t:null;this.outputStream.length=0,null!==n&&(e=this.outputStream).push.apply(e,d(n)),this.OutputStreamDirty()}},{key:"PushToOutputStream",value:function(t){var e=yt(t,Tt);if(null!==e){var n=this.TrySplittingHeadTailWhitespace(e);if(null!==n){var i,r=pt(n);try{for(r.s();!(i=r.n()).done;){var a=i.value;this.PushToOutputStreamIndividual(a)}}catch(t){r.e(t)}finally{r.f()}return void this.OutputStreamDirty()}}this.PushToOutputStreamIndividual(t),this.OutputStreamDirty()}},{key:"PopFromOutputStream",value:function(t){this.outputStream.splice(this.outputStream.length-t,t),this.OutputStreamDirty()}},{key:"TrySplittingHeadTailWhitespace",value:function(t){var e=t.value;if(null===e)return gt("single.value");for(var n=-1,i=-1,r=0;r<e.length;r++){var a=e[r];if("\n"!=a){if(" "==a||"\t"==a)continue;break}-1==n&&(n=r),i=r}for(var s=-1,o=-1,u=e.length-1;0<=u;u--){var l=e[u];if("\n"!=l){if(" "==l||"\t"==l)continue;break}-1==s&&(s=u),o=u}if(-1==n&&-1==s)return null;var h,c,f,v,d=[],p=0,y=e.length;return-1!=n&&(0<n&&(h=new Tt(e.substring(0,n)),d.push(h)),d.push(new Tt("\n")),p=i+1),-1!=s&&(y=o),p<y&&(c=e.substring(p,y-p),d.push(new Tt(c))),-1!=s&&i<o&&(d.push(new Tt("\n")),s<e.length-1&&(f=e.length-s-1,v=new Tt(e.substring(s+1,f)),d.push(v))),d}},{key:"PushToOutputStreamIndividual",value:function(t){var e=yt(t,G),n=yt(t,Tt),i=!0;if(e)this.TrimNewlinesFromOutputStream(),i=!0;else if(n){var r=-1,a=this.callStack.currentElement;a.type==Nt.Function&&(r=a.functionStartInOutputStream);for(var s=-1,o=this.outputStream.length-1;0<=o;o--){var u=this.outputStream[o],l=u instanceof At?u:null;if(null!=(u instanceof G?u:null)){s=o;break}if(null!=l&&l.commandType==At.CommandType.BeginString){r<=o&&(r=-1);break}}if(-1!=(-1!=s&&-1!=r?Math.min(r,s):-1!=s?s:r)){if(n.isNewline)i=!1;else if(n.isNonWhitespace&&(-1<s&&this.RemoveExistingGlue(),-1<r))for(var h=this.callStack.elements,c=h.length-1;0<=c;c--){var f=h[c];if(f.type!=Nt.Function)break;f.functionStartInOutputStream=-1}}else n.isNewline&&(!this.outputStreamEndsInNewline&&this.outputStreamContainsContent||(i=!1))}if(i){if(null===t)return gt("obj");this.outputStream.push(t),this.OutputStreamDirty()}}},{key:"TrimNewlinesFromOutputStream",value:function(){for(var t=-1,e=this.outputStream.length-1;0<=e;){var n=this.outputStream[e],i=yt(n,At),r=yt(n,Tt);if(null!=i||null!=r&&r.isNonWhitespace)break;null!=r&&r.isNewline&&(t=e),e--}if(0<=t)for(e=t;e<this.outputStream.length;){yt(this.outputStream[e],Tt)?this.outputStream.splice(e,1):e++}this.OutputStreamDirty()}},{key:"RemoveExistingGlue",value:function(){for(var t=this.outputStream.length-1;0<=t;t--){var e=this.outputStream[t];if(e instanceof G)this.outputStream.splice(t,1);else if(e instanceof At)break}this.OutputStreamDirty()}},{key:"outputStreamEndsInNewline",get:function(){if(0<this.outputStream.length)for(var t=this.outputStream.length-1;0<=t;t--){if(this.outputStream[t]instanceof At)break;var e=this.outputStream[t];if(e instanceof Tt){if(e.isNewline)return!0;if(e.isNonWhitespace)break}}return!1}},{key:"outputStreamContainsContent",get:function(){var t,e=pt(this.outputStream);try{for(e.s();!(t=e.n()).done;){if(t.value instanceof Tt)return!0}}catch(t){e.e(t)}finally{e.f()}return!1}},{key:"inStringEvaluation",get:function(){for(var t=this.outputStream.length-1;0<=t;t--){var e=yt(this.outputStream[t],At);if(e instanceof At&&e.commandType==At.CommandType.BeginString)return!0}return!1}},{key:"PushEvaluationStack",value:function(t){var e=yt(t,Pt);if(e){var n=e.value;if(null===n)return gt("rawList");if(null!=n.originNames){n.origins||(n.origins=[]),n.origins.length=0;var i,r=pt(n.originNames);try{for(r.s();!(i=r.n()).done;){var a=i.value;if(null===this.story.listDefinitions)return gt("StoryState.story.listDefinitions");var s=this.story.listDefinitions.TryListGetDefinition(a,null);if(null===s.result)return gt("StoryState def.result");n.origins.indexOf(s.result)<0&&n.origins.push(s.result)}}catch(t){r.e(t)}finally{r.f()}}}if(null===t)return gt("obj");this.evaluationStack.push(t)}},{key:"PopEvaluationStack",value:function(t){if(void 0===t)return b(this.evaluationStack.pop());if(t>this.evaluationStack.length)throw new Error("trying to pop too many objects");return b(this.evaluationStack.splice(this.evaluationStack.length-t,t))}},{key:"PeekEvaluationStack",value:function(){return this.evaluationStack[this.evaluationStack.length-1]}},{key:"ForceEnd",value:function(){this.callStack.Reset(),this._currentFlow.currentChoices.length=0,this.currentPointer=It.Null,this.previousPointer=It.Null,this.didSafeExit=!0}},{key:"TrimWhitespaceFromFunctionEnd",value:function(){k.Assert(this.callStack.currentElement.type==Nt.Function);var t=this.callStack.currentElement.functionStartInOutputStream;-1==t&&(t=0);for(var e=this.outputStream.length-1;t<=e;e--){var n=this.outputStream[e],i=yt(n,Tt),r=yt(n,At);if(null!=i){if(r)break;if(!i.isNewline&&!i.isInlineWhitespace)break;this.outputStream.splice(e,1),this.OutputStreamDirty()}}}},{key:"PopCallStack",value:function(t){var e=0<arguments.length&&void 0!==t?t:null;this.callStack.currentElement.type==Nt.Function&&this.TrimWhitespaceFromFunctionEnd(),this.callStack.Pop(e)}},{key:"SetChosenPath",value:function(t,e){this._currentFlow.currentChoices.length=0;var n=this.story.PointerAtPath(t);n.isNull||-1!=n.index||(n.index=0),this.currentPointer=n,e&&this.currentTurnIndex++}},{key:"StartFunctionEvaluationFromGame",value:function(t,e){this.callStack.Push(Nt.FunctionEvaluationFromGame,this.evaluationStack.length),this.callStack.currentElement.currentPointer=It.StartOf(t),this.PassArgumentsToEvaluationStack(e)}},{key:"PassArgumentsToEvaluationStack",value:function(t){if(null!==t)for(var e=0;e<t.length;e++){if("number"!=typeof t[e]&&"string"!=typeof t[e]||t[e]instanceof Ct)throw new Error((b(arguments[e]),"null"));this.PushEvaluationStack(_t.Create(t[e]))}}},{key:"TryExitFunctionEvaluationFromGame",value:function(){return this.callStack.currentElement.type==Nt.FunctionEvaluationFromGame&&(this.currentPointer=It.Null,this.didSafeExit=!0)}},{key:"CompleteFunctionEvaluationFromGame",value:function(){if(this.callStack.currentElement.type!=Nt.FunctionEvaluationFromGame)throw new Error("Expected external function evaluation to be complete. Stack trace: "+this.callStack.callStackTrace);for(var t=this.callStack.currentElement.evaluationStackHeightWhenPushed,e=null;this.evaluationStack.length>t;){var n=this.PopEvaluationStack();null===e&&(e=n)}if(this.PopCallStack(Nt.FunctionEvaluationFromGame),e){if(e instanceof Vt)return null;var i=mt(e,_t);return i.valueType==N.DivertTarget?i.valueObject.toString():i.valueObject}return null}},{key:"AddError",value:function(t,e){e?(null==this._currentWarnings&&(this._currentWarnings=[]),this._currentWarnings.push(t)):(null==this._currentErrors&&(this._currentErrors=[]),this._currentErrors.push(t))}},{key:"OutputStreamDirty",value:function(){this._outputStreamTextDirty=!0,this._outputStreamTagsDirty=!0}}]),c}(),rt=function(){function t(){m(this,t),this.startTime=void 0}return u(t,[{key:"ElapsedMilliseconds",get:function(){return void 0===this.startTime?0:(new Date).getTime()-this.startTime}},{key:"Start",value:function(){this.startTime=(new Date).getTime()}},{key:"Stop",value:function(){this.startTime=void 0}}]),t}();(Z=Q=Q||{})[Z.Author=0]="Author",Z[Z.Warning=1]="Warning",Z[Z.Error=2]="Error",Number.isInteger||(Number.isInteger=function(t){return"number"==typeof t&&isFinite(t)&&-9007199254740992<t&&t<9007199254740992&&Math.floor(t)===t}),a.Story=function(){s(f,T);var h=v(f);function f(){var t,e;m(this,f),(t=h.call(this)).inkVersionMinimumCompatible=18,t.onError=null,t.onDidContinue=null,t.onMakeChoice=null,t.onEvaluateFunction=null,t.onCompleteEvaluateFunction=null,t.onChoosePathString=null,t._prevContainers=[],t.allowExternalFunctionFallbacks=!1,t._listDefinitions=null,t._variableObservers=null,t._hasValidatedExternals=!1,t._temporaryEvaluationContainer=null,t._asyncContinueActive=!1,t._stateSnapshotAtLastNewline=null,t._sawLookaheadUnsafeFunctionAfterNewline=!1,t._recursiveContinueCount=0,t._asyncSaving=!1;var n,i=t._profiler=null,r=null;if(arguments[0]instanceof Ot?(e=arguments[0],void 0!==arguments[1]&&(i=arguments[1]),t._mainContentContainer=e):r="string"==typeof arguments[0]?(n=arguments[0],Y.TextToDictionary(n)):arguments[0],null!=i&&(t._listDefinitions=new K(i)),t._externals=new Map,null!==r){var a=r,s=a.inkVersion;if(null==s)throw new Error("ink version number not found. Are you sure it's a valid .ink.json file?");var o=parseInt(s);if(f.inkVersionCurrent<o)throw new Error("Version of ink used to build story was newer than the current version of the engine");if(o<t.inkVersionMinimumCompatible)throw new Error("Version of ink used to build story is too old to be loaded by this version of the engine");o!=f.inkVersionCurrent&&console.warn("WARNING: Version of ink used to build story doesn't match current version of engine. Non-critical, but recommend synchronising.");var u,l=a.root;if(null==l)throw new Error("Root node for ink not found. Are you sure it's a valid .ink.json file?");(u=a.listDefs)&&(t._listDefinitions=z.JTokenToListDefinitions(u)),t._mainContentContainer=mt(z.JTokenToRuntimeObject(l),Ot),t.ResetState()}return t}return u(f,[{key:"currentChoices",get:function(){var t=[];if(null===this._state)return gt("this._state");var e,n=pt(this._state.currentChoices);try{for(n.s();!(e=n.n()).done;){var i=e.value;i.isInvisibleDefault||(i.index=t.length,t.push(i))}}catch(t){n.e(t)}finally{n.f()}return t}},{key:"currentText",get:function(){return this.IfAsyncWeCant("call currentText since it's a work in progress"),this.state.currentText}},{key:"currentTags",get:function(){return this.IfAsyncWeCant("call currentTags since it's a work in progress"),this.state.currentTags}},{key:"currentErrors",get:function(){return this.state.currentErrors}},{key:"currentWarnings",get:function(){return this.state.currentWarnings}},{key:"currentFlowName",get:function(){return this.state.currentFlowName}},{key:"hasError",get:function(){return this.state.hasError}},{key:"hasWarning",get:function(){return this.state.hasWarning}},{key:"variablesState",get:function(){return this.state.variablesState}},{key:"listDefinitions",get:function(){return this._listDefinitions}},{key:"state",get:function(){return this._state}},{key:"StartProfiling",value:function(){}},{key:"EndProfiling",value:function(){}},{key:"ToJson",value:function(t){var e=this,n=!1;if(t||(n=!0,t=new Y.Writer),t.WriteObjectStart(),t.WriteIntProperty("inkVersion",f.inkVersionCurrent),t.WriteProperty("root",function(t){return z.WriteRuntimeContainer(t,e._mainContentContainer)}),null!=this._listDefinitions){t.WritePropertyStart("listDefs"),t.WriteObjectStart();var i,r=pt(this._listDefinitions.lists);try{for(r.s();!(i=r.n()).done;){var a=i.value;t.WritePropertyStart(a.name),t.WriteObjectStart();var s,o=pt(a.items);try{for(o.s();!(s=o.n()).done;){var u=S(s.value,2),l=u[0],h=u[1],c=kt.fromSerializedKey(l);t.WriteIntProperty(c.itemName,h)}}catch(t){o.e(t)}finally{o.f()}t.WriteObjectEnd(),t.WritePropertyEnd()}}catch(t){r.e(t)}finally{r.f()}t.WriteObjectEnd(),t.WritePropertyEnd()}if(t.WriteObjectEnd(),n)return t.ToString()}},{key:"ResetState",value:function(){this.IfAsyncWeCant("ResetState"),this._state=new it(this),this._state.variablesState.ObserveVariableChange(this.VariableStateDidChangeEvent.bind(this)),this.ResetGlobals()}},{key:"ResetErrors",value:function(){if(null===this._state)return gt("this._state");this._state.ResetErrors()}},{key:"ResetCallstack",value:function(){if(this.IfAsyncWeCant("ResetCallstack"),null===this._state)return gt("this._state");this._state.ForceEnd()}},{key:"ResetGlobals",value:function(){var t;this._mainContentContainer.namedContent.get("global decl")&&(t=this.state.currentPointer.copy(),this.ChoosePath(new O("global decl"),!1),this.ContinueInternal(),this.state.currentPointer=t),this.state.variablesState.SnapshotDefaultGlobals()}},{key:"SwitchFlow",value:function(t){if(this.IfAsyncWeCant("switch flow"),this._asyncSaving)throw new Error("Story is already in background saving mode, can't switch flow to "+t);this.state.SwitchFlow_Internal(t)}},{key:"RemoveFlow",value:function(t){this.state.RemoveFlow_Internal(t)}},{key:"SwitchToDefaultFlow",value:function(){this.state.SwitchToDefaultFlow_Internal()}},{key:"Continue",value:function(){return this.ContinueAsync(0),this.currentText}},{key:"canContinue",get:function(){return this.state.canContinue}},{key:"asyncContinueComplete",get:function(){return!this._asyncContinueActive}},{key:"ContinueAsync",value:function(t){this._hasValidatedExternals||this.ValidateExternalBindings(),this.ContinueInternal(t)}},{key:"ContinueInternal",value:function(t){var e=0<arguments.length&&void 0!==t?t:0;null!=this._profiler&&this._profiler.PreContinue();var n=0<e;if(this._recursiveContinueCount++,!this._asyncContinueActive){if(this._asyncContinueActive=n,!this.canContinue)throw new Error("Can't continue - should check canContinue before calling Continue");this._state.didSafeExit=!1,this._state.ResetOutput(),1==this._recursiveContinueCount&&(this._state.variablesState.batchObservingVariableChanges=!0)}var i=new rt;i.Start();var r=!1;this._sawLookaheadUnsafeFunctionAfterNewline=!1;do{try{r=this.ContinueSingleStep()}catch(t){if(!(t instanceof bt))throw t;this.AddError(t.message,void 0,t.useEndLineNumber);break}if(r)break;if(this._asyncContinueActive&&i.ElapsedMilliseconds>e)break}while(this.canContinue);if(i.Stop(),!r&&this.canContinue||(null!==this._stateSnapshotAtLastNewline&&this.RestoreStateSnapshot(),this.canContinue||(this.state.callStack.canPopThread&&this.AddError("Thread available to pop, threads should always be flat by the end of evaluation?"),0!=this.state.generatedChoices.length||this.state.didSafeExit||null!=this._temporaryEvaluationContainer||(this.state.callStack.CanPop(Nt.Tunnel)?this.AddError("unexpectedly reached end of content. Do you need a '->->' to return from a tunnel?"):this.state.callStack.CanPop(Nt.Function)?this.AddError("unexpectedly reached end of content. Do you need a '~ return'?"):this.state.callStack.canPop?this.AddError("unexpectedly reached end of content for unknown reason. Please debug compiler!"):this.AddError("ran out of content. Do you need a '-> DONE' or '-> END'?"))),this.state.didSafeExit=!1,this._sawLookaheadUnsafeFunctionAfterNewline=!1,1==this._recursiveContinueCount&&(this._state.variablesState.batchObservingVariableChanges=!1),this._asyncContinueActive=!1,null!==this.onDidContinue&&this.onDidContinue()),this._recursiveContinueCount--,null!=this._profiler&&this._profiler.PostContinue(),this.state.hasError||this.state.hasWarning){if(null===this.onError){var a=new St;throw a.Append("Ink had "),this.state.hasError&&(a.Append("".concat(this.state.currentErrors.length)),a.Append(1==this.state.currentErrors.length?" error":"errors"),this.state.hasWarning&&a.Append(" and ")),this.state.hasWarning&&(a.Append("".concat(this.state.currentWarnings.length)),a.Append(1==this.state.currentWarnings.length?" warning":"warnings"),this.state.hasWarning&&a.Append(" and ")),a.Append(". It is strongly suggested that you assign an error handler to story.onError. The first issue was: "),a.Append(this.state.hasError?this.state.currentErrors[0]:this.state.currentWarnings[0]),new bt(a.toString())}if(this.state.hasError){var s,o=pt(this.state.currentErrors);try{for(o.s();!(s=o.n()).done;){var u=s.value;this.onError(u,Q.Error)}}catch(u){o.e(u)}finally{o.f()}}if(this.state.hasWarning){var l,h=pt(this.state.currentWarnings);try{for(h.s();!(l=h.n()).done;){var c=l.value;this.onError(c,Q.Warning)}}catch(u){h.e(u)}finally{h.f()}}this.ResetErrors()}}},{key:"ContinueSingleStep",value:function(){if(null!=this._profiler&&this._profiler.PreStep(),this.Step(),null!=this._profiler&&this._profiler.PostStep(),this.canContinue||this.state.callStack.elementIsEvaluateFromGame||this.TryFollowDefaultInvisibleChoice(),null!=this._profiler&&this._profiler.PreSnapshot(),!this.state.inStringEvaluation){if(null!==this._stateSnapshotAtLastNewline){if(null===this._stateSnapshotAtLastNewline.currentTags)return gt("this._stateAtLastNewline.currentTags");if(null===this.state.currentTags)return gt("this.state.currentTags");var t=this.CalculateNewlineOutputStateChange(this._stateSnapshotAtLastNewline.currentText,this.state.currentText,this._stateSnapshotAtLastNewline.currentTags.length,this.state.currentTags.length);if(t==f.OutputStateChange.ExtendedBeyondNewline||this._sawLookaheadUnsafeFunctionAfterNewline)return this.RestoreStateSnapshot(),!0;t==f.OutputStateChange.NewlineRemoved&&this.DiscardSnapshot()}this.state.outputStreamEndsInNewline&&(this.canContinue?null==this._stateSnapshotAtLastNewline&&this.StateSnapshot():this.DiscardSnapshot())}return null!=this._profiler&&this._profiler.PostSnapshot(),!1}},{key:"CalculateNewlineOutputStateChange",value:function(t,e,n,i){if(null===t)return gt("prevText");if(null===e)return gt("currText");var r=e.length>=t.length&&"\n"==e.charAt(t.length-1);if(n==i&&t.length==e.length&&r)return f.OutputStateChange.NoChange;if(!r)return f.OutputStateChange.NewlineRemoved;if(n<i)return f.OutputStateChange.ExtendedBeyondNewline;for(var a=t.length;a<e.length;a++){var s=e.charAt(a);if(" "!=s&&"\t"!=s)return f.OutputStateChange.ExtendedBeyondNewline}return f.OutputStateChange.NoChange}},{key:"ContinueMaximally",value:function(){this.IfAsyncWeCant("ContinueMaximally");for(var t=new St;this.canContinue;)t.Append(this.Continue());return t.toString()}},{key:"ContentAtPath",value:function(t){return this.mainContentContainer.ContentAtPath(t)}},{key:"KnotContainerWithName",value:function(t){var e=this.mainContentContainer.namedContent.get(t);return e instanceof Ot?e:null}},{key:"PointerAtPath",value:function(t){if(0==t.length)return It.Null;var e=new It,n=t.length,i=null;return null===t.lastComponent?gt("path.lastComponent"):(t.lastComponent.isIndex?(n=t.length-1,i=this.mainContentContainer.ContentAtPath(t,void 0,n),e.container=i.container,e.index=t.lastComponent.index):(i=this.mainContentContainer.ContentAtPath(t),e.container=i.container,e.index=-1),null==i.obj||i.obj==this.mainContentContainer&&0<n?this.Error("Failed to find content at path '"+t+"', and no approximation of it was possible."):i.approximate&&this.Warning("Failed to find content at path '"+t+"', so it was approximated to: '"+i.obj.path+"'."),e)}},{key:"StateSnapshot",value:function(){this._stateSnapshotAtLastNewline=this._state,this._state=this._state.CopyAndStartPatching()}},{key:"RestoreStateSnapshot",value:function(){null===this._stateSnapshotAtLastNewline&&gt("_stateSnapshotAtLastNewline"),this._stateSnapshotAtLastNewline.RestoreAfterPatch(),this._state=this._stateSnapshotAtLastNewline,this._stateSnapshotAtLastNewline=null,this._asyncSaving||this._state.ApplyAnyPatch()}},{key:"DiscardSnapshot",value:function(){this._asyncSaving||this._state.ApplyAnyPatch(),this._stateSnapshotAtLastNewline=null}},{key:"CopyStateForBackgroundThreadSave",value:function(){if(this.IfAsyncWeCant("start saving on a background thread"),this._asyncSaving)throw new Error("Story is already in background saving mode, can't call CopyStateForBackgroundThreadSave again!");var t=this._state;return this._state=this._state.CopyAndStartPatching(),this._asyncSaving=!0,t}},{key:"BackgroundSaveComplete",value:function(){null===this._stateSnapshotAtLastNewline&&this._state.ApplyAnyPatch(),this._asyncSaving=!1}},{key:"Step",value:function(){var t=!0,e=this.state.currentPointer.copy();if(!e.isNull){for(var n=yt(e.Resolve(),Ot);n&&(this.VisitContainer(n,!0),0!=n.content.length);)n=yt((e=It.StartOf(n)).Resolve(),Ot);this.state.currentPointer=e.copy(),null!=this._profiler&&this._profiler.Step(this.state.callStack);var i,r,a,s,o,u=e.Resolve(),l=this.PerformLogicAndFlowControl(u);this.state.currentPointer.isNull||(l&&(t=!1),(i=yt(u,M))&&((r=this.ProcessChoice(i))&&this.state.generatedChoices.push(r),u=null,t=!1),u instanceof Ot&&(t=!1),t&&((a=yt(u,W))&&-1==a.contextIndex&&(s=this.state.callStack.ContextForVariableNamed(a.variableName),u=new W(a.variableName,s)),this.state.inExpressionEvaluation?this.state.PushEvaluationStack(u):this.state.PushToOutputStream(u)),this.NextContent(),(o=yt(u,At))&&o.commandType==At.CommandType.StartThread&&this.state.callStack.PushThread())}}},{key:"VisitContainer",value:function(t,e){t.countingAtStartOnly&&!e||(t.visitsShouldBeCounted&&this.state.IncrementVisitCountForContainer(t),t.turnIndexShouldBeCounted&&this.state.RecordTurnIndexVisitToContainer(t))}},{key:"VisitChangedContainersDueToDivert",value:function(){var t=this.state.previousPointer.copy(),e=this.state.currentPointer.copy();if(!e.isNull&&-1!=e.index){if(this._prevContainers.length=0,!t.isNull)for(var n=yt(t.Resolve(),Ot)||yt(t.container,Ot);n;)this._prevContainers.push(n),n=yt(n.parent,Ot);var i=e.Resolve();if(null!=i)for(var r=yt(i.parent,Ot),a=!0;r&&(this._prevContainers.indexOf(r)<0||r.countingAtStartOnly);){var s=0<r.content.length&&i==r.content[0]&&a;s||(a=!1),this.VisitContainer(r,s),r=yt((i=r).parent,Ot)}}}},{key:"ProcessChoice",value:function(t){var e,n=!0;t.hasCondition&&(e=this.state.PopEvaluationStack(),this.IsTruthy(e)||(n=!1));var i="",r="";if(t.hasChoiceOnlyContent&&(r=mt(this.state.PopEvaluationStack(),Tt).value||""),t.hasStartContent&&(i=mt(this.state.PopEvaluationStack(),Tt).value||""),t.onceOnly&&0<this.state.VisitCountForContainer(t.choiceTarget)&&(n=!1),!n)return null;var a=new U;return a.targetPath=t.pathOnChoice,a.sourcePath=t.path.toString(),a.isInvisibleDefault=t.isInvisibleDefault,a.threadAtGeneration=this.state.callStack.ForkThread(),a.text=(i+r).replace(/^[ \t]+|[ \t]+$/g,""),a}},{key:"IsTruthy",value:function(t){if(t instanceof _t){var e=t;return e instanceof Et?(this.Error("Shouldn't use a divert target (to "+e.targetPath+") as a conditional value. Did you intend a function call 'likeThis()' or a read count check 'likeThis'? (no arrows)"),!1):e.isTruthy}return!1}},{key:"PerformLogicAndFlowControl",value:function(t){if(null==t)return!1;if(t instanceof xt){var e=t;if(e.isConditional){var n=this.state.PopEvaluationStack();if(!this.IsTruthy(n))return!0}if(e.hasVariableTarget){var i,r,a=e.variableDivertName,s=this.state.variablesState.GetVariableWithName(a);null==s?this.Error("Tried to divert using a target from a variable that could not be found ("+a+")"):s instanceof Et||(r="Tried to divert to a target from a variable, but the variable ("+a+") didn't contain a divert target, it ",(i=yt(s,wt))instanceof wt&&0==i.value?r+="was empty/null (the value 0).":r+="contained '"+s+"'.",this.Error(r));var o=mt(s,Et);this.state.divertedPointer=this.PointerAtPath(o.targetPath)}else{if(e.isExternal)return this.CallExternalFunction(e.targetPathString,e.externalArgs),!0;this.state.divertedPointer=e.targetPointer.copy()}return e.pushesToStack&&this.state.callStack.Push(e.stackPushType,void 0,this.state.outputStream.length),this.state.divertedPointer.isNull&&!e.isExternal&&(e&&e.debugMetadata&&null!=e.debugMetadata.sourceName?this.Error("Divert target doesn't exist: "+e.debugMetadata.sourceName):this.Error("Divert resolution failed: "+e)),!0}if(t instanceof At){var u,l,h=t;switch(h.commandType){case At.CommandType.EvalStart:this.Assert(!1===this.state.inExpressionEvaluation,"Already in expression evaluation?"),this.state.inExpressionEvaluation=!0;break;case At.CommandType.EvalEnd:this.Assert(!0===this.state.inExpressionEvaluation,"Not in expression evaluation mode"),this.state.inExpressionEvaluation=!1;break;case At.CommandType.EvalOutput:0<this.state.evaluationStack.length&&((u=this.state.PopEvaluationStack())instanceof Vt||(l=new Tt(u.toString()),this.state.PushToOutputStream(l)));break;case At.CommandType.NoOp:break;case At.CommandType.Duplicate:this.state.PushEvaluationStack(this.state.PeekEvaluationStack());break;case At.CommandType.PopEvaluatedValue:this.state.PopEvaluationStack();break;case At.CommandType.PopFunction:case At.CommandType.PopTunnel:var c,f,v,d,p=h.commandType==At.CommandType.PopFunction?Nt.Function:Nt.Tunnel,y=null;if(p!=Nt.Tunnel||null===(y=yt(c=this.state.PopEvaluationStack(),Et))&&this.Assert(c instanceof Vt,"Expected void if ->-> doesn't override target"),this.state.TryExitFunctionEvaluationFromGame())break;this.state.callStack.currentElement.type==p&&this.state.callStack.canPop?(this.state.PopCallStack(),y&&(this.state.divertedPointer=this.PointerAtPath(y.targetPath))):((f=new Map).set(Nt.Function,"function return statement (~ return)"),f.set(Nt.Tunnel,"tunnel onwards statement (->->)"),v=f.get(this.state.callStack.currentElement.type),this.state.callStack.canPop||(v="end of flow (-> END or choice)"),d="Found "+f.get(p)+", when expected "+v,this.Error(d));break;case At.CommandType.BeginString:this.state.PushToOutputStream(h),this.Assert(!0===this.state.inExpressionEvaluation,"Expected to be in an expression when evaluating a string"),this.state.inExpressionEvaluation=!1;break;case At.CommandType.EndString:for(var m=[],g=0,S=this.state.outputStream.length-1;0<=S;--S){var k=this.state.outputStream[S];g++;var C=yt(k,At);if(C&&C.commandType==At.CommandType.BeginString)break;k instanceof Tt&&m.push(k)}this.state.PopFromOutputStream(g),m=m.reverse();var b,_=new St,w=pt(m);try{for(w.s();!(b=w.n()).done;){var T=b.value;_.Append(T.toString())}}catch(t){w.e(t)}finally{w.f()}this.state.inExpressionEvaluation=!0,this.state.PushEvaluationStack(new Tt(_.toString()));break;case At.CommandType.ChoiceCount:var E=this.state.generatedChoices.length;this.state.PushEvaluationStack(new wt(E));break;case At.CommandType.Turns:this.state.PushEvaluationStack(new wt(this.state.currentTurnIndex+1));break;case At.CommandType.TurnsSince:case At.CommandType.ReadCount:var P=this.state.PopEvaluationStack();if(!(P instanceof Et)){var O=P instanceof wt?". Did you accidentally pass a read count ('knot_name') instead of a target ('-> knot_name')?":"";this.Error("TURNS_SINCE / READ_COUNT expected a divert target (knot, stitch, label name), but saw "+P+O);break}var N,A=mt(P,Et),I=yt(this.ContentAtPath(A.targetPath).correctObj,Ot);null!=I?N=h.commandType==At.CommandType.TurnsSince?this.state.TurnsSinceForContainer(I):this.state.VisitCountForContainer(I):(N=h.commandType==At.CommandType.TurnsSince?-1:0,this.Warning("Failed to find container for "+h.toString()+" lookup at "+A.targetPath.toString())),this.state.PushEvaluationStack(new wt(N));break;case At.CommandType.Random:var x=yt(this.state.PopEvaluationStack(),wt),F=yt(this.state.PopEvaluationStack(),wt);if(null==F||F instanceof wt==!1)return this.Error("Invalid value for minimum parameter of RANDOM(min, max)");if(null==x||F instanceof wt==!1)return this.Error("Invalid value for maximum parameter of RANDOM(min, max)");if(null===x.value)return gt("maxInt.value");if(null===F.value)return gt("minInt.value");var W=x.value-F.value+1;(!isFinite(W)||W>Number.MAX_SAFE_INTEGER)&&(W=Number.MAX_SAFE_INTEGER,this.Error("RANDOM was called with a range that exceeds the size that ink numbers can use.")),W<=0&&this.Error("RANDOM was called with minimum as "+F.value+" and maximum as "+x.value+". The maximum must be larger");var V=this.state.storySeed+this.state.previousRandom,L=new Rt(V).next(),R=L%W+F.value;this.state.PushEvaluationStack(new wt(R)),this.state.previousRandom=L;break;case At.CommandType.SeedRandom:var j=yt(this.state.PopEvaluationStack(),wt);if(null==j||j instanceof wt==!1)return this.Error("Invalid value passed to SEED_RANDOM");if(null===j.value)return gt("minInt.value");this.state.storySeed=j.value,this.state.previousRandom=0,this.state.PushEvaluationStack(new Vt);break;case At.CommandType.VisitIndex:var D=this.state.VisitCountForContainer(this.state.currentPointer.container)-1;this.state.PushEvaluationStack(new wt(D));break;case At.CommandType.SequenceShuffleIndex:var B=this.NextSequenceShuffleIndex();this.state.PushEvaluationStack(new wt(B));break;case At.CommandType.StartThread:break;case At.CommandType.Done:this.state.callStack.canPopThread?this.state.callStack.PopThread():(this.state.didSafeExit=!0,this.state.currentPointer=It.Null);break;case At.CommandType.End:this.state.ForceEnd();break;case At.CommandType.ListFromInt:var G=yt(this.state.PopEvaluationStack(),wt),M=mt(this.state.PopEvaluationStack(),Tt);if(null===G)throw new bt("Passed non-integer when creating a list element from a numerical value.");var J=null;if(null===this.listDefinitions)return gt("this.listDefinitions");var U=this.listDefinitions.TryListGetDefinition(M.value,null);if(!U.exists)throw new bt("Failed to find LIST called "+M.value);if(null===G.value)return gt("minInt.value");var q=U.result.TryGetItemWithValue(G.value,kt.Null);q.exists&&(J=new Pt(q.result,G.value)),null==J&&(J=new Pt),this.state.PushEvaluationStack(J);break;case At.CommandType.ListRange:var K=yt(this.state.PopEvaluationStack(),_t),z=yt(this.state.PopEvaluationStack(),_t),H=yt(this.state.PopEvaluationStack(),Pt);if(null===H||null===z||null===K)throw new bt("Expected list, minimum and maximum for LIST_RANGE");if(null===H.value)return gt("targetList.value");var X=H.value.ListWithSubRange(z.valueObject,K.valueObject);this.state.PushEvaluationStack(new Pt(X));break;case At.CommandType.ListRandom:var $=this.state.PopEvaluationStack();if(null===$)throw new bt("Expected list for LIST_RANDOM");var Y=$.value,Q=null;if(null===Y)throw gt("list");if(0==Y.Count)Q=new Ct;else{for(var Z=this.state.storySeed+this.state.previousRandom,tt=new Rt(Z).next(),et=tt%Y.Count,nt=Y.entries(),it=0;it<=et-1;it++)nt.next();var rt=nt.next().value,at={Key:kt.fromSerializedKey(rt[0]),Value:rt[1]};if(null===at.Key.originName)return gt("randomItem.Key.originName");(Q=new Ct(at.Key.originName,this)).Add(at.Key,at.Value),this.state.previousRandom=tt}this.state.PushEvaluationStack(new Pt(Q));break;default:this.Error("unhandled ControlCommand: "+h)}return!0}if(t instanceof Wt){var st=t,ot=this.state.PopEvaluationStack();return this.state.variablesState.Assign(st,ot),!0}if(t instanceof Ft){var ut,lt,ht=t,ct=null;return null!=ht.pathForCount?(ut=ht.containerForCount,lt=this.state.VisitCountForContainer(ut),ct=new wt(lt)):null==(ct=this.state.variablesState.GetVariableWithName(ht.name))&&(this.Warning("Variable not found: '"+ht.name+"'. Using default value of 0 (false). This can happen with temporary variables if the declaration hasn't yet been hit. Globals are always given a default value on load if a value doesn't exist in the save state."),ct=new wt(0)),this.state.PushEvaluationStack(ct),!0}if(t instanceof Lt){var ft=t,vt=this.state.PopEvaluationStack(ft.numberOfParameters),dt=ft.Call(vt);return this.state.PushEvaluationStack(dt),!0}return!1}},{key:"ChoosePathString",value:function(t,e,n){var i=!(1<arguments.length&&void 0!==e)||e,r=2<arguments.length&&void 0!==n?n:[];if(this.IfAsyncWeCant("call ChoosePathString right now"),null!==this.onChoosePathString&&this.onChoosePathString(t,r),i)this.ResetCallstack();else if(this.state.callStack.currentElement.type==Nt.Function){var a="",s=this.state.callStack.currentElement.currentPointer.container;throw null!=s&&(a="("+s.path.toString()+") "),new Error("Story was running a function "+a+"when you called ChoosePathString("+t+") - this is almost certainly not not what you want! Full stack trace: \n"+this.state.callStack.callStackTrace)}this.state.PassArgumentsToEvaluationStack(r),this.ChoosePath(new O(t))}},{key:"IfAsyncWeCant",value:function(t){if(this._asyncContinueActive)throw new Error("Can't "+t+". Story is in the middle of a ContinueAsync(). Make more ContinueAsync() calls or a single Continue() call beforehand.")}},{key:"ChoosePath",value:function(t,e){var n=!(1<arguments.length&&void 0!==e)||e;this.state.SetChosenPath(t,n),this.VisitChangedContainersDueToDivert()}},{key:"ChooseChoiceIndex",value:function(t){t=t;var e=this.currentChoices;this.Assert(0<=t&&t<e.length,"choice out of range");var n=e[t];return null!==this.onMakeChoice&&this.onMakeChoice(n),null===n.threadAtGeneration?gt("choiceToChoose.threadAtGeneration"):null===n.targetPath?gt("choiceToChoose.targetPath"):(this.state.callStack.currentThread=n.threadAtGeneration,void this.ChoosePath(n.targetPath))}},{key:"HasFunction",value:function(t){try{return null!=this.KnotContainerWithName(t)}catch(t){return!1}}},{key:"EvaluateFunction",value:function(t,e,n){var i=1<arguments.length&&void 0!==e?e:[],r=2<arguments.length&&void 0!==n&&n;if(null!==this.onEvaluateFunction&&this.onEvaluateFunction(t,i),this.IfAsyncWeCant("evaluate a function"),null==t)throw new Error("Function is null");if(""==t||""==t.trim())throw new Error("Function is empty or white space.");var a=this.KnotContainerWithName(t);if(null==a)throw new Error("Function doesn't exist: '"+t+"'");var s=[];s.push.apply(s,d(this.state.outputStream)),this._state.ResetOutput(),this.state.StartFunctionEvaluationFromGame(a,i);for(var o=new St;this.canContinue;)o.Append(this.Continue());var u=o.toString();this._state.ResetOutput(s);var l=this.state.CompleteFunctionEvaluationFromGame();return null!=this.onCompleteEvaluateFunction&&this.onCompleteEvaluateFunction(t,i,u,l),r?{returned:l,output:u}:l}},{key:"EvaluateExpression",value:function(t){var e=this.state.callStack.elements.length;this.state.callStack.Push(Nt.Tunnel),this._temporaryEvaluationContainer=t,this.state.GoToStart();var n=this.state.evaluationStack.length;return this.Continue(),this._temporaryEvaluationContainer=null,this.state.callStack.elements.length>e&&this.state.PopCallStack(),n<this.state.evaluationStack.length?this.state.PopEvaluationStack():null}},{key:"CallExternalFunction",value:function(t,e){if(null===t)return gt("funcName");var n=this._externals.get(t),i=null,r=void 0!==n;if(!r||n.lookAheadSafe||null===this._stateSnapshotAtLastNewline){if(!r){if(this.allowExternalFunctionFallbacks)return i=this.KnotContainerWithName(t),this.Assert(null!==i,"Trying to call EXTERNAL function '"+t+"' which has not been bound, and fallback ink function could not be found."),this.state.callStack.Push(Nt.Function,void 0,this.state.outputStream.length),void(this.state.divertedPointer=It.StartOf(i));this.Assert(!1,"Trying to call EXTERNAL function '"+t+"' which has not been bound (and ink fallbacks disabled).")}for(var a=[],s=0;s<e;++s){var o=mt(this.state.PopEvaluationStack(),_t).valueObject;a.push(o)}a.reverse();var u=n.function(a),l=null;null!=u?(l=_t.Create(u),this.Assert(null!==l,"Could not create ink value from returned object of type "+P(u))):l=new Vt,this.state.PushEvaluationStack(l)}else this._sawLookaheadUnsafeFunctionAfterNewline=!0}},{key:"BindExternalFunctionGeneral",value:function(t,e,n){this.IfAsyncWeCant("bind an external function"),this.Assert(!this._externals.has(t),"Function '"+t+"' has already been bound."),this._externals.set(t,{function:e,lookAheadSafe:n})}},{key:"TryCoerce",value:function(t){return t}},{key:"BindExternalFunction",value:function(t,r,e){var a=this;this.Assert(null!=r,"Can't bind a null function"),this.BindExternalFunctionGeneral(t,function(t){a.Assert(t.length>=r.length,"External function expected "+r.length+" arguments");for(var e=[],n=0,i=t.length;n<i;n++)e[n]=a.TryCoerce(t[n]);return r.apply(null,e)},e)}},{key:"UnbindExternalFunction",value:function(t){this.IfAsyncWeCant("unbind an external a function"),this.Assert(this._externals.has(t),"Function '"+t+"' has not been bound."),this._externals.delete(t)}},{key:"ValidateExternalBindings",value:function(t,e){var n,i=null,r=null,a=e||new Set;if(t instanceof Ot&&(i=t),t instanceof T&&(r=t),null===i&&null===r)this.ValidateExternalBindings(this._mainContentContainer,a),this._hasValidatedExternals=!0,0==a.size?this._hasValidatedExternals=!0:(n="Error: Missing function binding for external",n+=1<a.size?"s":"",n+=": '",n+=Array.from(a).join("', '"),n+="' ",n+=this.allowExternalFunctionFallbacks?", and no fallback ink function found.":" (ink fallbacks disabled)",this.Error(n));else if(null!=i){var s,o=pt(i.content);try{for(o.s();!(s=o.n()).done;){var u=s.value;null!=u&&u.hasValidName||this.ValidateExternalBindings(u,a)}}catch(t){o.e(t)}finally{o.f()}var l,h=pt(i.namedContent);try{for(h.s();!(l=h.n()).done;){var c=S(l.value,2)[1];this.ValidateExternalBindings(yt(c,T),a)}}catch(t){h.e(t)}finally{h.f()}}else if(null!=r){var f=yt(r,xt);if(f&&f.isExternal){var v=f.targetPathString;if(null===v)return gt("name");this._externals.has(v)||this.allowExternalFunctionFallbacks&&this.mainContentContainer.namedContent.has(v)||a.add(v)}}}},{key:"ObserveVariable",value:function(t,e){if(this.IfAsyncWeCant("observe a new variable"),null===this._variableObservers&&(this._variableObservers=new Map),!this.state.variablesState.GlobalVariableExistsWithName(t))throw new Error("Cannot observe variable '"+t+"' because it wasn't declared in the ink story.");this._variableObservers.has(t)?this._variableObservers.get(t).push(e):this._variableObservers.set(t,[e])}},{key:"ObserveVariables",value:function(t,e){for(var n=0,i=t.length;n<i;n++)this.ObserveVariable(t[n],e[n])}},{key:"RemoveVariableObserver",value:function(t,e){var n;if(this.IfAsyncWeCant("remove a variable observer"),null!==this._variableObservers)if(null!=e)this._variableObservers.has(e)&&(null!=t?null!=(n=this._variableObservers.get(e))&&(n.splice(n.indexOf(t),1),0===n.length&&this._variableObservers.delete(e)):this._variableObservers.delete(e));else if(null!=t){var i,r=pt(this._variableObservers.keys());try{for(r.s();!(i=r.n()).done;){var a=i.value,s=this._variableObservers.get(a);null!=s&&(s.splice(s.indexOf(t),1),0===s.length&&this._variableObservers.delete(a))}}catch(t){r.e(t)}finally{r.f()}}}},{key:"VariableStateDidChangeEvent",value:function(t,e){if(null!==this._variableObservers){var n=this._variableObservers.get(t);if(void 0!==n){if(!(e instanceof _t))throw new Error("Tried to get the value of a variable that isn't a standard type");var i,r=mt(e,_t),a=pt(n);try{for(a.s();!(i=a.n()).done;){(0,i.value)(t,r.valueObject)}}catch(t){a.e(t)}finally{a.f()}}}}},{key:"globalTags",get:function(){return this.TagsAtStartOfFlowContainerWithPathString("")}},{key:"TagsForContentAtPath",value:function(t){return this.TagsAtStartOfFlowContainerWithPathString(t)}},{key:"TagsAtStartOfFlowContainerWithPathString",value:function(t){var e=new O(t),n=this.ContentAtPath(e).container;if(null===n)return gt("flowContainer");for(;;){var i=n.content[0];if(!(i instanceof Ot))break;n=i}var r,a=null,s=pt(n.content);try{for(s.s();!(r=s.n()).done;){var o=yt(r.value,J);if(!o)break;null==a&&(a=[]),a.push(o.text)}}catch(t){s.e(t)}finally{s.f()}return a}},{key:"BuildStringOfHierarchy",value:function(){var t=new St;return this.mainContentContainer.BuildStringOfHierarchy(t,0,this.state.currentPointer.Resolve()),t.toString()}},{key:"BuildStringOfContainer",value:function(t){var e=new St;return t.BuildStringOfHierarchy(e,0,this.state.currentPointer.Resolve()),e.toString()}},{key:"NextContent",value:function(){var t;this.state.previousPointer=this.state.currentPointer.copy(),(this.state.divertedPointer.isNull||(this.state.currentPointer=this.state.divertedPointer.copy(),this.state.divertedPointer=It.Null,this.VisitChangedContainersDueToDivert(),this.state.currentPointer.isNull))&&(this.IncrementContentPointer()||(t=!1,this.state.callStack.CanPop(Nt.Function)?(this.state.PopCallStack(Nt.Function),this.state.inExpressionEvaluation&&this.state.PushEvaluationStack(new Vt),t=!0):this.state.callStack.canPopThread?(this.state.callStack.PopThread(),t=!0):this.state.TryExitFunctionEvaluationFromGame(),t&&!this.state.currentPointer.isNull&&this.NextContent()))}},{key:"IncrementContentPointer",value:function(){var t=!0,e=this.state.callStack.currentElement.currentPointer.copy();if(e.index++,null===e.container)return gt("pointer.container");for(;e.index>=e.container.content.length;){t=!1;var n=yt(e.container.parent,Ot);if(n instanceof Ot==!1)break;var i=n.content.indexOf(e.container);if(-1==i)break;if((e=new It(n,i)).index++,t=!0,null===e.container)return gt("pointer.container")}return t||(e=It.Null),this.state.callStack.currentElement.currentPointer=e.copy(),t}},{key:"TryFollowDefaultInvisibleChoice",value:function(){var t=this._state.currentChoices,e=t.filter(function(t){return t.isInvisibleDefault});if(0==e.length||t.length>e.length)return!1;var n=e[0];return null===n.targetPath?gt("choice.targetPath"):null===n.threadAtGeneration?gt("choice.threadAtGeneration"):(this.state.callStack.currentThread=n.threadAtGeneration,null!==this._stateSnapshotAtLastNewline&&(this.state.callStack.currentThread=this.state.callStack.ForkThread()),this.ChoosePath(n.targetPath,!1),!0)}},{key:"NextSequenceShuffleIndex",value:function(){var t=yt(this.state.PopEvaluationStack(),wt);if(!(t instanceof wt))return this.Error("expected number of elements in sequence for shuffle index"),0;var e=this.state.currentPointer.container;if(null===e)return gt("seqContainer");if(null===t.value)return gt("numElementsIntVal.value");var n=t.value,i=mt(this.state.PopEvaluationStack(),wt).value;if(null===i)return gt("seqCount");for(var r=i/n,a=i%n,s=e.path.toString(),o=0,u=0,l=s.length;u<l;u++)o+=s.charCodeAt(u)||0;for(var h=o+r+this.state.storySeed,c=new Rt(Math.floor(h)),f=[],v=0;v<n;++v)f.push(v);for(var d=0;d<=a;++d){var p=c.next()%f.length,y=f[p];if(f.splice(p,1),d==a)return y}throw new Error("Should never reach here")}},{key:"Error",value:function(t,e){var n=1<arguments.length&&void 0!==e&&e,i=new bt(t);throw i.useEndLineNumber=n,i}},{key:"Warning",value:function(t){this.AddError(t,!0)}},{key:"AddError",value:function(t,e,n){var i,r=1<arguments.length&&void 0!==e&&e,a=2<arguments.length&&void 0!==n&&n,s=this.currentDebugMetadata,o=r?"WARNING":"ERROR";t=null!=s?(i=a?s.endLineNumber:s.startLineNumber,"RUNTIME "+o+": '"+s.fileName+"' line "+i+": "+t):this.state.currentPointer.isNull?"RUNTIME "+o+": "+t:"RUNTIME "+o+": ("+this.state.currentPointer+"): "+t,this.state.AddError(t,r),r||this.state.ForceEnd()}},{key:"Assert",value:function(t,e){var n=1<arguments.length&&void 0!==e?e:null;if(0==t)throw null==n&&(n="Story assert"),new Error(n+" "+this.currentDebugMetadata)}},{key:"currentDebugMetadata",get:function(){var t=this.state.currentPointer;if(!t.isNull&&null!==t.Resolve()&&null!==(n=t.Resolve().debugMetadata))return n;for(var e=this.state.callStack.elements.length-1;0<=e;--e)if(!(t=this.state.callStack.elements[e].currentPointer).isNull&&null!==t.Resolve()&&null!==(n=t.Resolve().debugMetadata))return n;for(var n,i=this.state.outputStream.length-1;0<=i;--i){if(null!==(n=this.state.outputStream[i].debugMetadata))return n}return null}},{key:"mainContentContainer",get:function(){return this._temporaryEvaluationContainer?this._temporaryEvaluationContainer:this._mainContentContainer}}]),f}(),a.Story.inkVersionCurrent=20,tt=a.Story||(a.Story={}),(et=tt.OutputStateChange||(tt.OutputStateChange={}))[et.NoChange=0]="NoChange",et[et.ExtendedBeyondNewline=1]="ExtendedBeyondNewline",et[et.NewlineRemoved=2]="NewlineRemoved",a.InkList=Ct,Object.defineProperty(a,"__esModule",{value:!0})});
//# sourceMappingURL=ink.js.map

    </script>
    <script data-editor-only="data-editor-only">class IndexedItemPool {
    constructor({ create, dispose }) {
        this.create = create;
        this.dispose = dispose;
        this.items = [];
    }

    setCount(count) {
        const missing = count - this.items.length;

        if (missing < 0) {
            const excess = this.items.splice(missing, -missing);
            excess.forEach((item) => this.dispose(item));
        } else if (missing > 0) {
            for (let i = 0; i < missing; ++i) {
                const item = this.create();
                this.items.push(item);
            }
        }
    }

    map(data, callback) {
        this.setCount(data.length);
        for (let i = 0; i < data.length; ++i) {
            callback(data[i], this.items[i], i);
        }
    }
}

    </script>
    <script data-editor-only="data-editor-only">const TEMP_TILESET0 = createRendering2D(1, 1);

function makeBlankRoom(id) {
    return {
        id,
        palette: 0,
        tilemap: ZEROES(16).map(() => REPEAT(16, 0)),
        backmap: ZEROES(16).map(() => REPEAT(16, 0)),
        foremap: ZEROES(16).map(() => REPEAT(16, 1)),
        wallmap: ZEROES(16).map(() => REPEAT(16, 0)),
        events: [],
    }
}

function generateGrid(width, height, gap) {
    const rendering = createRendering2D(width, height);

    for (let y = 0; y <= (height / gap); ++y) {
        rendering.fillRect(0, y * gap - 1, width, 2);
    }
    for (let x = 0; x <= (width / gap); ++x) {
        rendering.fillRect(x * gap - 1, 0, 2, height);
    }

    return rendering;
}

const TILE_GRID = generateGrid(160, 160, 20);
const ROOM_GRID = generateGrid(256, 256, 16);

/** 
 * Update the given bipsi project data so that it's valid for this current
 * version of bipsi.
 * @param {BipsiDataProject} project 
 */
function updateProject(project) {
    const locationFields = 
        allEvents(project)
        .flatMap((event) => event.fields)
        .filter((field) => field.type === "location");
    
    const repairLocations = !locationFields.every((location) => getRoomById(project, location.data.room));

    project.rooms.forEach((room) => {
        room.backmap = room.backmap ?? ZEROES(16).map(() => REPEAT(16, 0));
        room.foremap = room.foremap ?? ZEROES(16).map(() => REPEAT(16, 1));
        
        if (room.highmap) {
            for (let y = 0; y < 16; ++y) {
                for (let x = 0; x < 16; ++x) {
                    const high = room.highmap[y][x];

                    if (high > 0) {
                        room.tilemap[y][x] = high;
                        room.foremap[y][x] = 2;           
                    }
                }
            }
        }

        room.id = room.id ?? nextRoomId(project);
    });

    if (repairLocations) {
        locationFields.forEach((field) => {
            field.data.room = project.rooms[field.data.room]?.id ?? project.rooms[0].id;
        });
    }

    project.rooms.forEach((room) => room.events.forEach((event) => {
        event.id = event.id ?? nextEventId(project);
        event.fields = event.fields ?? [];
        event.fields = event.fields.filter((field) => field !== null);
    }));
}

function generateColorWheel(width, height) {
    const rendering = createRendering2D(width, height);
    withPixels(rendering, (pixels) => {
        const radius = width * .5;

        for (let y = 0; y < height; ++y) {
            for (let x = 0; x < width; ++x) {
                const [dx, dy] = [x - radius, y - radius];
                const h = (Math.atan2(dy, dx) / (Math.PI * 2) + 1) % 1;
                const s = Math.sqrt(dx*dx + dy*dy) / radius;

                const color = s > 1 ? 0 : RGBToUint32(HSVToRGB({ h, s, v: 1 }));
                pixels[y * width + x] = color;
            }
        }
    });
    return rendering;
}

/**
 * @param {CanvasRenderingContext2D} rendering 
 * @param {string[]} palette 
 * @param {BipsiDataRoom} room 
 */
 function drawRoomThumbnail(rendering, palette, room) {
    const [background, foreground, highlight] = palette;
    for (let y = 0; y < 16; ++y) {
        for (let x = 0; x < 16; ++x) {
            const color = room.wallmap[y][x] === 1 ? foreground : background;
            rendering.fillStyle = color;
            rendering.fillRect(x, y, 1, 1);
        }
    }

    rendering.fillStyle = highlight;
    room.events.forEach((event) => {
        const [x, y] = event.position;
        rendering.fillRect(x, y, 1, 1);
    });
}

class PaletteEditor {
    /**
     * @param {BipsiEditor} editor 
     */
    constructor(editor) {
        this.editor = editor;

        this.temporary = { h: 0, s: 0, v: 0, hex: "#000000" };
        this.temporary = undefined;

        /** @type {HTMLCanvasElement} */
        this.colorHueSat = ONE("#color-huesat");
        this.colorHueSatRendering = this.colorHueSat.getContext("2d");

        this.colorWheelGraphic = generateColorWheel(
            this.colorHueSat.width,
            this.colorHueSat.height,
        ).canvas;

        const margin = constants.colorwheelMargin;
        this.colorHueSat.style.setProperty("margin", `-${margin}px`);
        this.colorHueSat.width += margin * 2;
        this.colorHueSat.height += margin * 2;

        this.colorSelect = ui.radio("color-select");
        this.colorValue = ui.slider("color-value");
        this.colorHex = ui.text("color-hex");

        this.colorSelect.selectedIndex = 0;

        this.colorSelect.addEventListener("change", () => {
            this.updateTemporaryFromData();
            this.refreshDisplay();
        });

        this.colorValue.addEventListener("input", () => {
            const { color } = this.getSelections();

            color.v = this.colorValue.valueAsNumber;
            this.updateTemporaryFromHSV();
            this.refreshDisplay();
        });

        this.colorValue.addEventListener("change", () => {
            this.commitSelectedColorFromTemporary();
        });

        this.colorHex.addEventListener("change", () => {
            this.temporary.hex = this.colorHex.value;
            this.updateTemporaryFromHex();
            this.commitSelectedColorFromTemporary();
        });

        this.colorHex.addEventListener("paste", () => {
            setTimeout(() => {
                this.temporary.hex = this.colorHex.value;
                this.updateTemporaryFromHex();
                this.refreshDisplay();
            }, 0);
        });

        this.colorHueSat.addEventListener("pointerdown", (event) => {
            const drag = ui.drag(event);

            /** @param {PointerEvent} event */
            const update = (event) => {
                const { x, y } = mouseEventToCanvasPixelCoords(this.colorHueSat, event);
                
                const center = this.colorHueSat.width / 2;
                const [dx, dy] = [x - center, y - center];
                this.temporary.h = (Math.atan2(dy, dx) / (Math.PI * 2) + 1) % 1;
                this.temporary.s = Math.min(Math.sqrt(dx*dx + dy*dy) / (center-margin), 1);
                this.updateTemporaryFromHSV();
                this.refreshDisplay();
            };

            update(event);

            drag.addEventListener("move", (event) => {
                update(event.detail);
            });
            drag.addEventListener("up", (event) => {
                update(event.detail);
                this.commitSelectedColorFromTemporary();
            });
        });
    }

    async init() {
    }

    /**
     * @param {BipsiDataProject} data 
     * @returns 
     */
    getSelections(data = undefined) {
        data = data ?? this.editor.stateManager.present;
        const [paletteIndex, colorIndex] = this.colorSelect.value.split(",").map((v) => parseInt(v, 10));
        const palette = this.editor.stateManager.present.palettes[paletteIndex];
        const dataHex = palette[colorIndex];

        return { data, palette, colorIndex, color: this.temporary, dataHex };
    }

    getPreviewPalette() {
        const { color, palette, colorIndex } = this.getSelections();
        const previewPalette = [ ...palette ];
        previewPalette[colorIndex] = color.hex;
        return previewPalette;
    }

    refreshDisplay() {
        if (this.temporary === undefined) this.updateTemporaryFromData();

        const { data, color, palette } = this.getSelections();

        // recolor the color select buttons to the corresponding color
        ALL("#color-select .horizontal-capsule").forEach((capsule, y) => {
            ALL("label", capsule).forEach((label, x) => {
                label.style.background = data.palettes[y][x];
            });
        });

        // color wheel:
        const margin = constants.colorwheelMargin;
        // 1. clear
        fillRendering2D(this.colorHueSatRendering);
        // 2. base wheel at full value
        this.colorHueSatRendering.globalCompositeOperation = "source-over";
        this.colorHueSatRendering.drawImage(this.colorWheelGraphic, margin, margin);
        // 3. multiply with target value
        this.colorHueSatRendering.globalCompositeOperation = "multiply";
        const valueHex = rgbToHex({ r: color.v * 255, g: color.v * 255, b: color.v * 255 });
        fillRendering2D(this.colorHueSatRendering, valueHex);
        // 4. cut off fill edges with wheel shape
        this.colorHueSatRendering.globalCompositeOperation = "destination-in";
        this.colorHueSatRendering.drawImage(this.colorWheelGraphic, margin, margin);

        const center = this.colorHueSat.width / 2;
        const width = this.colorHueSat.width - margin * 2;
        const angle = color.h * Math.PI * 2;
        const radius = color.s * width * .5;
        this.colorHueSatRendering.globalCompositeOperation = "source-over";
        this.colorHueSatRendering.beginPath();
        this.colorHueSatRendering.arc(
            center + radius * Math.cos(angle), 
            center + radius * Math.sin(angle), 
            8, 0, 2 * Math.PI,
        );
        this.colorHueSatRendering.strokeStyle = "black";
        this.colorHueSatRendering.lineWidth = 3;
        this.colorHueSatRendering.fillStyle = color.hex;
        this.colorHueSatRendering.fill();
        this.colorHueSatRendering.stroke();

        this.colorValue.valueAsNumber = color.v;
        this.colorHex.value = color.hex;
        this.colorSelect.selectedInput.style.setProperty("background", color.hex);

        this.editor.redraw();
    }

    updateTemporaryFromData() {
        const { dataHex } = this.getSelections();
        this.temporary = { hex: dataHex };
        this.updateTemporaryFromHex();
    }

    updateTemporaryFromHex() {
        this.temporary = { 
            hex: this.temporary.hex, 
            ...RGBToHSV(hexToRGB(this.temporary.hex)),
        };
    }

    updateTemporaryFromHSV() {
        this.temporary.hex = rgbToHex(HSVToRGB(this.temporary));
    }

    commitSelectedColorFromTemporary() {


        this.editor.stateManager.makeChange(async (data) => {
            const { palette, colorIndex, color } = this.getSelections(data);
    
            // TODO undoability
            palette[colorIndex] = color.hex;
        });

        this.refreshDisplay();
    }
}

const FIELD_DEFAULTS = {
    tag: true,
    tile: 0,
    dialogue: "",
    location: { room: 0, position: [0, 0] },
    javascript: "",
    json: "",
    text: "",
};

class EventFieldEditor extends EventTarget {
    /**
     * @param {EventEditor} eventEditor 
     * @param {HTMLElement} fieldElement
     */
    constructor(eventEditor, fieldElement) {
        super();

        this.eventEditor = eventEditor;
        this.fieldElement = fieldElement;

        this.nameInput = ONE('input[name="field-name"]', fieldElement);
        this.typeSelect = ONE('select[name="field-type"]', fieldElement);

        this.nameInput.onchange = () => this.changed();
        this.typeSelect.onchange = () => this.changed();
    }

    changed() {
        this.dispatchEvent(new CustomEvent("change"));
    }

    setActive(value) {
        this.fieldElement.classList.toggle("active", value);
    }

    getData() {
        return { 
            key: this.nameInput.value,
            type: this.typeSelect.value 
        };
    }

    pushData(field) {
        this.nameInput.value = field.key;
        this.typeSelect.value = field.type;
    }

    pullData(field) {
        const { key, type } = this.getData();
        field.key = key;
        if (field.type !== type) {
            field.data = FIELD_DEFAULTS[type];
        }
        field.type = type;
    }
}

const EVENT_TEMPLATES = {
    empty: [],
    exit: [
        { key: "exit", type: "location", data: { room: 0, position: [0, 0] } },
    ],
    message: [
        { key: "say", type: "dialogue", data: "hello" },
        { key: "one-time", type: "tag", data: true },
    ],
    character: [
        { key: "graphic", type: "tile", data: 0 },
        { key: "solid", type: "tag", data: true },
        { key: "say", type: "dialogue", data: "hello" },
    ],
    ending: [
        { key: "ending", type: "dialogue", data: "goodbye"},
    ],
    player: [
        { key: "is-player", type: "tag", data: true },
        { key: "graphic", type: "tile", data: 0 },
        { key: "title", type: "dialogue", data: "your game title" },
        { key: "page-color", type: "text", data: "black" },
    ],
    code: [
        { key: "touch", type: "javascript", data: "await DO_STANDARD();" },
    ],
};

function prepareTemplate(element) {
    const clone = element.cloneNode(true);
    clone.removeAttribute("id");
    clone.hidden = false;

    return {
        parent: element.parentElement,
        element: clone,
    }
}

class EventEditor {
    /**
     * @param {BipsiEditor} editor 
     */
    constructor(editor) {
        this.editor = editor;

        const { parent, element } = prepareTemplate(ONE("#event-field-template"));
        this.fieldContainer = parent;
        this.fieldTemplate = element; 

        this.fieldEditors = [];

        this.selectedIndex = 0;

        ui.action("field-file-select", async () => {
            const [file] = await maker.pickFiles();
            if (file) {
                await this.editor.stateManager.makeChange(async (data) => {
                    const { field } = this.getSelections(data);
                    field.data = this.editor.stateManager.resources.add(file, "file-datauri");
                });
            }
        });
        this.fileInfo = ONE("#field-file-info");

        ui.action("create-event-empty", () => this.editor.createEvent(EVENT_TEMPLATES.empty));
        ui.action("create-event-code", () => this.editor.createEvent(EVENT_TEMPLATES.code));
        ui.action("create-event-exit", () => this.editor.createEvent(EVENT_TEMPLATES.exit));
        ui.action("create-event-message", () => this.editor.createEvent(EVENT_TEMPLATES.message));
        ui.action("create-event-character", () => this.editor.createEvent(EVENT_TEMPLATES.character));
        ui.action("create-event-ending", () => this.editor.createEvent(EVENT_TEMPLATES.ending));
        ui.action("create-event-player", () => {
            const avatar = allEvents(this.editor.stateManager.present).find((event) => eventIsTagged(event, "is-player"));

            this.editor.createEvent(avatar?.fields ?? EVENT_TEMPLATES.player);
            
            if (avatar) {
                this.editor.stateManager.makeChange(async (data) => {
                    const room = roomFromEvent(data, avatar);
                    arrayDiscard(room.events, avatar);
                });
            }
        });

        this.actions = {
            add: ui.action("add-event-field", () => this.addField()),
            duplicate: ui.action("duplicate-event-field", () => this.duplicateField()),
            shiftUp: ui.action("shift-up-event-field", () => this.shiftField(-1)),
            shiftDown: ui.action("shift-down-event-field", () => this.shiftField(1)),
            delete: ui.action("remove-event-field", () => this.removeField()),
        }

        this.eventEmptyElement = ONE("#event-empty");
        this.eventPropertiesElement = ONE("#event-properties");
        this.valueEditors = {
            json: ONE("#field-json-editor textarea"),
            dialogue: ONE("#field-dialogue-editor textarea"),
        };

        this.positionSelect = ONE("#field-position-select");
        this.positionSelectRendering = this.positionSelect.getContext("2d");

        this.dialoguePreviewToggle = ui.toggle("show-dialogue-preview");
        this.dialoguePreviewToggle.addEventListener("change", () => {
            this.resetDialoguePreview();
        });

        this.valueEditors.json.addEventListener("change", () => {
            this.editor.stateManager.makeChange(async (data) => {
                const { field } = this.getSelections(data);

                if (field.type === "json") {
                    field.data = JSON.parse(this.valueEditors.json.value);
                } else {
                    field.data = this.valueEditors.json.value;
                }
            });
        });

        this.valueEditors.dialogue.addEventListener("change", () => {
            this.editor.stateManager.makeChange(async (data) => {
                const { field } = this.getSelections(data);
                field.data = this.valueEditors.dialogue.value;
            });
        });

        this.valueEditors.dialogue.addEventListener("input", () => {
            this.resetDialoguePreview();
            this.editor.dialoguePreviewPlayer.skip();
        });

        this.editor.eventTileBrowser.select.addEventListener("change", () => {
            this.editor.stateManager.makeChange(async (data) => {
                const { field } = this.getSelections(data);
                field.data = data.tiles[this.editor.eventTileBrowser.selectedTileIndex].id;
            });
        });

        this.editor.fieldRoomSelect.select.addEventListener("change", () => {
            const id = this.editor.fieldRoomSelect.select.valueAsNumber;
            const index = this.editor.stateManager.present.rooms.findIndex((room) => room.id === id);

            const { field } = this.getSelections();
            const position = field.data.room === id ? field.data.position : undefined;

            this.refreshPositionSelect(index, position);
        });

        this.positionSelect.addEventListener("click", (event) => {
            const { x, y } = mouseEventToCanvasPixelCoords(this.positionSelect, event);
            const tx = Math.floor(x / 8);
            const ty = Math.floor(y / 8);
            this.editor.stateManager.makeChange(async (data) => {
                const { field } = this.getSelections(data);
                field.data.room = this.editor.fieldRoomSelect.select.valueAsNumber;
                field.data.position = [tx, ty];
            });
        });
    }

    get showDialoguePreview() {
        const { field } = this.getSelections();

        return this.editor.modeSelect.value === "events"
            && field?.type === "dialogue"
            && this.dialoguePreviewToggle.checked;
    }

    resetDialoguePreview() {
        const { field, event } = this.getSelections();

        const page = !this.editor.dialoguePreviewPlayer.empty ? this.editor.dialoguePreviewPlayer.pagesSeen : 0;
        const style = event ? oneField(event, "say-style", "json")?.data : undefined;

        this.editor.dialoguePreviewPlayer.clear();
        if (field && field.type === "dialogue") {
            this.editor.dialoguePreviewPlayer.queue(this.valueEditors.dialogue.value, style);
            for (let i = 0; i < page-1; ++i) {
                this.editor.dialoguePreviewPlayer.moveToNextPage();
            }
        }
        this.editor.redraw();
    }

    /**
     * @param {BipsiDataProject} data 
     */
    getSelections(data = undefined) {
        data = data ?? this.editor.stateManager.present;
        const { event } = this.editor.getSelections(data);
        const fieldIndex = this.selectedIndex;
        const field = event?.fields[fieldIndex];

        return { event, field, fieldIndex };
    }

    refresh() {
        const { event, field, fieldIndex } = this.getSelections();
        const data = this.editor.stateManager.present;

        if (event) {
            this.updateFieldCount(event.fields.length);
            this.fieldEditors.forEach((editor, index) => {
                editor.setActive(index === fieldIndex);
                editor.pushData(event.fields[index]);
            });
            this.eventEmptyElement.hidden = true;
            this.eventPropertiesElement.hidden = false;

            ONE("#field-json-editor").hidden = true;
            ONE("#field-dialogue-editor").hidden = true;
            ONE("#field-tile-editor").hidden = true;
            ONE("#field-location-editor").hidden = true;
            ONE("#field-file-editor").hidden = true;

            if (field) {
                if (field.type === "tag") {
                } else if (field.type === "file") {
                    ONE("#field-file-editor").hidden = false;

                    if (field.data) {
                        const file = this.editor.stateManager.resources.get(field.data);
                        this.fileInfo.value = `${file.name} (${file.type})`;
                    } else {
                        this.fileInfo.value = "[ NO FILE ]";
                    }
                } else if (field.type === "dialogue") {
                    this.valueEditors.dialogue.value = field.data;
                    ONE("#field-dialogue-editor").hidden = false;
                } else if (field.type === "tile") {
                    ONE("#field-tile-editor").hidden = false;
                    const index = this.editor.stateManager.present.tiles.findIndex((tile) => tile.id === field.data);
                    this.editor.eventTileBrowser.selectedTileIndex = index;
                } else if (field.type === "location") {
                    ONE("#field-location-editor").hidden = false;
                    let index = data.rooms.findIndex((room) => room.id == field.data.room);

                    if (index === -1) {
                        console.log("BAD LOCATION ROOM")
                        return;
                    }

                    this.editor.fieldRoomSelect.select.selectedIndex = index;
                    this.refreshPositionSelect(index, field.data.position);
                } else if (field.type === "json") {
                    this.valueEditors.json.value = JSON.stringify(field.data);
                    ONE("#field-json-editor").hidden = false;
                } else {
                    this.valueEditors.json.value = field.data;
                    ONE("#field-json-editor").hidden = false;
                }
            }
        } else {
            this.updateFieldCount(0);
            this.eventEmptyElement.hidden = false;
            this.eventPropertiesElement.hidden = true;
        }

        this.resetDialoguePreview();
    }

    refreshPositionSelect(index, position = undefined) {
        this.positionSelectRendering.globalCompositeOperation = "source-over";
        this.editor.drawRoom(this.positionSelectRendering, index);

        if (position) {
            const [x, y] = position; 
            this.positionSelectRendering.globalCompositeOperation = "difference"
            this.positionSelectRendering.fillStyle = "white";
            this.positionSelectRendering.fillRect(0, y * 8+2, 128, 4);
            this.positionSelectRendering.fillRect(x * 8+2, 0, 4, 128);
        }
    }

    setSelectedIndex(index) {
        this.selectedIndex = index;
        this.refresh();
    }

    updateFieldCount(count) {
        const missing = count - this.fieldEditors.length;

        if (missing < 0) {
            const excess = this.fieldEditors.splice(missing, -missing);
            excess.forEach((editor) => editor.fieldElement.remove());
        } else if (missing > 0) {
            const extras = ZEROES(missing).map((_, i) => {
                const index = this.fieldEditors.length + i;
                const fieldElement = this.fieldTemplate.cloneNode(true);
                const fieldEditor = new EventFieldEditor(this, fieldElement);

                // has to be click so that refresh doesn't overwrite input
                // before change..
                fieldElement.onclick = () => this.setSelectedIndex(index);

                fieldEditor.addEventListener("change", () => {
                    this.editor.stateManager.makeChange(async (data) => {
                        const { field } = this.getSelections(data);
                        fieldEditor.pullData(field);
                        // TODO: convert data on type change..
                    });
                });

                return fieldEditor;
            });

            this.fieldContainer.append(...extras.map((field) => field.fieldElement));
            this.fieldEditors.push(...extras);
        }

        this.selectedIndex = Math.min(this.selectedIndex, count - 1);

        if (this.selectedIndex === -1) {
            this.selectedIndex = 0;
        }
    }

    async addField() {
        this.editor.stateManager.makeChange(async (data) => {
            const { event } = this.getSelections(data);
            event.fields.push({ key: "new field", type: "text", data: "" });
            this.setSelectedIndex(event.fields.length - 1);
        });
    }

    async duplicateField() {
        this.editor.stateManager.makeChange(async (data) => {
            const { event, fieldIndex } = this.getSelections(data);
            const copy = COPY(event.fields[fieldIndex]);
            event.fields.splice(fieldIndex, 0, copy);
            this.setSelectedIndex(fieldIndex+1);
        });
    }

    async shiftField(di) {
        this.editor.stateManager.makeChange(async (data) => {
            const { event, fieldIndex } = this.getSelections(data);
            const prev = fieldIndex;
            const next = Math.max(0, Math.min(fieldIndex + di, event.fields.length));
            
            if (event.fields[prev] === undefined || event.fields[next] === undefined) {
                return;
            }

            const temp = event.fields[prev];
            event.fields[prev] = event.fields[next];
            event.fields[next] = temp;

            this.setSelectedIndex(next);
        });
    }

    async removeField() {
        this.editor.stateManager.makeChange(async (data) => {
            const { event, fieldIndex } = this.getSelections(data);
            event.fields.splice(fieldIndex, 1);
        });
    }
}

class TileEditor {
    /**
     * @param {BipsiEditor} editor 
     */
    constructor(editor) {
        this.editor = editor;

        const tile0 = this.editor.renderings.tilePaint0;
        const tile1 = this.editor.renderings.tilePaint1;

        tile0.canvas.addEventListener("pointerdown", (event) => this.startDrag(event, 0));
        tile1.canvas.addEventListener("pointerdown", (event) => this.startDrag(event, 1));

        this.animateToggle = ui.toggle("tile-animated");
        this.animateToggle.addEventListener("change", () => {
            this.editor.toggleTileAnimated();
        });
    }

    async startDrag(event, frameIndex) {
        const rendering = [
            this.editor.renderings.tilePaint0,
            this.editor.renderings.tilePaint1,
        ][frameIndex];

        const { tile } = this.editor.getSelections();
 
        this.editor.stateManager.makeCheckpoint();
        const tileset = await this.editor.forkTileset();

        const index = tile.frames[frameIndex] ?? tile.frames[0];
        const temp = copyTile(tileset, index);

        const redraw = () => {
            drawTile(tileset, index, temp);
            this.redraw();
        };

        const drag = ui.drag(event);
        const positions = trackCanvasStroke(rendering.canvas, drag);

        const round = (position) => {
            return {
                x: Math.floor(position.x / 20),
                y: Math.floor(position.y / 20),
            };
        };

        // "brush" is a single pixel which is either transparent or white,
        // whichever the existing pixel isn't
        const { x, y } = round(positions[0]);
        const brush = temp.getImageData(x, y, 1, 1);
        const value = brush.data[3] === 0 ? 255 : 0;
        brush.data[0] = value;
        brush.data[1] = value;
        brush.data[2] = value;
        brush.data[3] = value;

        const plot = (x, y) => temp.putImageData(brush, x, y);

        plot(x, y);
        redraw();

        drag.addEventListener("move", () => {
            const { x: x0, y: y0 } = round(positions[positions.length - 2]);
            const { x: x1, y: y1 } = round(positions[positions.length - 1]);
            lineplot(x0, y0, x1, y1, plot);
            redraw();
        });

        drag.addEventListener("up", () => {
            const { x, y } = round(positions[positions.length - 1]);
            plot(x, y);
            redraw();
            this.editor.stateManager.changed();
        });
    }

    redraw() {
        const { data, tileset, room, tile } = this.editor.getSelections();
        if (!tile) return;

        this.editor.tileEditor.animateToggle.setCheckedSilent(tile.frames.length > 1);

        const [bg, fg, hi] = data.palettes[room.palette];

        const color = this.editor.roomPaintTool.selectedIndex === 1 ? hi : fg;
        const tilesetC = recolorMask(tileset, color);

        const grid = this.editor.tileGrid.checked;

        [this.editor.renderings.tilePaint0, this.editor.renderings.tilePaint1].forEach((rendering, i) => {
            fillRendering2D(rendering, bg);
            const frameIndex = tile.frames[i] ?? tile.frames[0];
            const { x, y, size } = getTileCoords(tileset.canvas, frameIndex);
            rendering.drawImage(
                tilesetC.canvas,
                x, y, size, size,
                0, 0, size * 20, size * 20,
            );

            if (grid) {
                rendering.globalAlpha = .25;
                rendering.drawImage(TILE_GRID.canvas, 0, 0);
                rendering.globalAlpha = 1;
            }
        });

        this.editor.renderings.tilePaintA.drawImage(
            [this.editor.renderings.tilePaint0, this.editor.renderings.tilePaint1][this.editor.frame].canvas,
            0, 0, 8, 8,
        );
    }
}

class BipsiEditor extends EventTarget {
    /**
     * Setup most of the stuff for the bipsi editor (the rest is in init
     * because constructors can't be async). This includes finding the existing
     * HTML UI so it doesn't really make sense to construct this more than once
     * but a class is easy syntax for wrapping functions and state together 
     */
    constructor(font) {
        super();

        // are there changes to warn about losing?
        this.unsavedChanges = false;

        // is there a fully loaded project?
        this.ready = false;

        // to determine which resources are still in use for the project we
        // combine everything the bipsi needs plus anything this editor
        // needs
        const getEditorManifest = (data) => [...getManifest(data), ...this.getManifest()];

        /** @type {maker.StateManager<BipsiDataProject>} */
        this.stateManager = new maker.StateManager(getEditorManifest);

        /** @type {Object.<string, CanvasRenderingContext2D>} */
        this.renderings = {
            tilePaint0: ONE("#tile-paint-0").getContext("2d"),
            tilePaint1: ONE("#tile-paint-1").getContext("2d"),
            tilePaintA: ONE("#tile-paint-a").getContext("2d"),

            tileMapPaint: ONE("#tile-map-paint").getContext("2d"),
            tilePaintRoom: ONE("#tile-paint-room").getContext("2d"),
            paletteRoom: ONE("#palette-room").getContext("2d"),
            eventsRoom: ONE("#events-room").getContext("2d"),

            playtest: ONE("#playtest-rendering").getContext("2d"),
        };

        this.roomSelect = new RoomSelect("room-select", ONE("#room-select-template"));
        this.fieldRoomSelect = new RoomSelect("field-room-select", ONE("#field-room-select-template"));
        this.eventsRoomSelect = new RoomSelect("events-room-select", ONE("#events-room-select-template"));

        this.eventsRoomSelectWindow = ONE("#events-room-select-window");
        this.eventsRoomSelectToggle = ui.toggle("events-switch-room");

        this.eventsRoomSelectToggle.addEventListener("change", () => {
            this.eventsRoomSelectWindow.hidden = !this.eventsRoomSelectToggle.checked;
        });

        this.eventsRoomSelect.select.addEventListener("change", () => {
            this.roomSelect.select.selectedIndex = this.eventsRoomSelect.select.selectedIndex;
            //this.eventsRoomSelectToggle.checked = false;
        });

        window.addEventListener("click", (event) => {
            const ignore = !event.isTrusted
                        || this.eventsRoomSelectWindow.contains(event.target)
                        || ONE("#room-picker-toggle").contains(event.target);
            if (ignore) return;
            this.eventsRoomSelectToggle.checked = false;
        });

        Object.values(this.renderings).forEach((rendering) => rendering.imageSmoothingEnabled = false);

        this.tileBrowser = new TileBrowser(this, "tile-select", ONE("#tile-select-template"));
        this.eventTileBrowser = new EventTileBrowser(this, "field-tile-select", ONE("#field-tile-select-template"));

        this.tileEditor = new TileEditor(this);
        this.paletteEditor = new PaletteEditor(this);
        this.eventEditor = new EventEditor(this);

        //this.palettePicker = new PalettePicker();

        this.font = font;
        this.dialoguePreviewPlayer = new DialoguePlayback(256, 256);
        this.dialoguePreviewPlayer.options.font = font;

        let prev;
        const timer = (next) => {
            window.requestAnimationFrame(timer);
            if (!this.ready) return;

            prev = prev ?? Date.now();
            next = next ?? Date.now();
            const dt = Math.max(0, (next - prev) / 1000.);
            prev = next;
            this.dialoguePreviewPlayer.update(dt);
            this.redrawDialoguePreview();
        }
        timer();

        // find all the ui already defined in the html
        this.modeSelect = ui.radio("mode-select");
        //this.roomSelect = ui.radio("room-select");
        this.roomPaintTool = ui.radio("room-paint-tool");
        this.roomPaletteSelect = ui.select("room-palette");
        this.tilePaintFrameSelect = ui.radio("tile-paint-frame");

        this.modeSelect.tab(ONE("#event-edit"), "events");
        this.modeSelect.tab(ONE("#room-events-tab"), "events");

        this.modeSelect.tab(ONE("#palette-edit"), "palettes");
        
        this.modeSelect.tab(ONE("#room-select-tab"), "draw-room");
        this.modeSelect.tab(ONE("#tile-select-tab"), "draw-room", "draw-tiles");

        this.modeSelect.tab(ONE("#tile-buttons"), "draw-tiles")
        this.modeSelect.tab(ONE("#tile-paint-tab"), "draw-tiles");
        this.modeSelect.tab(ONE("#tile-map-tab"), "draw-room");
        this.modeSelect.tab(ONE("#palette-tab"), "palettes");

        this.modeSelect.tab(ONE("#play-tab-body"), "playtest");
        this.modeSelect.tab(ONE("#play-tab-view"), "playtest");

        this.roomGrid = ui.toggle("room-grid");
        this.roomGrid.addEventListener("change", () => this.redraw());

        this.tileGrid = ui.toggle("tile-grid");
        this.tileGrid.addEventListener("change", () => this.redraw());

        // initial selections
        this.modeSelect.selectedIndex = 0;
        this.roomPaintTool.selectedIndex = 0; 
        this.tilePaintFrameSelect.selectedIndex = 0;

        this.selectedEventCell = { x: 0, y: 0 };
        this.selectedEventId = undefined;

        this.tilePaintFrameSelect.addEventListener("change", () => {
            const { tile } = this.getSelections();
            if (this.tilePaintFrameSelect.selectedIndex === 1 && tile.frames.length === 1) {
                this.toggleTileAnimated();
            }
        });

        // editor actions controlled by html buttons
        this.actions = {
            // editor toolbar
            undo: ui.action("undo", () => this.stateManager.undo()),
            redo: ui.action("redo", () => this.stateManager.redo()),

            // editor menu
            save: ui.action("save", () => this.save()),
            export_: ui.action("export", () => this.exportProject()),
            export_json: ui.action("export_json", () => this.exportBundle()),
            import_: ui.action("import_html", () => this.importProject()),
            import_json: ui.action("import_bipsi", () => this.importBundle()),
            import_story: ui.action("import_story", () => this.importStory()),
            reset: ui.action("reset", () => this.resetProject()),
            update: ui.action("update", () => this.updateEditor()),

            shiftTileUp: ui.action("shift-tile-up", () =>
                this.processSelectedTile((tile) => cycleRendering2D(tile,  0, -1))),
            shiftTileDown: ui.action("shift-tile-down", () =>
                this.processSelectedTile((tile) => cycleRendering2D(tile,  0,  1))),
            shiftTileLeft: ui.action("shift-tile-left", () =>
                this.processSelectedTile((tile) => cycleRendering2D(tile, -1,  0))),
            shiftTileRight: ui.action("shift-tile-right", () =>
                this.processSelectedTile((tile) => cycleRendering2D(tile,  1,  0))),

            rotateTileClockwise: ui.action("rotate-tile-clockwise", () => 
                this.processSelectedTile((tile) => turnRendering2D(tile, 1))),
            rotateTileAnticlockwise: ui.action("rotate-tile-anticlockwise", () => 
                this.processSelectedTile((tile) => turnRendering2D(tile, -1))),

            flipTile: ui.action("flip-tile",     () => this.processSelectedTile(flipRendering2D)),
            mirrorTile: ui.action("mirror-tile", () => this.processSelectedTile(mirrorRendering2D)),
            invertTile: ui.action("invert-tile", () => this.processSelectedTile(invertMask)),
 
            copyTileFrame: ui.action("copy-tile-frame", () => this.copySelectedTileFrame()),
            pasteTileFrame: ui.action("paste-tile-frame", () => this.pasteSelectedTileFrame()),
            clearTileFrame: ui.action("clear-tile-frame", () => this.clearSelectedTileFrame()),

            newTile: ui.action("add-new-tile", () => this.newTile()),
            duplicateTile: ui.action("duplicate-tile", () => this.duplicateTile()),
            reorderTileBefore: ui.action("reorder-tile-before", () => this.reorderTileBefore()),
            reorderTileAfter: ui.action("reorder-tile-after", () => this.reorderTileAfter()),
            deleteTile: ui.action("delete-tile", () => this.deleteTile()),

            newRoom: ui.action("add-new-room", () => this.newRoom()),
            duplicateRoom: ui.action("duplicate-room", () => this.duplicateRoom()),
            reorderRoomBefore: ui.action("reorder-room-before", () => this.reorderRoomBefore()),
            reorderRoomAfter: ui.action("reorder-room-after", () => this.reorderRoomAfter()),
            deleteRoom: ui.action("delete-room", () => this.deleteRoom()),

            swapTileFrames: ui.action("swap-tile-frames", () => this.swapSelectedTileFrames()),

            copyEvent: ui.action("copy-event", () => this.copySelectedEvent()),
            pasteEvent: ui.action("paste-event", () => this.pasteSelectedEvent()),
            deleteEvent: ui.action("delete-event", () => this.deleteSelectedEvent()),
        };

        // can't undo/redo/paste yet
        this.actions.undo.disabled = true;
        this.actions.redo.disabled = true;
        this.actions.pasteTileFrame.disabled = true;
        this.actions.pasteEvent.disabled = true;
        this.actions.save.disabled = !storage.available;

        // hotkeys
        document.addEventListener("keydown", (event) => {
            const targetTag = event.target.tagName.toLowerCase();
            const textedit = targetTag === "input" || targetTag === "textarea";

            if (event.ctrlKey) {
                if (event.key === "z" && !textedit) this.actions.undo.invoke();
                if (event.key === "y" && !textedit) this.actions.redo.invoke();
                if (event.key === "s") {
                    event.preventDefault();
                    this.actions.save.invoke();
                }
            } else if (!textedit) {
                const topkeys = ["KeyQ", "KeyW", "KeyE", "KeyR", "KeyT"]; 
                topkeys.forEach((code, i) => {
                    if (event.code === code) {
                        this.modeSelect.selectedIndex = i;
                        event.preventDefault();
                    }
                });
            }

            if (event.altKey && this.heldColorPick === undefined) {
                this.heldColorPick = this.roomPaintTool.selectedIndex;
                this.roomPaintTool.selectedIndex = 2;
                event.preventDefault();
            }
        });

        // stop temporarily color picking if the alt key is released
        document.addEventListener("keyup", (event) => {
            if (!event.altKey && this.heldColorPick !== undefined) {
                this.roomPaintTool.selectedIndex = this.heldColorPick;
                this.heldColorPick = undefined;
                event.preventDefault();
            }
        });

        // changes in mode select bar
        this.modeSelect.addEventListener("change", async () => {
            this.redrawTileBrowser();

            ONE("#playtest").hidden = true;
            ONE("#playtest").srcdoc = "";
        });

        const playtest = ui.action("playtest", () => this.playtest());
        ONE("#playtest-rendering").addEventListener("click", () => playtest.invoke());

        this.roomSelect.select.addEventListener("change", () => {
            const { room } = this.getSelections();
            this.roomPaletteSelect.selectedIndex = room.palette;
            
            this.selectedEventId = undefined;
            this.redraw();
            this.eventEditor.refresh();
        });

        this.roomPaintTool.addEventListener("change", () => {
            this.redraw();
            this.redrawTileBrowser();
        });

        this.tileBrowser.select.addEventListener("change", () => {
            if (this.roomPaintTool.selectedIndex > 1) {
                this.roomPaintTool.selectedIndex = 0;
            }

            this.tilePaintFrameSelect.selectedIndex = 0;
        })

        this.roomPaletteSelect.addEventListener("change", () => {
            this.stateManager.makeChange(async (data) => {
                const { room } = this.getSelections(data);
                room.palette = this.roomPaletteSelect.selectedIndex;
            });
        });

        // whenever the project data is changed
        this.stateManager.addEventListener("change", () => {
            this.unsavedChanges = true;
            this.ready = true;
    
            this.refreshRoomSelect();

            this.paletteEditor.updateTemporaryFromData();
            this.paletteEditor.refreshDisplay();

            // enable/disable undo/redo buttons
            this.actions.undo.disabled = !this.stateManager.canUndo;
            this.actions.redo.disabled = !this.stateManager.canRedo;

            const { room } = this.getSelections();
            this.roomPaletteSelect.selectedIndex = room.palette;

            this.redrawTileBrowser();

            // render room
            this.redraw();
            this.tileBrowser.redraw();
            this.eventTileBrowser.redraw();

            // events
            this.eventEditor.refresh();
        });

        const onRoomPointer = async (event, canvas, forcePick=false) => {
            const { tile, room, data } = this.getSelections();

            const scale = canvas.width / (8 * 16);

            const round = (position) => {
                return {
                    x: Math.floor(position.x / (8 * scale)),
                    y: Math.floor(position.y / (8 * scale)),
                };
            };

            const redraw = () => this.redraw();

            const drag = ui.drag(event);
            const positions = trackCanvasStroke(canvas, drag);

            const { x, y } = round(positions[0]);

            const tool = this.roomPaintTool.value;

            const prevTile = room.tilemap[y][x];
            const nextTile = prevTile !== tile.id ? tile.id : 0;
            const nextWall = 1 - room.wallmap[y][x];

            if (tool === "pick" || forcePick) {
                if (prevTile !== 0) {
                    this.tileBrowser.selectedTileIndex = Math.max(0, data.tiles.findIndex((tile) => tile.id === prevTile));
                    this.tileBrowser.redraw();
                }
            } else if (tool === "wall" || tool === "tile" || tool === "high") {    
                this.stateManager.makeCheckpoint();

                const setIfWithin = (map, x, y, value) => {
                    if (x >= 0 && x < 16 && y >= 0 && y < 16) map[y][x] = value ?? 0;
                } 

                const pal = tool === "high" ? 2 : 1;

                const plots = {
                    tile: (x, y) => { 
                        setIfWithin(room.tilemap, x, y, nextTile); 
                        setIfWithin(room.backmap, x, y, 0); 
                        setIfWithin(room.foremap, x, y, pal); 
                    },
                    wall: (x, y) => setIfWithin(room.wallmap, x, y, nextWall),
                }
                plots.high = plots.tile;

                const plot = plots[tool];
                plot(x, y);
                redraw();

                drag.addEventListener("move", (event) => {
                    const { x: x0, y: y0 } = round(positions[positions.length - 2]);
                    const { x: x1, y: y1 } = round(positions[positions.length - 1]);
                    lineplot(x0, y0, x1, y1, plot);
                    redraw();
                });

                drag.addEventListener("up", (event) => {
                    const { x, y } = round(positions[positions.length - 1]);
                    plot(x, y);
                    redraw();
                    this.stateManager.changed();
                });

                if (tool === "wall") {
                    drag.addEventListener("click", (event) => {
                        if (event.detail.shiftKey) {
                            room.tilemap.forEach((row, y) => {
                                row.forEach((tileIndex, x) => {
                                    if (tileIndex === prevTile) {
                                        room.wallmap[y][x] = nextWall;
                                    }
                                });
                            });
                        }
                        redraw();
                    });
                }
            } else if (tool === "shift") {    
                this.stateManager.makeCheckpoint();

                drag.addEventListener("move", (event) => {
                    const { x: x0, y: y0 } = round(positions[positions.length - 2]);
                    const { x: x1, y: y1 } = round(positions[positions.length - 1]);
                    const dx = x0 - x1;
                    const dy = y0 - y1;
                    cycleMap(room.tilemap, dx, dy);
                    cycleMap(room.wallmap, dx, dy);
                    cycleMap(room.backmap, dx, dy);
                    cycleMap(room.foremap, dx, dy);
                    redraw();
                });
            }
        };

        this.renderings.tileMapPaint.canvas.addEventListener("pointerdown", (event) => onRoomPointer(event, this.renderings.tileMapPaint.canvas));
        this.renderings.tilePaintRoom.canvas.addEventListener("pointerdown", (event) => onRoomPointer(event, this.renderings.tilePaintRoom.canvas, true));

        this.renderings.eventsRoom.canvas.addEventListener("pointerdown", async (event) => {
            // hack bc race condition rn
            const drag = ui.drag(event);
            await sleep(1);

            if (this.eventEditor.showDialoguePreview) {
                this.dialoguePreviewPlayer.skip();
                if (this.dialoguePreviewPlayer.empty) this.eventEditor.resetDialoguePreview();
                this.redraw();
                return;
            }

            const { room } = this.getSelections();
            const scale = this.renderings.eventsRoom.canvas.width / (8 * 16);

            const round = (position) => {
                return {
                    x: Math.floor(position.x / (8 * scale)),
                    y: Math.floor(position.y / (8 * scale)),
                };
            };

            const redraw = () => {
                this.redraw();
            };

            const positions = trackCanvasStroke(this.renderings.eventsRoom.canvas, drag);
            let started = false;

            const { x, y } = round(positions[0]);

            if (event.altKey) {
                this.tileBrowser.selectedTileIndex = room.tilemap[y][x];
                return;
            }

            this.selectedEventCell = { x, y };
            redraw();

            const events_ = getEventsAt(room.events, x, y);
            const event_ = events_[events_.length - 1];
            this.selectedEventId = event_?.id;
            const events = event_ === undefined ? room.events : [event_];
            
            this.eventEditor.refresh();

            drag.addEventListener("move", (event) => {
                const { x: x0, y: y0 } = round(positions[positions.length - 2]);
                const { x: x1, y: y1 } = round(positions[positions.length - 1]);
                const dx = x1 - x0;
                const dy = y1 - y0;

                const move = (dx !== 0 || dy !== 0);

                if (!started && move) {
                    started = true;
                    this.stateManager.makeCheckpoint();
                }

                cycleEvents(events, dx, dy);
                this.selectedEventCell = { x: (x1 + 16) % 16, y: (y1 + 16) % 16 };

                if (move) {
                    this.stateManager.changed();
                }
            });
        });

        this.frame = 0;

        window.setInterval(() => {
            if (!this.ready) return;

            this.frame = 1 - this.frame;
            this.redraw();
        }, constants.frameInterval);
    }

    async init() {
        await this.paletteEditor.init();
        await this.dialoguePreviewPlayer.load();

        this.EVENT_TILE = await loadImage(constants.eventTile);
        this.WALL_TILE = await loadImage(constants.wallTile);

        this.dialoguePreviewPlayer.clear();
        this.dialoguePreviewPlayer.queue("click here to playtest", { panelColor: "#ffd800", textColor: "#000000" });
        this.dialoguePreviewPlayer.skip();
        this.dialoguePreviewPlayer.render();
        this.playtestSplash = copyRendering2D(this.dialoguePreviewPlayer.dialogueRendering);
    }

    /**
     * @param {BipsiDataProject} data 
     */
    getSelections(data = undefined) {
        data = data || this.stateManager.present;
        
        const tileset = this.stateManager.resources.get(data.tileset);
        const tileSize = constants.tileSize;
        const roomIndex = this.roomSelect.select.selectedIndex;
        const tileIndex = this.tileBrowser.selectedTileIndex;
        const frameIndex = this.tilePaintFrameSelect.selectedIndex;

        const tile = data.tiles[tileIndex];
        const room = data.rooms[roomIndex];

        const tileFrame = tile?.frames[frameIndex] ?? tile?.frames[0];

        const event = getEventById(data, this.selectedEventId);

        return { data, tileset, room, roomIndex, frameIndex, tileIndex, tileSize, event, tile, tileFrame };
    }

    /**
     * @returns {Promise<CanvasRenderingContext2D>}
     */
    async forkTileset() {
        const tilesetId = this.stateManager.present.tileset;
        // create a new copy of the image resource
        const { id, instance } = await this.stateManager.resources.fork(tilesetId);
        // replace the tileset image with the new copy
        this.stateManager.present.tileset = id;
        // return the instance of the image for editing
        return instance;
    }

    /**
     * @param {CanvasRenderingContext2D} rendering 
     * @param {number} roomIndex 
     */
    drawRoom(rendering, roomIndex, { palette = undefined, events = true } = {}) {
        const { data, tileset } = this.getSelections();
        const room = data.rooms[roomIndex];
        palette = palette ?? data.palettes[room.palette];
        const [background] = palette;

        // find current animation frame for each tile
        const tileToFrame = makeTileToFrameMap(data.tiles, this.frame);

        fillRendering2D(rendering, background);
        drawTilemapLayer(rendering, tileset, tileToFrame, palette, room);
        if (events) drawEventLayer(rendering, tileset, tileToFrame, palette, room.events);
    }

    redraw() {
        this.tileEditor.redraw();

        const { data, room, tileSize, roomIndex, tileset } = this.getSelections();
        const palette = this.modeSelect.value === "palettes" 
                      ? this.paletteEditor.getPreviewPalette()  
                      : data.palettes[room.palette];
        const [background] = palette;

        const tileToFrame = makeTileToFrameMap(data.tiles, this.frame);

        fillRendering2D(TEMP_128, background);
        drawTilemapLayer(TEMP_128, tileset, tileToFrame, palette, room);
        this.renderings.tileMapPaint.drawImage(TEMP_128.canvas, 0, 0, 256, 256);
        
        fillRendering2D(TEMP_128);
        drawEventLayer(TEMP_128, tileset, tileToFrame, palette, room.events);
        this.renderings.tileMapPaint.globalAlpha = .75;
        this.renderings.tileMapPaint.drawImage(TEMP_128.canvas, 0, 0, 256, 256);
        this.renderings.tileMapPaint.globalAlpha = 1;

        if (this.roomGrid.checked) {
            const rendering = this.renderings.tileMapPaint;
            rendering.globalAlpha = .25;
            rendering.drawImage(ROOM_GRID.canvas, 0, 0);
            rendering.globalAlpha = 1;
        }

        if (this.roomPaintTool.value === "wall") {
            const rendering = this.renderings.tileMapPaint;
            rendering.globalAlpha = .75;
            room.wallmap.forEach((row, y) => {
                row.forEach((wall, x) => {
                    if (wall > 0) {
                        rendering.drawImage(
                            this.WALL_TILE, 
                            x * tileSize * 2, y * tileSize * 2,
                        );
                    }
                });
            });
            rendering.globalAlpha = 1;
        }

        this.refreshRoomSelect();

        this.drawRoom(TEMP_128, roomIndex, { palette });
        this.renderings.paletteRoom.drawImage(TEMP_128.canvas, 0, 0);
        this.renderings.tilePaintRoom.drawImage(TEMP_128.canvas, 0, 0);
        this.renderings.eventsRoom.drawImage(TEMP_128.canvas, 0, 0, 256, 256);

        if (!this.eventEditor.showDialoguePreview) {
            fillRendering2D(TEMP_256);
    
            room.events.forEach((event) => {
                const [x, y] = event.position;
                TEMP_256.drawImage(this.EVENT_TILE, x * tileSize * 2, y * tileSize * 2);
            });

            if (this.selectedEventCell) {
                const { x, y } = this.selectedEventCell;
                TEMP_256.fillStyle = "white";
                TEMP_256.fillRect(0, y * 16 + 6, 256, 4);
                TEMP_256.fillRect(x * 16 + 6, 0, 4, 256);
            }

            this.renderings.eventsRoom.globalAlpha = .5;
            this.renderings.eventsRoom.drawImage(TEMP_256.canvas, 0, 0);
            this.renderings.eventsRoom.globalAlpha = 1;
        }

        this.actions.copyEvent.disabled = this.selectedEventId === undefined;
        this.actions.deleteEvent.disabled = this.selectedEventId === undefined;

        this.actions.reorderRoomBefore.disabled = this.roomSelect.select.selectedIndex <= 0;
        this.actions.reorderRoomAfter.disabled = this.roomSelect.select.selectedIndex >= this.stateManager.present.rooms.length - 1;

        this.redrawDialoguePreview();

        fillRendering2D(this.renderings.playtest);
        this.renderings.playtest.drawImage(this.playtestSplash.canvas, 0, 0);
    } 

    refreshRoomSelect() {
        const { data } = this.getSelections();

        const thumbs = data.rooms.map((room) => {
            const thumb = createRendering2D(16, 16);
            drawRoomThumbnail(thumb, data.palettes[room.palette], room);
            return { id: room.id, thumb: thumb.canvas };
        });

        this.roomSelect.updateRooms(thumbs);
        this.fieldRoomSelect.updateRooms(thumbs);
        this.eventsRoomSelect.updateRooms(thumbs);

        this.roomSelect.select.selectedIndex = Math.max(this.roomSelect.select.selectedIndex, 0);
        this.eventsRoomSelect.select.selectedIndex = this.roomSelect.select.selectedIndex;
    }

    redrawDialoguePreview() {
        if (this.eventEditor.showDialoguePreview && !this.dialoguePreviewPlayer.empty) {
            const top = this.selectedEventCell.y >= 8;

            this.dialoguePreviewPlayer.options.anchorY = top ? 0 : 1;
            this.dialoguePreviewPlayer.render();
            this.renderings.eventsRoom.drawImage(this.dialoguePreviewPlayer.dialogueRendering.canvas, 0, 0);
        }
    }

    async redrawTileBrowser() {
        const { data, room, tileset } = this.getSelections();
        const [, foreground, highlight] = data.palettes[room.palette];

        const hi = this.roomPaintTool.value === "high" || this.modeSelect.value === "events";
        const color = hi ? highlight : foreground;
        const tilesetC = recolorMask(tileset, color, TEMP_TILESET0);

        // draw tileset frame
        const cols = 16;
        const rows = Math.ceil(data.tiles.length / cols);
        const frame0 = createRendering2D(cols * 8, rows * 8);
        const frame1 = createRendering2D(cols * 8, rows * 8);

        data.tiles.forEach(({ frames }, i) => {
            const index0 = frames[0];
            const index1 = frames[1] ?? index0;

            const tx = i % 16;
            const ty = Math.floor(i / 16);

            {
                const { x, y, size } = getTileCoords(tilesetC.canvas, index0);
                frame0.drawImage(
                    tilesetC.canvas,
                    x, y, size, size, 
                    tx * size, ty * size, size, size,
                );
            }
            {
                const { x, y, size } = getTileCoords(tilesetC.canvas, index1);
                frame1.drawImage(
                    tilesetC.canvas,
                    x, y, size, size, 
                    tx * size, ty * size, size, size,
                );
            }
        });

        await this.tileBrowser.setFrames([frame0.canvas, frame1.canvas]);
        await this.eventTileBrowser.setFrames([frame0.canvas, frame1.canvas]);
        if (this.tileBrowser.select.selectedIndex === -1) {
            this.tileBrowser.select.selectedIndex = 0;
        }
    }

    async copySelectedRoom() {
        const { room } = this.getSelections();
        this.copiedRoom = COPY(room);
        this.actions.pasteRoom.disabled = false;
    }

    async pasteSelectedRoom() {
        return this.stateManager.makeChange(async (data) => {
            const { roomIndex } = this.getSelections(data);
            const copy = COPY(this.copiedRoom);
            copy.id = nextRoomId(data);
            const eventId = nextEventId(data);
            copy.events.forEach((event, i) => event.id = eventId + i);
            data.rooms[roomIndex] = copy;
        });
    }
    
    async clearSelectedRoom() {
        return this.stateManager.makeChange(async (data) => {
            const { roomIndex } = this.getSelections(data);
            data.rooms[roomIndex] = makeBlankRoom();
        });
    }

    /**
     * @param {(CanvasRenderingContext2D) => void} process 
     */
    async processSelectedTile(process) {
        return this.stateManager.makeChange(async (data) => {
            const { tileFrame } = this.getSelections(data);
            const tileset = await this.forkTileset();

            const frame = copyTile(tileset, tileFrame);
            process(frame);
            drawTile(tileset, tileFrame, frame);
        });
    }

    async copySelectedTileFrame() {
        const { tileset, tileFrame } = this.getSelections();
        this.copiedTileFrame = copyTile(tileset, tileFrame);
        this.actions.pasteTileFrame.disabled = false;
    }

    async pasteSelectedTileFrame() {
        return this.stateManager.makeChange(async (data) => {
            const { tileFrame } = this.getSelections(data);
            const tileset = await this.forkTileset();

            drawTile(tileset, tileFrame, this.copiedTileFrame);
        });
    }
    
    async clearSelectedTileFrame() {
        return this.stateManager.makeChange(async (data) => {
            const { tileFrame } = this.getSelections(data);
            const tileset = await this.forkTileset();

            const { x, y, size } = getTileCoords(tileset.canvas, tileFrame);
            tileset.clearRect(x, y, size, size);
        });
    }

    async swapSelectedTileFrames() {
        const { tile } = this.getSelections();
        if (tile.frames.length === 1) return;

        return this.stateManager.makeChange(async (data) => {
            const { tile } = this.getSelections(data);
            [tile.frames[1], tile.frames[0]] = [tile.frames[0], tile.frames[1]];
        });
    }

    async newTile() {
        await this.stateManager.makeChange(async (data) => {
            const { tileIndex, tileset } = this.getSelections(data);
            const id = nextTileId(data);
            const frames = [findFreeFrame(data.tiles)];
            data.tiles.splice(tileIndex+1, 0, { id, frames });
            resizeTileset(tileset, data.tiles);
            
            const { x, y, size } = getTileCoords(tileset.canvas, frames[0]);
            tileset.clearRect(x, y, size, size);
        });
        this.tileBrowser.selectedTileIndex += 1;
    }

    async duplicateTile() {
        await this.stateManager.makeChange(async (data) => {
            const { tileIndex, tile, tileset } = this.getSelections(data);
            const id = nextTileId(data);
            const frames = [];

            data.tiles.splice(tileIndex+1, 0, { id, frames });
            tile.frames.forEach((_, i) => {
                frames.push(findFreeFrame(data.tiles));
                resizeTileset(tileset, data.tiles);
                const frame = copyTile(tileset, tile.frames[i]);
                drawTile(tileset, frames[i], frame);
            });
        });
        this.tileBrowser.selectedTileIndex += 1;
    }

    async toggleTileAnimated() {
        return this.stateManager.makeChange(async (data) => {
            const { tile, tileset } = this.getSelections(data);
            
            if (tile.frames.length === 1) {
                tile.frames.push(findFreeFrame(data.tiles));
                resizeTileset(tileset, data.tiles);
                const frame = copyTile(tileset, tile.frames[0]);
                drawTile(tileset, tile.frames[1], frame);
            } else {
                tile.frames = [tile.frames[0]];
            }
        });
    }

    async reorderTileBefore() {
        return this.stateManager.makeChange(async (data) => {
            const { tileIndex } = this.getSelections(data);
            const nextIndex = tileIndex - 1;
            [data.tiles[nextIndex], data.tiles[tileIndex]] = [data.tiles[tileIndex], data.tiles[nextIndex]];
            this.tileBrowser.selectedTileIndex -= 1;
        });
    }

    async reorderTileAfter() {
        return this.stateManager.makeChange(async (data) => {
            const { tileIndex } = this.getSelections(data);
            const nextIndex = tileIndex + 1;
            [data.tiles[nextIndex], data.tiles[tileIndex]] = [data.tiles[tileIndex], data.tiles[nextIndex]];
            this.tileBrowser.selectedTileIndex += 1;
        });
    }

    async deleteTile() {
        return this.stateManager.makeChange(async (data) => {
            const { tile } = this.getSelections(data);
            arrayDiscard(data.tiles, tile);
            data.rooms.forEach((room) => {
                room.tilemap.forEach((row, y) => {
                    row.forEach((id, x) => {
                        if (id === tile.id) row[x] = 0;
                    });
                });
            });
        });
    }

    async newRoom() {
        await this.stateManager.makeChange(async (data) => {
            const { roomIndex } = this.getSelections(data);
            const room = makeBlankRoom(nextRoomId(data));
            data.rooms.splice(roomIndex+1, 0, room);
        });
        this.roomSelect.select.selectedIndex += 1;
    }

    async duplicateRoom() {
        await this.stateManager.makeChange(async (data) => {
            const { roomIndex, room } = this.getSelections(data);
            const copy = COPY(room);
            copy.id = nextRoomId(data);
            data.rooms.splice(roomIndex+1, 0, copy);

            const nextId = nextEventId(data);
            copy.events.forEach((event, i) => event.id = nextId+i);
        });
        this.roomSelect.select.selectedIndex += 1;
    }

    async reorderRoomBefore() {
        return this.stateManager.makeChange(async (data) => {
            const { roomIndex } = this.getSelections(data);
            const nextIndex = roomIndex - 1;
            [data.rooms[nextIndex], data.rooms[roomIndex]] = [data.rooms[roomIndex], data.rooms[nextIndex]];
            this.roomSelect.select.selectedIndex -= 1;
        });
    }

    async reorderRoomAfter() {
        return this.stateManager.makeChange(async (data) => {
            const { roomIndex } = this.getSelections(data);
            const nextIndex = roomIndex + 1;
            [data.rooms[nextIndex], data.rooms[roomIndex]] = [data.rooms[roomIndex], data.rooms[nextIndex]];
            this.roomSelect.select.selectedIndex += 1;
        });
    }

    async deleteRoom() {
        return this.stateManager.makeChange(async (data) => {
            const { room } = this.getSelections(data);
            arrayDiscard(data.rooms, room);
        });
    }

    createEvent(fieldsTemplate = undefined) {
        this.stateManager.makeChange(async (data) => {
            const { room } = this.getSelections(data);
            const { x, y } = this.selectedEventCell;
            const event = { 
                id: nextEventId(data),
                position: [x, y],
                fields: COPY(fieldsTemplate ?? []),
            }
            room.events.push(event);
            this.selectedEventId = event.id;
        });
    }

    copySelectedEvent() {
        const { data } = this.getSelections();
        const event = getEventById(data, this.selectedEventId);
        this.copiedEvent = COPY(event);
        this.actions.pasteEvent.disabled = false;
    }

    pasteSelectedEvent() {
        this.stateManager.makeChange(async (data) => {
            const { room } = this.getSelections(data);
            const { x, y } = this.selectedEventCell;
            const event = COPY(this.copiedEvent);
            event.id = nextEventId(data);
            event.position = [x, y];
            room.events.push(event);
            this.selectedEventId = event.id;
        });
    }

    deleteSelectedEvent() {
        this.stateManager.makeChange(async (data) => {
            const { room } = this.getSelections(data);
            const event = getEventById(data, this.selectedEventId);
            arrayDiscard(room.events, event);
            this.selectedEventId = undefined;
        });
    }

    /**
     * Replace the current bipsi data with the given bundle.
     * @param {maker.ProjectBundle<BipsiDataProject>} bundle
     */
    async loadBundle(bundle) {
        this.ready = false;

        // account for changes between bipsi versions
        updateProject(bundle.project);

        await this.stateManager.loadBundle(bundle);
        this.unsavedChanges = false;
    }

    async loadStory(story) {
        ONE("#story-embed").innerHTML = JSON.stringify(story);
        await this.playtest()
    }

    /** @returns {string[]} */
    getManifest() {
        return [];
    }

    async playtest() {
        const iframe = ONE("#playtest");
        const html = await this.makeExportHTML();
        iframe.srcdoc = html;
        iframe.hidden = false;
    }

    async makeExportHTML() {
        // make a standalone bundle of the current project state and the 
        // resources it depends upon
        const bundle = await this.stateManager.makeBundle();

        // make a copy of this web page
        const clone = /** @type {HTMLElement} */ (document.documentElement.cloneNode(true));
        // remove some unwanted elements from the page copy
        ALL("[data-empty]", clone).forEach((element) => element.replaceChildren());
        ALL("[data-editor-only]", clone).forEach((element) => element.remove());
        // insert the project bundle data into the page copy 
        ONE("#bundle-embed", clone).innerHTML = JSON.stringify(bundle);

        // track how many remixes this is (remixes have soft-limits to encourage finding updates)
        const generation = parseInt(clone.getAttribute("data-remix-generation"));
        clone.setAttribute("data-remix-generation", `${generation + 1}`);

        // default to player mode
        clone.setAttribute("data-app-mode", "player");

        return clone.outerHTML;
    }
        
    async exportProject() {
        // prompt the browser to download the page
        const name = "binksi.html";
        const blob = maker.textToBlob(await this.makeExportHTML(), "text/html");
        maker.saveAs(blob, name);
    }

    async exportBundle() {
        const bundle = await this.stateManager.makeBundle();
        const name = "bipsi.json";
        const formatted = perfectJson(bundle,{singleLine: ({ key, path, depth }) => {
            if (key == "position") return true;
            if (key == "frames") return true;
            if (depth >= 5){
               return ["tilemap", "highmap", "backmap", "foremap", "wallmap"].includes(path[3]);
            }
            if (depth >= 3){
                return ["palettes", "tiles"].includes(path[1]);
            }
            return false;
          }});
        const blob = maker.textToBlob(formatted, "application/json");
        maker.saveAs(blob, name);
    }

    async importProject() {
        // ask the browser to provide a file
        const [file] = await maker.pickFiles("text/html");
        // read the file and turn it into an html page
        const text = await maker.textFromFile(file);
        const html = await maker.htmlFromText(text);
        // extract the bundle from the imported page
        const bundle = maker.bundleFromHTML(html);
        // load the contents of the bundle into the editor
        await this.loadBundle(bundle);
    } 

    async importBundle() {
        // ask the browser to provide a file
        const [file] = await maker.pickFiles("application/json");
        // read the file and turn it into an html page
        const json = await maker.textFromFile(file);
        const bundle = JSON.parse(json);
        await this.loadBundle(bundle);
    } 

    async importStory() {
        // ask the browser to provide a file
        const [file] = await maker.pickFiles("application/json");
        // read the file and turn it into an html page
        const json = await maker.textFromFile(file);
        const story = JSON.parse(json.charCodeAt(0) == 123 ? json : json.substring(1))
        await this.loadStory(story);
    } 

    async resetProject() {
        // open the default project in the editor
        await this.loadBundle(maker.bundleFromHTML(document, "#editor-embed"));
    }
    
    /**
     * Open a new tab with the original editor and send the current project to it.
     */
    async updateEditor() {
        // original editor url is stored in the html (may be different for 
        // custom editor mods)
        const liveURL = document.documentElement.getAttribute("data-editor-live");
        
        const bundle = await this.stateManager.makeBundle();
        
        // the original editor will check to see if it was opened by another
        // tab and then send us a message--if we receive it then we send the
        // bundle back 
        window.addEventListener("message", (event) => {
            event.data.port.postMessage({ bundle });
        });
        window.open(liveURL);
    }

    async save() {
        // visual feedback that saving is occuring
        this.actions.save.disabled = true;
        const timer = sleep(250);

        // make bundle and save it
        const bundle = await this.stateManager.makeBundle();
        await storage.save(bundle, "slot0");
        
        // successful save, no unsaved changes
        this.unsavedChanges = false;

        // allow saving again when enough time has passed to see visual feedback
        await timer;
        this.actions.save.disabled = false;
    }
}

    </script>
    <script data-editor-only="data-editor-only">class RoomSelectItem {
    constructor(root, input, canvas) {
        this.root = root;
        this.input = input;
        this.canvas = canvas;
        this.rendering = canvas.getContext("2d");
    }

    setup(id, thumb) {
        this.input.title = `select room ${id}`;
        this.input.value = id;
        this.rendering.drawImage(thumb, 0, 0);
    }

    remove() {
        this.root.remove();
    }
}

class RoomSelect {
    /**
     * @param {*} name 
     * @param {HTMLTemplateElement} template 
     */
    constructor(name, template) {
        this.template = template;

        this.name = name;
        this.select = ui.radio(name);

        const parent = this.template.parentElement;

        this.items = new IndexedItemPool({
            create: () => {
                const clone = this.template.content.firstElementChild.cloneNode(true);
                const item = new RoomSelectItem(clone, ONE("input", clone), ONE("canvas", clone));
                parent.append(clone);
                return item;
            },
            dispose: (item) => item.remove(), 
        });
    }

    /**
     * @param {{ id: number, thumb: HTMLCanvasElement }[]} rooms 
     */
    updateRooms(rooms) {
        this.items.map(rooms, ({ id, thumb }, item) => item.setup(id, thumb));
        this.select.replaceInputs(ALL(`input[type="radio"][name="${this.name}"]`));
    }
}
    </script>
    <script data-editor-only="data-editor-only">class TileSelectItem {
    constructor(root, input) {
        this.root = root;
        this.input = input;
    }

    setup(id, x, y, index) {
        this.input.title = `select tile ${id}`;
        this.input.value = index;
        this.root.style.backgroundPosition = `-${x}px -${y}px`;
    }

    remove() {
        this.root.remove();
    }
}

class TileBrowser {
    /**
     * @param {BipsiEditor} editor
     * @param {string} name
     * @param {HTMLTemplateElement} template
     */
    constructor(editor, name, template) {
        this.editor = editor;
        this.template = template;

        this.thumbnailURIs = [];

        this.itemContainer = this.template.parentElement;

        this.items = new IndexedItemPool({
            create: () => {
                const clone = this.template.content.firstElementChild.cloneNode(true);
                const item = new TileSelectItem(clone, ONE("input", clone));
                this.itemContainer.append(item.root);
                this.select.add(item.input);
                return item;
            },
            dispose: (item) => {
                this.select.remove(item.input);
                item.remove();
            },
        });

        this.select = ui.radio(name);
    
        this.select.addEventListener("change", () => this.redraw());

        this.frame = 0;

        window.setInterval(() => {
            if (!this.editor.ready) return;
            this.frame = 1 - this.frame;
            this.updateCSS();
            this.redraw();
        }, constants.frameInterval);
    }

    get selectedTileIndex() {
        return this.select.valueAsNumber;
    }

    set selectedTileIndex(value) { 
        this.select.setValueSilent(value);
        this.select.inputs[this.select.selectedIndex]?.scrollIntoView({ block: "center" }); 
    }

    redraw() {
        const { data, tile } = this.editor.getSelections();
        if (!tile) return;

        this.items.setCount(data.tiles.length);
        if (this.select.selectedIndex === -1) {
            this.select.selectedIndex = 0;
        }

        this.editor.tileEditor.animateToggle.setCheckedSilent(tile.frames.length > 1);

        this.editor.actions.reorderTileBefore.disabled = this.selectedTileIndex <= 0;
        this.editor.actions.reorderTileAfter.disabled = this.selectedTileIndex >= data.tiles.length - 1;
    }

    async setFrames(canvases) {
        const prev = [...this.thumbnailURIs];
        const blobs = await Promise.all(canvases.map(canvasToBlob));
        const uris = blobs.map(URL.createObjectURL);
        await Promise.all(uris.map(loadImage)).then(() => {
            this.thumbnailURIs = uris;
            this.updateCSS();
            prev.map(URL.revokeObjectURL);
        });

        const root = ONE(":root");
        const scale = 5;
        const w = canvases[0].width * scale;
        const h = canvases[0].height * scale;

        const { data, room } = this.editor.getSelections();

        root.style.setProperty("--tileset-background-size", `${w}px ${h}px`);
        root.style.setProperty("--tileset-background-color", data.palettes[room.palette][0]);

        this.items.map(data.tiles, (tile, item, index) => {
            const { x, y } = getTileCoords(canvases[0], index);
            item.setup(tile.id, x * scale, y * scale, index);
        });
    }

    async updateCSS() {
        this.itemContainer.style.setProperty(
            "--tileset-background-image", 
            `url("${this.thumbnailURIs[this.frame]}")`,
        );
    }
}

class EventTileBrowser extends TileBrowser {
    redraw() {
    }
}

    </script>
    <script data-editor-only="data-editor-only">"use strict";

function perfectJson(item) {

  function arrayValuesAreExpandedObjects(values) {
    for (var i = 0; i < values.length; i++) {
      if (!/^[[{]\n/.test(values[i])) {
        return false;
      }
    }
  
    return true;
  }
  
  function getIndentChars(depth, indent) {
    return new Array(depth * indent + 1).join(' ');
  }

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var recursiveOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var _options$indent = options.indent,
      indent = _options$indent === void 0 ? 2 : _options$indent,
      _options$compact = options.compact,
      compact = _options$compact === void 0 ? true : _options$compact,
      singleLine = options.singleLine,
      maxLineLength = options.maxLineLength,
      _options$arrayMargin = options.arrayMargin,
      arrayMargin = _options$arrayMargin === void 0 ? '' : _options$arrayMargin,
      _options$objectMargin = options.objectMargin,
      objectMargin = _options$objectMargin === void 0 ? ' ' : _options$objectMargin,
      split = options.split,
      splitResult = options.splitResult;
  var key = recursiveOptions.key,
      _recursiveOptions$pat = recursiveOptions.path,
      path = _recursiveOptions$pat === void 0 ? [] : _recursiveOptions$pat,
      _recursiveOptions$ite = recursiveOptions.items,
      items = _recursiveOptions$ite === void 0 ? [] : _recursiveOptions$ite,
      _recursiveOptions$dep = recursiveOptions.depth,
      depth = _recursiveOptions$dep === void 0 ? 0 : _recursiveOptions$dep,
      _recursiveOptions$spl = recursiveOptions.splitted,
      splitted = _recursiveOptions$spl === void 0 ? {} : _recursiveOptions$spl;
  var _recursiveOptions$spl2 = recursiveOptions.splitDepth,
      splitDepth = _recursiveOptions$spl2 === void 0 ? 0 : _recursiveOptions$spl2;

  if (item === undefined) {
    return 'undefined';
  }

  if (item === null) {
    return 'null';
  }

  if (typeof item === 'string') {
    return "\"".concat(item, "\"");
  }

  if (typeof item === 'boolean' || typeof item === 'number') {
    return "".concat(item);
  }

  var itemOpts = {
    key: key,
    value: item,
    path: path,
    items: items,
    depth: depth,
    indent: indent
  };
  var splitPlaceholder = typeof key === 'string' && typeof split === 'function' ? split(itemOpts) : null;

  if (splitPlaceholder) {
    if (splitted[splitPlaceholder] !== undefined) {
      throw new Error("Placeholder \"".concat(splitPlaceholder, "\" is already used"));
    }

    splitDepth = 0;
  }

  var perfectify = function perfectify(key, value) {
    return perfectJson(value, options, {
      key: key,
      path: path.concat([key]),
      items: items.concat([item]),
      depth: depth + 1,
      splitDepth: splitDepth + 1,
      splitted: splitted
    });
  };

  var baseIndentChars = getIndentChars(depth, indent);
  var prefixIndentChars = key === undefined ? baseIndentChars : '';
  var open, close, margin, values;

  if (Array.isArray(item)) {
    if (item.length === 0) {
      return "".concat(prefixIndentChars, "[]");
    }

    open = '[';
    close = ']';
    margin = arrayMargin;
    values = item.map(function (value, key) {
      return perfectify(key, value);
    });
  } else {
    var keys = Object.keys(item);

    if (keys.length === 0) {
      return "".concat(prefixIndentChars, "{}");
    }

    open = '{';
    close = '}';
    margin = objectMargin;
    values = keys.map(function (key) {
      return "\"".concat(key, "\": ").concat(perfectify(key, item[key]));
    });
  }

  var line = "".concat(open).concat(margin).concat(values.join(', ')).concat(margin).concat(close);
  var result;

  if (typeof singleLine === 'boolean' && singleLine || typeof singleLine === 'function' && singleLine(_objectSpread(_objectSpread({}, itemOpts), {}, {
    line: line
  })) || typeof maxLineLength === 'number' && line.length + baseIndentChars.length <= maxLineLength) {
    result = line;
  } else {
    var list;

    if (Array.isArray(item) && arrayValuesAreExpandedObjects(values) && compact) {
      var replaceIndent = splitPlaceholder ? (splitDepth + 1) * indent : indent;
      var replaceRegExp = new RegExp("\\n {".concat(replaceIndent, "}"), 'g');
      list = '';

      for (var i = 0; i < values.length; i++) {
        if (list) {
          list += ', ';
        }

        list += values[i].replace(replaceRegExp, '\n');
      }
    } else {
      var baseSpace = getIndentChars(splitDepth, indent);
      var nestedSpace = getIndentChars(splitDepth + 1, indent);
      list = "\n".concat(values.map(function (value) {
        return "".concat(nestedSpace).concat(value);
      }).join(',\n'), "\n").concat(baseSpace);
    }

    result = "".concat(prefixIndentChars).concat(open).concat(list).concat(close);
  }

  if (splitPlaceholder) {
    splitted[splitPlaceholder] = result;
  }

  if (depth === 0 && typeof splitResult === 'function') {
    splitResult(splitted);
  }

  return splitPlaceholder ? "\"".concat(splitPlaceholder, "\"") : result;
}
    </script>
    <!--script(data-editor-only)include scripts/editor/palette-picker.js
    -->
    <script>async function startPlayback(font, bundle) {
    const playback = new BipsiPlayback(font);
    await playback.init();
    await playback.loadBundle(bundle);
    playback.start();
}

async function startEditor(font) {
    const editor = new BipsiEditor(font);
    await editor.init();

    // used to show/hide elements in css
    document.documentElement.setAttribute("data-app-mode", "editor");

    // no embedded project, start editor with save or editor embed
    const save = await storage.load("slot0").catch(() => undefined);
    const bundle = save || maker.bundleFromHTML(document, "#editor-embed");
    
    // load bundle and enter editor mode
    await editor.loadBundle(bundle);

    // unsaved changes warning
    window.addEventListener("beforeunload", (event) => {
        if (!editor.unsavedChanges) return;
        event.preventDefault();
        return event.returnValue = "Are you sure you want to exit?";
    });
}

async function makePlayback(font, bundle, story) {
    const playback = new BipsiPlayback(font);
    await playback.initWithStory(story);

    const playCanvas = /** @type {HTMLCanvasElement} */ (ONE("#player-canvas"));
    const playRendering = /** @type {CanvasRenderingContext2D} */ (playCanvas.getContext("2d"));

    // update the canvas size every render just in case..
    playback.addEventListener("render", () => {
        fillRendering2D(playRendering);
        playRendering.drawImage(playback.rendering.canvas, 0, 0);
        fitCanvasToParent(playCanvas);
        document.documentElement.style.setProperty('--vh', `${window.innerHeight / 100}px`);
    });

    // update the canvas size whenever the browser window resizes
    window.addEventListener("resize", () => fitCanvasToParent(playCanvas));
    
    // update the canvas size initially
    fitCanvasToParent(playCanvas);

    let moveCooldown = 0;
    const heldKeys = new Set();
    const keys = new Map();
    keys.set("ArrowLeft",  () => playback.move(-1,  0));
    keys.set("ArrowRight", () => playback.move( 1,  0));
    keys.set("ArrowUp",    () => playback.move( 0, -1));
    keys.set("ArrowDown",  () => playback.move( 0,  1));

    const keyToCode = new Map();
    keyToCode.set("ArrowUp", "KeyW");
    keyToCode.set("ArrowLeft", "KeyA");
    keyToCode.set("ArrowDown", "KeyS");
    keyToCode.set("ArrowRight", "KeyD");

    function doMove(key) {
        if(playback.preventMoving) return;
        const move = keys.get(key);
        if (move) {
            move();
            moveCooldown = .2;
        }
    }

    let prev;
    const timer = (next) => {
        prev = prev ?? Date.now();
        next = next ?? Date.now();
        const dt = Math.max(0, (next - prev) / 1000.);
        moveCooldown = Math.max(moveCooldown - dt, 0);
        prev = next;
        window.requestAnimationFrame(timer);

        if (moveCooldown === 0) {
            const key = Array.from(keys.keys()).find((key) => heldKeys.has(key) || heldKeys.has(keyToCode.get(key)));
            if (key) doMove(key);
        }

        playback.update(dt);
    }
    timer();

    function down(key, code) {
        if (!playback.dialoguePlayback.empty) {
            playback.proceed();
        } else {
            heldKeys.add(key);
            heldKeys.add(code);
            doMove(key);
        }
    }

    function up(key, code) {
        heldKeys.delete(key);
        heldKeys.delete(code);
    }

    const turnToKey = ["ArrowRight", "ArrowDown", "ArrowLeft", "ArrowUp"];
    const threshold = 512 / 16 * 4;
    let ignoreMouse = false;

    window.onblur = () => setTimeout(() => ignoreMouse = true, 0);
    window.onfocus = () => setTimeout(() => ignoreMouse = false, 0);

    document.addEventListener("keydown", (event) => {
        if (!event.repeat) down(event.key, event.code);
        if (event.key !== "Tab") {
            event.stopPropagation();
            event.preventDefault();
        }
    }, { capture: true });
    document.addEventListener("keyup", (event) => up(event.key, event.code));

    document.addEventListener("pointerdown", (event) => {
        if (ignoreMouse) return;

        const drag = ui.drag(event);
        let [x0, y0] = [drag.downEvent.clientX, drag.downEvent.clientY];

        playback.proceed();

        drag.addEventListener("move", () => {
            const [x1, y1] = [drag.lastEvent.clientX, drag.lastEvent.clientY];
            const [dx, dy] = [x1 - x0, y1 - y0];

            const dist = Math.max(Math.abs(dx), Math.abs(dy));
            const angle = Math.atan2(dy, dx) + Math.PI * 2;
            const turns = Math.round(angle / (Math.PI * .5)) % 4;
            const nextKey = turnToKey[turns];

            if (dist >= threshold) {
                doMove(nextKey);
                x0 = x1;
                y0 = y1;
            } 
        });
    });

    document.documentElement.setAttribute("data-app-mode", "player");
    await playback.loadBundle(bundle);
    playback.start();

    return playback;
}

async function start() {
    const font = await loadBasicFont(ONE("#font-embed"));

    // determine if there is a project bundle embedded in this page
    const bundle = maker.bundleFromHTML(document);

    const storyContent = maker.bundleFromHTML(document, "#story-embed");
    const story = new inkjs.Story(storyContent);

    if (bundle) {
        await makePlayback(font, bundle, story);
    } else {
        await startEditor(font);
    }
}

    </script>
    <!-- styles-->
    <style id="base-style">
/* prevent weird highlights https://stackoverflow.com/questions/21003535/ */
.no-select {
    -webkit-tap-highlight-color: transparent;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
}

/* hidden elements should be hidden regardless of their display style */
[hidden] { display: none !important; }

/* default to width/height including padding and border */
* { box-sizing: border-box; }

/* used dynamically to prevent or cancel smooth transitions */
.skip-transition { transition: none !important; }

/* make buttons and select inherit font */ 
button, select { font-family: inherit; font-size: inherit; }

/* clickable things should use this cursor imo */
button, a, input[type="radio"], input[type="checkbox"], select, option, label, summary { cursor: pointer; }

/* crisp pixelart for images and backgrounds */
* {
    image-rendering: -moz-crisp-edges;
    image-rendering: -webkit-crisp-edges;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
}

/* prevent pull down to refresh page (and lose data rip) */
body {
    overscroll-behavior-y: contain;
}

    </style>
    <style id="main-style">:root {
    --button-color: #ffd800;

    /** diagonal stripes for showing clearly transparent pixels of the paint area */
    --trans-color-1: rgb(32, 32, 32);
    --trans-color-2: rgb(48, 48, 48);
    --trans-gradient: repeating-linear-gradient( -45deg, var(--trans-color-1), var(--trans-color-1) .5em, var(--trans-color-2) .5em, var(--trans-color-2) 1em );

    font-family: sans-serif;
}

:root[data-app-mode="editor"] [data-hidden-in-editor] {
    display: none !important;
    visibility: hidden;
}

:root[data-app-mode="player"] [data-hidden-in-player] {
    display: none !important;
    visibility: hidden;
}

html, body {
    margin: 0; padding: 0;
    min-height: calc(var(--vh, 1vh) * 100);

    overflow: hidden auto;
    overscroll-behavior-y: contain;
}

body {
    display: flex; flex-direction: column;
    justify-content: center;
    align-items: center;

    background: black;
    color: white;
}

#editor {
    display: flex; flex-direction: column;
    justify-content: center;
    align-items: center;
}

html:not([data-remix-generation="0"]) [data-original-only] {
    display: none !important;
}

html[data-remix-generation="0"] [data-remix-only] {
    display: none !important;
}

#editor main {
    display: flex; flex-direction: column;
    padding: 1em; gap: 1em;

    background: #367b6b;
    border-radius: 2em;
}

@media (max-width: 650px) {
    #editor main {
        width: 100vw;
    }
}

h1, h2, h3, h4, h5, h6 {
    margin: 0;
}

#help {
    font-family: monospace;
    font-size: large;

    padding: 1em;

    overflow: hidden scroll;
}

#help, #help > section {
    display: flex;
    flex-direction: column;
    gap: 1em;
}

#help [name="help"] {
    position: absolute;
    top: 1em; right: 1em;

    padding: 0 1em;
    height: 32px;
}

#help p {
    margin: 0;
}

#help a {
    color: var(--button-color);
}

#help a:hover {
    color: white;
}

#help a:visited {
    color: gray;
}

#help ul {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    margin: 0 1em;
    padding: 0;
    gap: .5em 1em;
    list-style: none;

    align-content: center;
}

#tool-select input[type="radio"]:checked + img {
    filter: invert();
}

#color-select input[type="radio"]:checked {
    background: none;
    z-index: 5;

    animation-name: selection-flash;
    animation-direction: alternate;
    animation-duration: 2s;
    animation-iteration-count: infinite;
}

#viewport {
    position: relative;
    display: flex; flex-direction: column;
    border-radius: 1em;

    background: var(--trans-gradient);
    padding: .65em;

    justify-content: center;
    align-items: start;

    overflow: hidden;
}

#help {
    position: absolute;
    left: 0; top: 0;
    width: 100%; height: 100%;
    color: white;
    background-color: #000000DD;
    /* border-radius: 1em; */

    display: flex;
    flex-direction: column;
    padding: 1em;
    overflow: auto;
}

#renderer {
    background: magenta;
    touch-action: none;
}

.button-row {
    display: flex;
    flex-direction: row;
    gap: 1em;
}

button {
    flex: 1;
    flex-direction: column;
    white-space: nowrap;

    border: none;
    border-radius: 1em;
    background-color: var(--button-color);

    font-weight: bold;

    display: flex;
    justify-content: center;
    align-items: center;

    padding: .25em;
}

button:active {
    filter: invert();
}

button:disabled {
    opacity: .5;
    cursor: not-allowed;
}

.radio-select label {
    position: relative;

    margin: 0;
    appearance: none;
    -moz-appearance: none;
    -webkit-appearance: none;
    background-color: var(--button-color);

    min-height: 3em;
}

.radio-select input[type="radio"] {
    margin: 0;
    appearance: none;
    -moz-appearance: none;
    -webkit-appearance: none;
    border-radius: inherit;

    position: absolute;
    width: 100%; height: 100%;
}

.radio-select label img, .radio-select label svg, button img, button svg {
    pointer-events: none;
    width: 32px; height: 32px;
}

.radio-select label img, .radio-select label svg {
    position: absolute;
    left: 50%; top: 50%;
    transform: translate(-50%, -50%);
}

.radio-select input[type="radio"]:checked {
    border: none;
    background: blue;
}

.radio-select img {
    filter: brightness(0);
}

.radio-select svg {
    color: black;
}

.radio-select input[type="radio"]:checked + svg {
    color: white;
}

.radio-select input[type="radio"]:checked + img {
    filter: none;
}

@keyframes selection-flash {
    0%   { box-shadow: 0 0 0 .5em black; }
    100% { box-shadow: 0 0 0 .5em white; }
}

.horizontal-capsule > *, .vertical-capsule > * {
    flex: 1;
}

.horizontal-capsule {
    display: flex;
    flex-direction: row;
}

.vertical-capsule {
    display: flex;
    flex-direction: column;
}

.horizontal-capsule > :first-child {
    border-radius: 1em 0 0 1em;
}

.horizontal-capsule > :last-child {
    border-radius: 0 1em 1em 0;
}

.vertical-capsule > :first-child {
    border-radius: 1em 1em 0 0;
}

.vertical-capsule > :last-child {
    border-radius: 0 0 1em 1em;
}

:focus {
    outline: thick solid white;
    z-index: 5;
}
:focus:not(:focus-visible) { 
    outline: unset 
}

:focus + * {
    z-index: 5;
}

.hanging-menu {
    display: flex;
    flex-direction: row;
    gap: 1em;

    height: 32px;
}

.hanging-menu > * {
    background-color: var(--button-color);

    font-weight: bold;
    padding-left: 1em;
    padding-right: 1em;

    border: none;
    border-radius: 0 0 1em 1em;

    display: flex;
    justify-content: center;
    align-items: center;
}

.grid4 {
    display: grid;
    grid-template-columns: repeat(4, auto);
}

.grid8 {
    display: grid;
    grid-template-columns: repeat(8, 1fr);
}

.grid4 label { border-radius: 0; }
.grid4 label:nth-child(1) { border-top-left-radius: 1em; }
.grid4 label:nth-child(4) { border-top-right-radius: 1em; }
.grid4 label:nth-last-child(4) { border-bottom-left-radius: 1em; }
.grid4 label:nth-last-child(1) { border-bottom-right-radius: 1em; }

.grid8 label { border-radius: 0; }
.grid8 label:nth-child(1) { border-top-left-radius: 1em; }
.grid8 label:nth-child(8) { border-top-right-radius: 1em; }
.grid8 label:nth-last-child(8) { border-bottom-left-radius: 1em; }
.grid8 label:nth-last-child(1) { border-bottom-right-radius: 1em; }

.grid8 label :not(input) { border-radius: inherit; }

input[type="text"], textarea {
    font-family: monospace;

    flex: 1;
    flex-basis: 100%;
    min-width: 0;
    padding: .5em .75em;
    border: 0;
    border-radius: .5em;
    color: white;
    background: black;

    margin: 0;
}

.grid3 {
    display: grid;
    grid-template-columns: repeat(3, auto);
}

.grid3 label { border-radius: 0; }
.grid3 label:nth-child(1) { border-top-left-radius: 1em; }
.grid3 label:nth-child(3) { border-top-right-radius: 1em; }
.grid3 label:nth-last-child(3) { border-bottom-left-radius: 1em; }
.grid3 label:nth-last-child(1) { border-bottom-right-radius: 1em; }

    </style>
    <style>body, canvas {
    touch-action: none;
}

#player {
    position: absolute;
    width: 100%; height: 100%;
    overflow: hidden;

    display: flex;
    flex-direction: column;

    padding-bottom: 0;
    gap: 1em;
}

#player-container {
    flex: 1;

    display: flex;
    flex-direction: column;
    justify-content: start;
    align-items: center;

    margin: 0 auto;
    max-width: 512px;
    width: 100%;
}

@media screen and (max-width: 640px) {
    #player-container {
        max-width: 100%;
        width: 100%;
    }
}


#player-container #player-choices{
    margin-top: 0.8em;
    width: 100%;
    padding: 1em;
}
#player-container #player-choices ul{
    font-family: "Press Start 2P";
    list-style: none;
    font-size: 0.8em;
    margin: 0; padding: 0
}
#player-container #player-choices ul li{
    margin: 0; padding: 0;
}
#player-container #player-choices ul li:not(last-child){
    margin-bottom: 1em;
}
#player-container #player-choices a{
    color: white;
    text-decoration: none;
}

    </style>
    <style data-editor-only="data-editor-only">:root {
    --button-color: #ffd800;
    --frame-color: #367b6b;
}

body {
    touch-action: none;
    background: var(--page-color, black);
}

canvas {
    touch-action: none;
}

input[type="text"], textarea {
    font-size: large;
}

.horizontal-capsule {
    flex: 1;
}

.row {
    display: flex; flex-direction: row;
    flex: 1;
}

.column {
    display: flex; flex-direction: column;
    flex: 1;
}

#playtest-rendering {
    background: var(--trans-gradient);
}

#player-menu {
    display: grid;
    grid-auto-flow: column;
    grid-auto-columns: 1fr;
    gap: 1em;

    height: 32px;

    align-self: center;
}

#editor {
    display: flex; flex-direction: row;
    flex-wrap: wrap;
    gap: 1rem;
    align-items: stretch;
}

#controls {
    display: flex; flex-direction: column;

    height: 512px;
    width: 512px;
}

#controls .hanging-menu {
    gap: .5em;
}

#controls .hanging-menu > * {
    border-radius: .75rem;
}

#upper-toolbar {
    display: flex; flex-direction: row;
    gap: .5rem;
}

#upper-toolbar .button-row > * {
    min-width: 48px;
}

#tools {
    flex: 1;

    display: flex; flex-direction: column;
    padding: 1rem; gap: 1rem;

    background: var(--frame-color);
    border-radius: 0 1rem 1rem 1rem;

    overflow: hidden;
}

#renderer {
    height: 512px;
    background: none;
}

#mode-body {
    height: 100%;

    display: flex; flex-direction: column;
}

#mode-select > * {
    border-bottom-left-radius: 0;
    border-bottom-right-radius: 0;
}

#mode-select.radio-select input[type="radio"]:checked {
    background: #367b6b;
}

#undo-row {
    padding-bottom: .5rem;
    gap: .5rem;
}

#undo-row > * {
    border-radius: .75rem;
}

#menu {
    margin-top: .5rem;
}

#palette-edit {
    flex: 1;

    border-radius: 1rem;
    background: var(--trans-gradient);

    padding: 1rem;
    gap: 1rem;
}

#palette-edit-select > :first-child {
    border-radius: 1rem 0 0 0;
}

#palette-edit-select > :last-child {
    border-radius: 0 1rem 0 0;
}

#palette-edit-select label img {
    filter: none;
}

#color-select {
    gap: .5rem;
}

#color-select label {
    min-height: 0;
}

#color-select input[type="radio"]:checked {
    background: none;
    z-index: 5;

    animation: none;
    box-shadow: 0 0 0 .5em white;
}

#color-edit {
    gap: 1rem;
}

label.toggle {
    flex: 1;
    flex-direction: row;
    white-space: nowrap;
    border: none;
    border-radius: 1em;
    background-color: var(--button-color);
    font-weight: bold;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: .25em;

    color: black;
    position: relative;
}

.toggle input {
    appearance: none;
    -moz-appearance: none;
    -webkit-appearance: none;
    margin: 0;
    border-radius: inherit;

    position: absolute;
    width: 100%; height: 100%;
}

.toggle input + svg {
    color: black;

    pointer-events: none;
    width: 32px; height: 32px;
}

.toggle input:checked {
    background: blue;
}

.toggle input:checked + svg {
    color: white;
}

#viewport {
    width: 512px;
    height: calc(512px + 48px + 3.2rem);
    background: none;

    padding: 0;
    border-radius: 0;
    overflow: visible;
}

#tile-paint-tab {
    display: flex; flex-direction: column;
    gap: 1rem;
}

#tile-paint-previews {
    display: flex; flex-direction: row;
    gap: 1rem;
}

#tile-paint-canvases {
    flex: 0;

    display: flex; flex-direction: row;

    padding: 1rem; gap: 1rem;
    background: var(--trans-gradient);
    border-radius: 1rem;

    align-items: center;
    justify-content: space-evenly;
}

#tile-paint-canvases canvas {
    width: 160px; height: 160px;
    cursor: crosshair;
}

#tile-paint-buttons {
    flex: 1;

    display: grid;
    grid-template-columns: repeat(3, auto);
}

#tile-paint-a {
    cursor: not-allowed;
    margin: auto;

    width: 96px;
    height: 96px;
}

#viewport {
    display: flex; flex-direction: column;

    justify-content: unset;
    align-items: unset;

    gap: .5rem;
}

.viewport-toolbar {
    display: flex; flex-direction: row;
    gap: .5rem;
}

#palette-room, #tile-map-paint, #events-room {
    width: 512px; height: 512px;
}

#room-paint-buttons label {
    min-height: unset;
}

#room-paint-buttons .radio-select svg {
    min-height: unset;
    transform: translate(-50%, -50%) scale(75%);
}

#palette-room {
    cursor: not-allowed;
}

#tile-map-tab {
    display: flex; flex-direction: column;
    gap: .5rem;
}

#tile-map-paint {
    cursor: crosshair;
}

#tile-paint-room {
    width: 256px; height: 256px;

    cursor: crosshair;
}

#tile-paint-canvases * {
    background: none;
}

#tile-paint-canvases input:checked {
    pointer-events: none;
    background: none;
}

#tile-paint-canvases input:not(:checked) + canvas {
    pointer-events: none;
    opacity: 50%;
}

select {
    padding: .5em;

    border: none;
    border-radius: 1rem;

    background-color: var(--button-color);
}

#room-events-tab {
    display: flex; flex-direction: column;
    gap: .5rem;

    cursor: pointer;
}

#event-empty {
    display: flex; flex-direction: column;
    gap: .5rem;
}

.event-template-list > button {
    flex: 0;

    display: flex; flex-direction: row;
    padding: .5rem; gap: .5rem;
    justify-content: flex-start;
}

.event-template-list {
    display: grid;
    gap: .5rem;
    grid-template-columns: repeat(2, 1fr);
}

#event-properties {
    display: flex; flex-direction: column;
    gap: 1rem;

    overflow: hidden;
}

#event-properties > .row {
    overflow: hidden;
}

#event-properties textarea {
    flex: 1;
    resize: none;
    border-radius: 1rem;
}

.event-sheet {
    flex: 1;

    display: flex; flex-direction: column;

    border-radius: 1rem 0 0 1rem;
    background: black;
    overflow: hidden scroll;
}

.event-sheet > :nth-child(2n+0) {
    background: var(--trans-color-1);
}

.event-sheet > :nth-child(2n+1) {
    background: var(--trans-color-2);
}

.event-sheet #event-sheet-add {
    flex: 0;
    margin: .5rem;
    background: var(--button-color);
}

.event-line {
    display: flex; flex-direction: row;
    gap: .25rem;

    height: 32px;
    min-height: 32px;

    cursor: pointer;

    gap: .25rem;
    padding: 0 .25rem;
}

.event-line > input, .event-line > select { 
    color: white;
    flex: 1;
    border-radius: 0;
    background: inherit;
    padding-top: 0;
    padding-bottom: 0;
}

.event-line:not(.active) > * {
    pointer-events: none;
}

.event-line.active {
    filter: invert();
}

.event-line :focus {
    outline: thick solid var(--button-color);
    z-index: 5;
}

.event-lines-toolbar {
    flex: unset;
    width: 48px;
    height: 180px;
    gap: .5rem;

    display: flex; flex-direction: column;
}

.event-lines-toolbar > button {
    border-radius: 0 .5rem .5rem 0;
    padding: 0;
    height: 40px;
}

#field-json-editor {
    height: 192px;

    display: flex;
}

#field-file-editor {
    display: flex;
    flex-direction: row;
    gap: .5rem;
}

#field-file-editor button {
    height: 40px;
    border-radius: .75rem;
    padding-left: .75rem;
    padding-right: .75rem;
}

#field-file-sidebar {
    width: 128px;

    display: flex;
    flex-direction: column;
    gap: .5rem;
}

#field-dialogue-editor {
    height: 96px;

    display: flex;
}

#field-dialogue-editor > .row {
    gap: .5rem;
}

#field-dialogue-editor textarea {
    border-radius: .5rem 1rem 1rem .5rem;
}

#dialogue-editor-toolbar {
    display: flex; flex-direction: column;
    gap: .5rem;

    width: 48px;
}

#dialogue-editor-toolbar .toggle {
    border-radius: .5rem;
}


#event-edit, #game-fields-edit {
    gap: 1rem;
    overflow: hidden;
}

#event-edit > *, #game-fields-edit > * {
    flex: 1;
}

#event-action-type-select {
    padding: .5em;

    border: none;
    border-radius: 1rem 0 0 1rem;

    background-color: var(--button-color);

    font-weight: bold;

    height: 48px;
}

#event-selected-toolbar {
    gap: 1rem;
    padding-right: 1rem;
}

#field-tile-editor {
    height: 192px;
}

#field-tile-select {
    padding: .5rem;

    display: flex; flex-direction: row;
    flex-wrap: wrap;
    gap: 5px;
    justify-content: flex-start;

    border-radius: .5rem;
    background: var(--trans-gradient);
    overflow: hidden scroll;

    width: 100%;
    height: 100%;
}

#field-tile-select label {
    min-height: unset;

    width: 40px; height: 40px;

    background-color: var(--tileset-background-color);
    background-image: var(--tileset-background-image);
    background-size: var(--tileset-background-size);
}

#field-tile-select input[type="radio"]:checked {
    background: none;
    z-index: 5;

    box-shadow: 0 0 0 5px white;
}

#play-tab-view canvas {
    width: 512px; height: 512px;
}

details > summary {
    font-size: 1.5em;
    font-weight: bold;
    color: var(--button-color);
}

h2 {
    font-size: 1.5em;
    font-weight: bold;
    color: var(--button-color);
}

#play-tab-body {
    font-size: larger;
}

a {
    color: var(--button-color);
    font-weight: bold;
}

a:hover {
    color: white;
}

a:visited {
    color: #cef0df;
}

em {
    font-weight: bold;
    color: var(--button-color);
}

    </style>
    <style data-editor-only="data-editor-only">#playtest {
    position: absolute;
    width: 512px; height: 100%;
    left: 0; top: 0;

    border: none;
}

#palette-picker {
    position: absolute;
    right: 0; bottom: 56px;
    width: 256px;
    height: 256px;

    background: var(--button-color);
    border-radius: 1.5rem 0 0 1.5rem;
    padding: .5rem;

    display: flex;
}

#palette-picker-palettes {
    background: var(--trans-gradient);
    border-radius: 1rem;
    padding: .5rem;
    gap: .5rem;

    overflow: hidden scroll;
}

#palette-picker label {
    border-radius: 1rem;
}

#palette-picker input[type="radio"]:checked {
    background: none;
    z-index: 5;
    animation: none;
    box-shadow: 0 0 0 0.5em white;
}

#tile-select-tab {
    flex: 1;

    position: relative;
    display: flex; flex-direction: column;
    gap: .5rem;

    overflow: hidden;
}

.tile-buttons {
    display: flex; flex-direction: row;
    gap: .5rem;
}

.tile-buttons > * {
    width: 56px;
    height: 40px;

    border-radius: .75rem;
}

#tile-select {
    flex: 1;

    padding: .5rem;

    display: flex; flex-direction: row;
    flex-wrap: wrap;
    gap: 5px;
    justify-content: flex-start;
    align-content: flex-start;

    border-radius: .5rem;
    background: var(--trans-gradient);
    overflow: hidden scroll;
}

#tile-select label {
    min-height: unset;

    width: 40px; height: 40px;

    background-color: var(--tileset-background-color);
    background-image: var(--tileset-background-image);
    background-size: var(--tileset-background-size);
}

#tile-select input[type="radio"]:checked {
    background: none;
    z-index: 5;

    box-shadow: 0 0 0 5px white;
}

#room-select-tab {
    display: flex; flex-direction: column;
    gap: .5rem;

    padding-bottom: 1rem;

    height: 240px;
}

.room-buttons {
    display: flex; flex-direction: row;
    gap: .5rem;
}

.room-buttons > * {
    width: 56px;
    height: 40px;

    border-radius: .75rem;
}

.room-select {
    --room-size: calc(16px * 3);

    flex: 1;

    padding: .5rem;

    display: flex; flex-direction: row;
    flex-wrap: wrap;
    gap: .5rem;
    justify-content: flex-start;
    align-content: flex-start;

    border-radius: .5rem;
    background: var(--trans-gradient);
    overflow: hidden scroll;
}

.room-select label {
    min-height: unset;

    width: var(--room-size);
    height: var(--room-size);
}

.room-select input[type="radio"]:checked {
    background: none;
    z-index: 5;

    box-shadow: 0 0 0 5px white;
}

.room-select canvas {
    width: 100%; height: 100%;
}

#field-location-editor {
    display: flex; flex-direction: row;
    gap: 1rem;

    height: 236px;
}

#field-position-select {
    background: var(--trans-gradient);

    height: 236px;
}

#tile-paint-buttons > * {
    max-width: unset;
}

input + svg {
    z-index: 6;
}

label.toggle#tile-grid {
    max-width: 64px;
}

#room-picker-toggle {
    gap: .25rem;
}

#events-room-select-window {
    position: absolute;
    width: 512px; height: 256px;
    bottom: calc(48px + .5rem);

    display: flex; flex-direction: column;
    border-radius: 1rem;
    padding: 1rem; gap: .5rem;

    background: var(--frame-color);

    cursor: initial;
}

    </style>
  </head>
  <body class="no-select" onload="start()">
    <div id="player" data-hidden-in-editor="data-hidden-in-editor">
      <div id="player-container">
        <canvas id="player-canvas" width="256" height="256"></canvas>
        <div id="player-choices">
          <ul id="player-choices-list"></ul>
        </div>
      </div>
    </div>
    <div id="editor" data-editor-only="data-editor-only">
      <div id="viewport">
        <div id="play-tab-view" hidden="hidden">
          <canvas id="playtest-rendering" width="256" height="256" tabindex="0"></canvas>
          <iframe id="playtest" hidden="hidden"></iframe>
        </div>
        <div id="palette-tab" hidden="hidden">
          <canvas id="palette-room" width="128" height="128" draggable="false"></canvas>
        </div>
        <div id="room-events-tab" hidden="hidden">
          <canvas id="events-room" width="256" height="256"></canvas>
          <div id="events-room-select-window" hidden="hidden">
            <div class="room-buttons">
              <button name="add-new-room" title="add new room"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z"/></svg></button>
              <button name="duplicate-room" title="duplicate selected room"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M13 0H6a2 2 0 0 0-2 2 2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h7a2 2 0 0 0 2-2 2 2 0 0 0 2-2V2a2 2 0 0 0-2-2zm0 13V4a2 2 0 0 0-2-2H5a1 1 0 0 1 1-1h7a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1zM3 4a1 1 0 0 1 1-1h7a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V4z"/></svg></button>
              <button name="reorder-room-before" title="reorder room before"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M15 8a.5.5 0 0 0-.5-.5H2.707l3.147-3.146a.5.5 0 1 0-.708-.708l-4 4a.5.5 0 0 0 0 .708l4 4a.5.5 0 0 0 .708-.708L2.707 8.5H14.5A.5.5 0 0 0 15 8z"/></svg></button>
              <button name="reorder-room-after" title="reorder room after"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M1 8a.5.5 0 0 1 .5-.5h11.793l-3.147-3.146a.5.5 0 0 1 .708-.708l4 4a.5.5 0 0 1 0 .708l-4 4a.5.5 0 0 1-.708-.708L13.293 8.5H1.5A.5.5 0 0 1 1 8z"/></svg></button>
              <button name="delete-room" title="delete selected room"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/><path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/></svg></button>
            </div>
            <div class="room-select radio-select" id="events-room-select" title="select room">
              <template id="events-room-select-template">
                <label>
                  <input type="radio" name="events-room-select" value="0" title="select room 0"/>
                  <canvas width="16" height="16"></canvas>
                </label>
              </template>
            </div>
          </div>
          <div class="viewport-toolbar" id="room-events-toolbar">
            <button name="copy-event" title="copy event"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M13 0H6a2 2 0 0 0-2 2 2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h7a2 2 0 0 0 2-2 2 2 0 0 0 2-2V2a2 2 0 0 0-2-2zm0 13V4a2 2 0 0 0-2-2H5a1 1 0 0 1 1-1h7a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1zM3 4a1 1 0 0 1 1-1h7a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V4z"/></svg></button>
            <button name="paste-event" title="paste event"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M4 11a1 1 0 1 1 2 0v1a1 1 0 1 1-2 0v-1zm6-4a1 1 0 1 1 2 0v5a1 1 0 1 1-2 0V7zM7 9a1 1 0 0 1 2 0v3a1 1 0 1 1-2 0V9z"/><path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/><path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/></svg></button>
            <button name="delete-event" title="delete event"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/><path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/></svg></button>
            <label class="toggle" id="room-picker-toggle">
              <input type="checkbox" name="events-switch-room" title="switch room"/><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M0 1.5A1.5 1.5 0 0 1 1.5 0h13A1.5 1.5 0 0 1 16 1.5v13a1.5 1.5 0 0 1-1.5 1.5h-13A1.5 1.5 0 0 1 0 14.5v-13zM1.5 1a.5.5 0 0 0-.5.5V5h4V1H1.5zM5 6H1v4h4V6zm1 4h4V6H6v4zm-1 1H1v3.5a.5.5 0 0 0 .5.5H5v-4zm1 0v4h4v-4H6zm5 0v4h3.5a.5.5 0 0 0 .5-.5V11h-4zm0-1h4V6h-4v4zm0-5h4V1.5a.5.5 0 0 0-.5-.5H11v4zm-1 0V1H6v4h4z"/></svg>
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-caret-up-fill" viewBox="0 0 16 16"><path d="m7.247 4.86-4.796 5.481c-.566.647-.106 1.659.753 1.659h9.592a1 1 0 0 0 .753-1.659l-4.796-5.48a1 1 0 0 0-1.506 0z"/></svg>
            </label>
          </div>
        </div>
        <div id="tile-paint-tab" hidden="hidden">
          <div class="row">
            <canvas id="tile-paint-a" width="8" height="8" draggable="false" title="tile animation preview"></canvas>
            <div class="radio-select" id="tile-paint-canvases">
              <label>
                <input type="radio" name="tile-paint-frame"/>
                <canvas id="tile-paint-0" width="160" height="160" draggable="false" title="edit tile frame 0"></canvas>
              </label>
              <label>
                <input type="radio" name="tile-paint-frame"/>
                <canvas id="tile-paint-1" width="160" height="160" draggable="false" title="edit tile frame 1"></canvas>
              </label>
            </div>
          </div>
          <div id="tile-paint-previews">
            <canvas id="tile-paint-room" width="128" height="128" draggable="false"></canvas>
            <div class="viewport-toolbar" id="tile-paint-buttons">
              <button name="rotate-tile-anticlockwise" title="rotate tile anticlockwise"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M1.146 4.854a.5.5 0 0 1 0-.708l4-4a.5.5 0 1 1 .708.708L2.707 4H12.5A2.5 2.5 0 0 1 15 6.5v8a.5.5 0 0 1-1 0v-8A1.5 1.5 0 0 0 12.5 5H2.707l3.147 3.146a.5.5 0 1 1-.708.708l-4-4z"/></svg></button>
              <button name="shift-tile-up" title="shift tile up"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 15a.5.5 0 0 0 .5-.5V2.707l3.146 3.147a.5.5 0 0 0 .708-.708l-4-4a.5.5 0 0 0-.708 0l-4 4a.5.5 0 1 0 .708.708L7.5 2.707V14.5a.5.5 0 0 0 .5.5z"/></svg></button>
              <button name="rotate-tile-clockwise" title="rotate tile clockwise"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-arrow-90deg-right" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M14.854 4.854a.5.5 0 0 0 0-.708l-4-4a.5.5 0 0 0-.708.708L13.293 4H3.5A2.5 2.5 0 0 0 1 6.5v8a.5.5 0 0 0 1 0v-8A1.5 1.5 0 0 1 3.5 5h9.793l-3.147 3.146a.5.5 0 0 0 .708.708l4-4z"/></svg></button>
              <button name="shift-tile-left" title="shift tile left"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M15 8a.5.5 0 0 0-.5-.5H2.707l3.147-3.146a.5.5 0 1 0-.708-.708l-4 4a.5.5 0 0 0 0 .708l4 4a.5.5 0 0 0 .708-.708L2.707 8.5H14.5A.5.5 0 0 0 15 8z"/></svg></button>
              <button name="shift-tile-down" title="shift tile down"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 1a.5.5 0 0 1 .5.5v11.793l3.146-3.147a.5.5 0 0 1 .708.708l-4 4a.5.5 0 0 1-.708 0l-4-4a.5.5 0 0 1 .708-.708L7.5 13.293V1.5A.5.5 0 0 1 8 1z"/></svg></button>
              <button name="shift-tile-right" title="shift tile right"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M1 8a.5.5 0 0 1 .5-.5h11.793l-3.147-3.146a.5.5 0 0 1 .708-.708l4 4a.5.5 0 0 1 0 .708l-4 4a.5.5 0 0 1-.708-.708L13.293 8.5H1.5A.5.5 0 0 1 1 8z"/></svg></button>
              <button name="mirror-tile" title="mirror tile"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M7 2.5a.5.5 0 0 0-.939-.24l-6 11A.5.5 0 0 0 .5 14h6a.5.5 0 0 0 .5-.5v-11zm2.376-.484a.5.5 0 0 1 .563.245l6 11A.5.5 0 0 1 15.5 14h-6a.5.5 0 0 1-.5-.5v-11a.5.5 0 0 1 .376-.484zM10 4.46V13h4.658L10 4.46z"/></svg></button>
              <button name="flip-tile" title="flip tile"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M13.5 7a.5.5 0 0 0 .24-.939l-11-6A.5.5 0 0 0 2 .5v6a.5.5 0 0 0 .5.5h11zm.485 2.376a.5.5 0 0 1-.246.563l-11 6A.5.5 0 0 1 2 15.5v-6a.5.5 0 0 1 .5-.5h11a.5.5 0 0 1 .485.376zM11.539 10H3v4.658L11.54 10z"/></svg></button>
              <button name="invert-tile" title="invert tile"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M9.05.435c-.58-.58-1.52-.58-2.1 0L.436 6.95c-.58.58-.58 1.519 0 2.098l6.516 6.516c.58.58 1.519.58 2.098 0l6.516-6.516c.58-.58.58-1.519 0-2.098L9.05.435zM8 .989c.127 0 .253.049.35.145l6.516 6.516a.495.495 0 0 1 0 .7L8.35 14.866a.493.493 0 0 1-.35.145V.989z"/></svg></button>
              <button name="copy-tile-frame" title="copy frame"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M13 0H6a2 2 0 0 0-2 2 2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h7a2 2 0 0 0 2-2 2 2 0 0 0 2-2V2a2 2 0 0 0-2-2zm0 13V4a2 2 0 0 0-2-2H5a1 1 0 0 1 1-1h7a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1zM3 4a1 1 0 0 1 1-1h7a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V4z"/></svg></button>
              <button name="paste-tile-frame" title="paste frame"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M4 11a1 1 0 1 1 2 0v1a1 1 0 1 1-2 0v-1zm6-4a1 1 0 1 1 2 0v5a1 1 0 1 1-2 0V7zM7 9a1 1 0 0 1 2 0v3a1 1 0 1 1-2 0V9z"/><path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/><path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/></svg></button>
              <button name="clear-tile-frame" title="clear frame"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/><path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/></svg></button>
              <button name="swap-tile-frames" title="swap frames"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M1 11.5a.5.5 0 0 0 .5.5h11.793l-3.147 3.146a.5.5 0 0 0 .708.708l4-4a.5.5 0 0 0 0-.708l-4-4a.5.5 0 0 0-.708.708L13.293 11H1.5a.5.5 0 0 0-.5.5zm14-7a.5.5 0 0 1-.5.5H2.707l3.147 3.146a.5.5 0 1 1-.708.708l-4-4a.5.5 0 0 1 0-.708l4-4a.5.5 0 1 1 .708.708L2.707 4H14.5a.5.5 0 0 1 .5.5z"/></svg></button>
              <label class="toggle">
                <input type="checkbox" name="tile-animated" title="toggle animated"/><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M10.804 8 5 4.633v6.734L10.804 8zm.792-.696a.802.802 0 0 1 0 1.392l-6.363 3.692C4.713 12.69 4 12.345 4 11.692V4.308c0-.653.713-.998 1.233-.696l6.363 3.692z"/></svg>
              </label>
              <label class="toggle">
                <input type="checkbox" name="tile-grid" title="toggle grid"/><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-border" viewBox="0 0 16 16"><path d="M0 0h.969v.5H1v.469H.969V1H.5V.969H0V0zm2.844 1h-.938V0h.938v1zm1.875 0H3.78V0h.938v1zm1.875 0h-.938V0h.938v1zm.937 0V.969H7.5V.5h.031V0h.938v.5H8.5v.469h-.031V1H7.53zm2.813 0h-.938V0h.938v1zm1.875 0h-.938V0h.938v1zm1.875 0h-.938V0h.938v1zM15.5 1h-.469V.969H15V.5h.031V0H16v.969h-.5V1zM1 1.906v.938H0v-.938h1zm6.5.938v-.938h1v.938h-1zm7.5 0v-.938h1v.938h-1zM1 3.78v.938H0V3.78h1zm6.5.938V3.78h1v.938h-1zm7.5 0V3.78h1v.938h-1zM1 5.656v.938H0v-.938h1zm6.5.938v-.938h1v.938h-1zm7.5 0v-.938h1v.938h-1zM.969 8.5H.5v-.031H0V7.53h.5V7.5h.469v.031H1v.938H.969V8.5zm1.875 0h-.938v-1h.938v1zm1.875 0H3.78v-1h.938v1zm1.875 0h-.938v-1h.938v1zm1.875-.031V8.5H7.53v-.031H7.5V7.53h.031V7.5h.938v.031H8.5v.938h-.031zm1.875.031h-.938v-1h.938v1zm1.875 0h-.938v-1h.938v1zm1.875 0h-.938v-1h.938v1zm1.406 0h-.469v-.031H15V7.53h.031V7.5h.469v.031h.5v.938h-.5V8.5zM0 10.344v-.938h1v.938H0zm7.5 0v-.938h1v.938h-1zm8.5-.938v.938h-1v-.938h1zM0 12.22v-.938h1v.938H0zm7.5 0v-.938h1v.938h-1zm8.5-.938v.938h-1v-.938h1zM0 14.094v-.938h1v.938H0zm7.5 0v-.938h1v.938h-1zm8.5-.938v.938h-1v-.938h1zM.969 16H0v-.969h.5V15h.469v.031H1v.469H.969v.5zm1.875 0h-.938v-1h.938v1zm1.875 0H3.78v-1h.938v1zm1.875 0h-.938v-1h.938v1zm.937 0v-.5H7.5v-.469h.031V15h.938v.031H8.5v.469h-.031v.5H7.53zm2.813 0h-.938v-1h.938v1zm1.875 0h-.938v-1h.938v1zm1.875 0h-.938v-1h.938v1zm.937 0v-.5H15v-.469h.031V15h.469v.031h.5V16h-.969z"/></svg>
              </label>
            </div>
          </div>
        </div>
        <div id="tile-map-tab" hidden="hidden">
          <canvas id="tile-map-paint" width="256" height="256" draggable="false"></canvas>
          <div class="viewport-toolbar" id="tile-map-toolbar">
            <div class="horizontal-capsule radio-select">
              <label>
                <input type="radio" name="room-paint-tool" value="tile" title="draw tiles"/><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M0 1.5A1.5 1.5 0 0 1 1.5 0h13A1.5 1.5 0 0 1 16 1.5v13a1.5 1.5 0 0 1-1.5 1.5h-13A1.5 1.5 0 0 1 0 14.5v-13zM1.5 1a.5.5 0 0 0-.5.5V5h4V1H1.5zM5 6H1v4h4V6zm1 4h4V6H6v4zm-1 1H1v3.5a.5.5 0 0 0 .5.5H5v-4zm1 0v4h4v-4H6zm5 0v4h3.5a.5.5 0 0 0 .5-.5V11h-4zm0-1h4V6h-4v4zm0-5h4V1.5a.5.5 0 0 0-.5-.5H11v4zm-1 0V1H6v4h4z"/></svg>
              </label>
              <label>
                <input type="radio" name="room-paint-tool" value="high" title="draw highlights"/><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M7.657 6.247c.11-.33.576-.33.686 0l.645 1.937a2.89 2.89 0 0 0 1.829 1.828l1.936.645c.33.11.33.576 0 .686l-1.937.645a2.89 2.89 0 0 0-1.828 1.829l-.645 1.936a.361.361 0 0 1-.686 0l-.645-1.937a2.89 2.89 0 0 0-1.828-1.828l-1.937-.645a.361.361 0 0 1 0-.686l1.937-.645a2.89 2.89 0 0 0 1.828-1.828l.645-1.937zM3.794 1.148a.217.217 0 0 1 .412 0l.387 1.162c.173.518.579.924 1.097 1.097l1.162.387a.217.217 0 0 1 0 .412l-1.162.387A1.734 1.734 0 0 0 4.593 5.69l-.387 1.162a.217.217 0 0 1-.412 0L3.407 5.69A1.734 1.734 0 0 0 2.31 4.593l-1.162-.387a.217.217 0 0 1 0-.412l1.162-.387A1.734 1.734 0 0 0 3.407 2.31l.387-1.162zM10.863.099a.145.145 0 0 1 .274 0l.258.774c.115.346.386.617.732.732l.774.258a.145.145 0 0 1 0 .274l-.774.258a1.156 1.156 0 0 0-.732.732l-.258.774a.145.145 0 0 1-.274 0l-.258-.774a1.156 1.156 0 0 0-.732-.732L9.1 2.137a.145.145 0 0 1 0-.274l.774-.258c.346-.115.617-.386.732-.732L10.863.1z"/></svg>
              </label>
              <label>
                <input type="radio" name="room-paint-tool" value="pick" title="pick tile"/><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M13.354.646a1.207 1.207 0 0 0-1.708 0L8.5 3.793l-.646-.647a.5.5 0 1 0-.708.708L8.293 5l-7.147 7.146A.5.5 0 0 0 1 12.5v1.793l-.854.853a.5.5 0 1 0 .708.707L1.707 15H3.5a.5.5 0 0 0 .354-.146L11 7.707l1.146 1.147a.5.5 0 0 0 .708-.708l-.647-.646 3.147-3.146a1.207 1.207 0 0 0 0-1.708l-2-2zM2 12.707l7-7L10.293 7l-7 7H2v-1.293z"/></svg>
              </label>
              <label>
                <input type="radio" name="room-paint-tool" value="shift" title="shift tiles"/><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M7.646.146a.5.5 0 0 1 .708 0l2 2a.5.5 0 0 1-.708.708L8.5 1.707V5.5a.5.5 0 0 1-1 0V1.707L6.354 2.854a.5.5 0 1 1-.708-.708l2-2zM8 10a.5.5 0 0 1 .5.5v3.793l1.146-1.147a.5.5 0 0 1 .708.708l-2 2a.5.5 0 0 1-.708 0l-2-2a.5.5 0 0 1 .708-.708L7.5 14.293V10.5A.5.5 0 0 1 8 10zM.146 8.354a.5.5 0 0 1 0-.708l2-2a.5.5 0 1 1 .708.708L1.707 7.5H5.5a.5.5 0 0 1 0 1H1.707l1.147 1.146a.5.5 0 0 1-.708.708l-2-2zM10 8a.5.5 0 0 1 .5-.5h3.793l-1.147-1.146a.5.5 0 0 1 .708-.708l2 2a.5.5 0 0 1 0 .708l-2 2a.5.5 0 0 1-.708-.708L14.293 8.5H10.5A.5.5 0 0 1 10 8z"/></svg>
              </label>
              <label>
                <input type="radio" name="room-paint-tool" value="wall" title="draw walls"/><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M0 .5A.5.5 0 0 1 .5 0h15a.5.5 0 0 1 .5.5v3a.5.5 0 0 1-.5.5H14v2h1.5a.5.5 0 0 1 .5.5v3a.5.5 0 0 1-.5.5H14v2h1.5a.5.5 0 0 1 .5.5v3a.5.5 0 0 1-.5.5H.5a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1 .5-.5H2v-2H.5a.5.5 0 0 1-.5-.5v-3A.5.5 0 0 1 .5 6H2V4H.5a.5.5 0 0 1-.5-.5v-3zM3 4v2h4.5V4H3zm5.5 0v2H13V4H8.5zM3 10v2h4.5v-2H3zm5.5 0v2H13v-2H8.5zM1 1v2h3.5V1H1zm4.5 0v2h5V1h-5zm6 0v2H15V1h-3.5zM1 7v2h3.5V7H1zm4.5 0v2h5V7h-5zm6 0v2H15V7h-3.5zM1 13v2h3.5v-2H1zm4.5 0v2h5v-2h-5zm6 0v2H15v-2h-3.5z"/></svg>
              </label>
            </div>
            <label class="toggle" id="tile-grid">
              <input type="checkbox" name="room-grid" title="toggle grid"/><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-border" viewBox="0 0 16 16"><path d="M0 0h.969v.5H1v.469H.969V1H.5V.969H0V0zm2.844 1h-.938V0h.938v1zm1.875 0H3.78V0h.938v1zm1.875 0h-.938V0h.938v1zm.937 0V.969H7.5V.5h.031V0h.938v.5H8.5v.469h-.031V1H7.53zm2.813 0h-.938V0h.938v1zm1.875 0h-.938V0h.938v1zm1.875 0h-.938V0h.938v1zM15.5 1h-.469V.969H15V.5h.031V0H16v.969h-.5V1zM1 1.906v.938H0v-.938h1zm6.5.938v-.938h1v.938h-1zm7.5 0v-.938h1v.938h-1zM1 3.78v.938H0V3.78h1zm6.5.938V3.78h1v.938h-1zm7.5 0V3.78h1v.938h-1zM1 5.656v.938H0v-.938h1zm6.5.938v-.938h1v.938h-1zm7.5 0v-.938h1v.938h-1zM.969 8.5H.5v-.031H0V7.53h.5V7.5h.469v.031H1v.938H.969V8.5zm1.875 0h-.938v-1h.938v1zm1.875 0H3.78v-1h.938v1zm1.875 0h-.938v-1h.938v1zm1.875-.031V8.5H7.53v-.031H7.5V7.53h.031V7.5h.938v.031H8.5v.938h-.031zm1.875.031h-.938v-1h.938v1zm1.875 0h-.938v-1h.938v1zm1.875 0h-.938v-1h.938v1zm1.406 0h-.469v-.031H15V7.53h.031V7.5h.469v.031h.5v.938h-.5V8.5zM0 10.344v-.938h1v.938H0zm7.5 0v-.938h1v.938h-1zm8.5-.938v.938h-1v-.938h1zM0 12.22v-.938h1v.938H0zm7.5 0v-.938h1v.938h-1zm8.5-.938v.938h-1v-.938h1zM0 14.094v-.938h1v.938H0zm7.5 0v-.938h1v.938h-1zm8.5-.938v.938h-1v-.938h1zM.969 16H0v-.969h.5V15h.469v.031H1v.469H.969v.5zm1.875 0h-.938v-1h.938v1zm1.875 0H3.78v-1h.938v1zm1.875 0h-.938v-1h.938v1zm.937 0v-.5H7.5v-.469h.031V15h.938v.031H8.5v.469h-.031v.5H7.53zm2.813 0h-.938v-1h.938v1zm1.875 0h-.938v-1h.938v1zm1.875 0h-.938v-1h.938v1zm.937 0v-.5H15v-.469h.031V15h.469v.031h.5V16h-.969z"/></svg>
            </label>
            <select name="room-palette">
              <option value="0">palette 0</option>
              <option value="1">palette 1</option>
              <option value="2">palette 2</option>
              <option value="3">palette 3</option>
              <option value="4">palette 4</option>
              <option value="5">palette 5</option>
              <option value="6">palette 6</option>
              <option value="7">palette 7</option>
            </select>
          </div>
        </div>
        <div id="palette-picker" hidden="hidden">
          <div class="column radio-select" id="palette-picker-palettes" title="select palette">
            <label id="palette-picker-template" hidden="hidden">
              <input type="radio" name="palette-picker-select" value="undefined,undefined" title="select palette undefined"/>
            </label>
          </div>
        </div>
      </div>
      <div id="controls">
        <div id="upper-toolbar">
          <div class="horizontal-capsule radio-select" id="mode-select" title="mode-select">
            <label>
              <input type="radio" name="mode-select" value="playtest" title="playtest" autocomplete="off"/><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M10.804 8 5 4.633v6.734L10.804 8zm.792-.696a.802.802 0 0 1 0 1.392l-6.363 3.692C4.713 12.69 4 12.345 4 11.692V4.308c0-.653.713-.998 1.233-.696l6.363 3.692z"/></svg>
            </label>
            <label>
              <input type="radio" name="mode-select" value="palettes" title="palettes"/><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M8 5a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3zm4 3a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3zM5.5 7a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm.5 6a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3z"/><path d="M16 8c0 3.15-1.866 2.585-3.567 2.07C11.42 9.763 10.465 9.473 10 10c-.603.683-.475 1.819-.351 2.92C9.826 14.495 9.996 16 8 16a8 8 0 1 1 8-8zm-8 7c.611 0 .654-.171.655-.176.078-.146.124-.464.07-1.119-.014-.168-.037-.37-.061-.591-.052-.464-.112-1.005-.118-1.462-.01-.707.083-1.61.704-2.314.369-.417.845-.578 1.272-.618.404-.038.812.026 1.16.104.343.077.702.186 1.025.284l.028.008c.346.105.658.199.953.266.653.148.904.083.991.024C14.717 9.38 15 9.161 15 8a7 7 0 1 0-7 7z"/></svg>
            </label>
            <label>
              <input type="radio" name="mode-select" value="draw-tiles" title="draw tiles"/><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M12.146.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1 0 .708l-10 10a.5.5 0 0 1-.168.11l-5 2a.5.5 0 0 1-.65-.65l2-5a.5.5 0 0 1 .11-.168l10-10zM11.207 2.5 13.5 4.793 14.793 3.5 12.5 1.207 11.207 2.5zm1.586 3L10.5 3.207 4 9.707V10h.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.5h.293l6.5-6.5zm-9.761 5.175-.106.106-1.528 3.821 3.821-1.528.106-.106A.5.5 0 0 1 5 12.5V12h-.5a.5.5 0 0 1-.5-.5V11h-.5a.5.5 0 0 1-.468-.325z"/></svg>
            </label>
            <label>
              <input type="radio" name="mode-select" value="draw-room" title="draw room"/><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M0 1.5A1.5 1.5 0 0 1 1.5 0h13A1.5 1.5 0 0 1 16 1.5v13a1.5 1.5 0 0 1-1.5 1.5h-13A1.5 1.5 0 0 1 0 14.5v-13zM1.5 1a.5.5 0 0 0-.5.5V5h4V1H1.5zM5 6H1v4h4V6zm1 4h4V6H6v4zm-1 1H1v3.5a.5.5 0 0 0 .5.5H5v-4zm1 0v4h4v-4H6zm5 0v4h3.5a.5.5 0 0 0 .5-.5V11h-4zm0-1h4V6h-4v4zm0-5h4V1.5a.5.5 0 0 0-.5-.5H11v4zm-1 0V1H6v4h4z"/></svg>
            </label>
            <label>
              <input type="radio" name="mode-select" value="events" title="events"/><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M1.5 1a.5.5 0 0 0-.5.5v3a.5.5 0 0 1-1 0v-3A1.5 1.5 0 0 1 1.5 0h3a.5.5 0 0 1 0 1h-3zM11 .5a.5.5 0 0 1 .5-.5h3A1.5 1.5 0 0 1 16 1.5v3a.5.5 0 0 1-1 0v-3a.5.5 0 0 0-.5-.5h-3a.5.5 0 0 1-.5-.5zM.5 11a.5.5 0 0 1 .5.5v3a.5.5 0 0 0 .5.5h3a.5.5 0 0 1 0 1h-3A1.5 1.5 0 0 1 0 14.5v-3a.5.5 0 0 1 .5-.5zm15 0a.5.5 0 0 1 .5.5v3a1.5 1.5 0 0 1-1.5 1.5h-3a.5.5 0 0 1 0-1h3a.5.5 0 0 0 .5-.5v-3a.5.5 0 0 1 .5-.5z"/><path d="M3 14s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1H3zm8-9a3 3 0 1 1-6 0 3 3 0 0 1 6 0z"/></svg>
            </label>
            <!--label
            input(type="radio" name="mode-select" value="extras" title="extras")
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M7.657 6.247c.11-.33.576-.33.686 0l.645 1.937a2.89 2.89 0 0 0 1.829 1.828l1.936.645c.33.11.33.576 0 .686l-1.937.645a2.89 2.89 0 0 0-1.828 1.829l-.645 1.936a.361.361 0 0 1-.686 0l-.645-1.937a2.89 2.89 0 0 0-1.828-1.828l-1.937-.645a.361.361 0 0 1 0-.686l1.937-.645a2.89 2.89 0 0 0 1.828-1.828l.645-1.937zM3.794 1.148a.217.217 0 0 1 .412 0l.387 1.162c.173.518.579.924 1.097 1.097l1.162.387a.217.217 0 0 1 0 .412l-1.162.387A1.734 1.734 0 0 0 4.593 5.69l-.387 1.162a.217.217 0 0 1-.412 0L3.407 5.69A1.734 1.734 0 0 0 2.31 4.593l-1.162-.387a.217.217 0 0 1 0-.412l1.162-.387A1.734 1.734 0 0 0 3.407 2.31l.387-1.162zM10.863.099a.145.145 0 0 1 .274 0l.258.774c.115.346.386.617.732.732l.774.258a.145.145 0 0 1 0 .274l-.774.258a1.156 1.156 0 0 0-.732.732l-.258.774a.145.145 0 0 1-.274 0l-.258-.774a1.156 1.156 0 0 0-.732-.732L9.1 2.137a.145.145 0 0 1 0-.274l.774-.258c.346-.115.617-.386.732-.732L10.863.1z"/></svg>
            -->
          </div>
          <div class="button-row" id="undo-row">
            <button name="undo" title="undo"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 3a5 5 0 1 1-4.546 2.914.5.5 0 0 0-.908-.417A6 6 0 1 0 8 2v1z"/><path d="M8 4.466V.534a.25.25 0 0 0-.41-.192L5.23 2.308a.25.25 0 0 0 0 .384l2.36 1.966A.25.25 0 0 0 8 4.466z"/></svg></button>
            <button name="redo" title="redo"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/><path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"/></svg></button>
            <button name="save" title="save"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-disc" viewBox="0 0 16 16"><path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/><path d="M10 8a2 2 0 1 1-4 0 2 2 0 0 1 4 0zM8 4a4 4 0 0 0-4 4 .5.5 0 0 1-1 0 5 5 0 0 1 5-5 .5.5 0 0 1 0 1zm4.5 3.5a.5.5 0 0 1 .5.5 5 5 0 0 1-5 5 .5.5 0 0 1 0-1 4 4 0 0 0 4-4 .5.5 0 0 1 .5-.5z"/></svg></button>
          </div>
        </div>
        <div id="tools">
          <div id="mode-body">
            <div id="room-select-tab" hidden="hidden">
              <div class="room-buttons">
                <button name="add-new-room" title="add new room"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z"/></svg></button>
                <button name="duplicate-room" title="duplicate selected room"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M13 0H6a2 2 0 0 0-2 2 2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h7a2 2 0 0 0 2-2 2 2 0 0 0 2-2V2a2 2 0 0 0-2-2zm0 13V4a2 2 0 0 0-2-2H5a1 1 0 0 1 1-1h7a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1zM3 4a1 1 0 0 1 1-1h7a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V4z"/></svg></button>
                <button name="reorder-room-before" title="reorder room before"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M15 8a.5.5 0 0 0-.5-.5H2.707l3.147-3.146a.5.5 0 1 0-.708-.708l-4 4a.5.5 0 0 0 0 .708l4 4a.5.5 0 0 0 .708-.708L2.707 8.5H14.5A.5.5 0 0 0 15 8z"/></svg></button>
                <button name="reorder-room-after" title="reorder room after"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M1 8a.5.5 0 0 1 .5-.5h11.793l-3.147-3.146a.5.5 0 0 1 .708-.708l4 4a.5.5 0 0 1 0 .708l-4 4a.5.5 0 0 1-.708-.708L13.293 8.5H1.5A.5.5 0 0 1 1 8z"/></svg></button>
                <button name="delete-room" title="delete selected room"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/><path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/></svg></button>
              </div>
              <div class="room-select radio-select" id="room-select" title="select rooms">
                <template id="room-select-template">
                  <label>
                    <input type="radio" name="room-select" value="0" title="select room 0"/>
                    <canvas width="16" height="16"></canvas>
                  </label>
                </template>
              </div>
            </div>
            <div id="tile-select-tab" hidden="hidden">
              <div class="radio-select" id="tile-select" title="select tiles">
                <template id="tile-select-template">
                  <label>
                    <input type="radio" name="tile-select"/>
                  </label>
                </template>
              </div>
              <div class="tile-buttons" id="tile-buttons">
                <button name="add-new-tile" title="add new tile"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z"/></svg></button>
                <button name="duplicate-tile" title="duplicate selected tile"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M13 0H6a2 2 0 0 0-2 2 2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h7a2 2 0 0 0 2-2 2 2 0 0 0 2-2V2a2 2 0 0 0-2-2zm0 13V4a2 2 0 0 0-2-2H5a1 1 0 0 1 1-1h7a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1zM3 4a1 1 0 0 1 1-1h7a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V4z"/></svg></button>
                <button name="reorder-tile-before" title="reorder tile before"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M15 8a.5.5 0 0 0-.5-.5H2.707l3.147-3.146a.5.5 0 1 0-.708-.708l-4 4a.5.5 0 0 0 0 .708l4 4a.5.5 0 0 0 .708-.708L2.707 8.5H14.5A.5.5 0 0 0 15 8z"/></svg></button>
                <button name="reorder-tile-after" title="reorder tile after"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M1 8a.5.5 0 0 1 .5-.5h11.793l-3.147-3.146a.5.5 0 0 1 .708-.708l4 4a.5.5 0 0 1 0 .708l-4 4a.5.5 0 0 1-.708-.708L13.293 8.5H1.5A.5.5 0 0 1 1 8z"/></svg></button>
                <button name="delete-tile" title="delete selected tile"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/><path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/></svg></button>
              </div>
            </div>
            <div class="row" id="palette-edit" hidden="hidden">
              <div class="column radio-select" id="color-select" title="select palette">
                <div class="horizontal-capsule">
                  <label>
                    <input type="radio" name="color-select" value="0,0" title="select palette 0, color 0"/>
                  </label>
                  <label>
                    <input type="radio" name="color-select" value="0,1" title="select palette 0, color 1"/>
                  </label>
                  <label>
                    <input type="radio" name="color-select" value="0,2" title="select palette 0, color 2"/>
                  </label>
                </div>
                <div class="horizontal-capsule">
                  <label>
                    <input type="radio" name="color-select" value="1,0" title="select palette 1, color 0"/>
                  </label>
                  <label>
                    <input type="radio" name="color-select" value="1,1" title="select palette 1, color 1"/>
                  </label>
                  <label>
                    <input type="radio" name="color-select" value="1,2" title="select palette 1, color 2"/>
                  </label>
                </div>
                <div class="horizontal-capsule">
                  <label>
                    <input type="radio" name="color-select" value="2,0" title="select palette 2, color 0"/>
                  </label>
                  <label>
                    <input type="radio" name="color-select" value="2,1" title="select palette 2, color 1"/>
                  </label>
                  <label>
                    <input type="radio" name="color-select" value="2,2" title="select palette 2, color 2"/>
                  </label>
                </div>
                <div class="horizontal-capsule">
                  <label>
                    <input type="radio" name="color-select" value="3,0" title="select palette 3, color 0"/>
                  </label>
                  <label>
                    <input type="radio" name="color-select" value="3,1" title="select palette 3, color 1"/>
                  </label>
                  <label>
                    <input type="radio" name="color-select" value="3,2" title="select palette 3, color 2"/>
                  </label>
                </div>
                <div class="horizontal-capsule">
                  <label>
                    <input type="radio" name="color-select" value="4,0" title="select palette 4, color 0"/>
                  </label>
                  <label>
                    <input type="radio" name="color-select" value="4,1" title="select palette 4, color 1"/>
                  </label>
                  <label>
                    <input type="radio" name="color-select" value="4,2" title="select palette 4, color 2"/>
                  </label>
                </div>
                <div class="horizontal-capsule">
                  <label>
                    <input type="radio" name="color-select" value="5,0" title="select palette 5, color 0"/>
                  </label>
                  <label>
                    <input type="radio" name="color-select" value="5,1" title="select palette 5, color 1"/>
                  </label>
                  <label>
                    <input type="radio" name="color-select" value="5,2" title="select palette 5, color 2"/>
                  </label>
                </div>
                <div class="horizontal-capsule">
                  <label>
                    <input type="radio" name="color-select" value="6,0" title="select palette 6, color 0"/>
                  </label>
                  <label>
                    <input type="radio" name="color-select" value="6,1" title="select palette 6, color 1"/>
                  </label>
                  <label>
                    <input type="radio" name="color-select" value="6,2" title="select palette 6, color 2"/>
                  </label>
                </div>
                <div class="horizontal-capsule">
                  <label>
                    <input type="radio" name="color-select" value="7,0" title="select palette 7, color 0"/>
                  </label>
                  <label>
                    <input type="radio" name="color-select" value="7,1" title="select palette 7, color 1"/>
                  </label>
                  <label>
                    <input type="radio" name="color-select" value="7,2" title="select palette 7, color 2"/>
                  </label>
                </div>
              </div>
              <div class="column" id="color-edit">
                <canvas id="color-huesat" width="216" height="216"></canvas>
                <input name="color-value" type="range" min="0" max="1" step=".01"/>
                <div class="button-row">
                  <input name="color-hex" type="text" value="#ffffff"/>
                </div>
              </div>
            </div>
            <div class="column" id="event-edit" hidden="hidden">
              <div id="event-empty" hidden="hidden">
                <h2>create event from template:</h2>
                <h3>general</h3>
                <div class="event-template-list">
                  <button name="create-event-character">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M3 14s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1H3zm5-6a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/></svg>character</button>
                  <button name="create-event-exit">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M3 2a1 1 0 0 1 1-1h8a1 1 0 0 1 1 1v13h1.5a.5.5 0 0 1 0 1h-13a.5.5 0 0 1 0-1H3V2zm1 13h8V2H4v13z"/><path d="M9 9a1 1 0 1 0 2 0 1 1 0 0 0-2 0z"/></svg>exit</button>
                  <button name="create-event-message">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M2.678 11.894a1 1 0 0 1 .287.801 10.97 10.97 0 0 1-.398 2c1.395-.323 2.247-.697 2.634-.893a1 1 0 0 1 .71-.074A8.06 8.06 0 0 0 8 14c3.996 0 7-2.807 7-6 0-3.192-3.004-6-7-6S1 4.808 1 8c0 1.468.617 2.83 1.678 3.894zm-.493 3.905a21.682 21.682 0 0 1-.713.129c-.2.032-.352-.176-.273-.362a9.68 9.68 0 0 0 .244-.637l.003-.01c.248-.72.45-1.548.524-2.319C.743 11.37 0 9.76 0 8c0-3.866 3.582-7 8-7s8 3.134 8 7-3.582 7-8 7a9.06 9.06 0 0 1-2.347-.306c-.52.263-1.639.742-3.468 1.105z"/></svg>message</button>
                  <button name="create-event-ending">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-flag" viewBox="0 0 16 16"><path d="M14.778.085A.5.5 0 0 1 15 .5V8a.5.5 0 0 1-.314.464L14.5 8l.186.464-.003.001-.006.003-.023.009a12.435 12.435 0 0 1-.397.15c-.264.095-.631.223-1.047.35-.816.252-1.879.523-2.71.523-.847 0-1.548-.28-2.158-.525l-.028-.01C7.68 8.71 7.14 8.5 6.5 8.5c-.7 0-1.638.23-2.437.477A19.626 19.626 0 0 0 3 9.342V15.5a.5.5 0 0 1-1 0V.5a.5.5 0 0 1 1 0v.282c.226-.079.496-.17.79-.26C4.606.272 5.67 0 6.5 0c.84 0 1.524.277 2.121.519l.043.018C9.286.788 9.828 1 10.5 1c.7 0 1.638-.23 2.437-.477a19.587 19.587 0 0 0 1.349-.476l.019-.007.004-.002h.001M14 1.221c-.22.078-.48.167-.766.255-.81.252-1.872.523-2.734.523-.886 0-1.592-.286-2.203-.534l-.008-.003C7.662 1.21 7.139 1 6.5 1c-.669 0-1.606.229-2.415.478A21.294 21.294 0 0 0 3 1.845v6.433c.22-.078.48-.167.766-.255C4.576 7.77 5.638 7.5 6.5 7.5c.847 0 1.548.28 2.158.525l.028.01C9.32 8.29 9.86 8.5 10.5 8.5c.668 0 1.606-.229 2.415-.478A21.317 21.317 0 0 0 14 7.655V1.222z"/></svg>ending</button>
                </div>
                <h3>special</h3>
                <div class="event-template-list">
                  <button name="create-event-player">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-person-circle" viewBox="0 0 16 16"><path d="M11 6a3 3 0 1 1-6 0 3 3 0 0 1 6 0z"/><path fill-rule="evenodd" d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8zm8-7a7 7 0 0 0-5.468 11.37C3.242 11.226 4.805 10 8 10s4.757 1.225 5.468 2.37A7 7 0 0 0 8 1z"/></svg>player avatar</button>
                  <button name="create-event-code">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-braces" viewBox="0 0 16 16"><path d="M2.114 8.063V7.9c1.005-.102 1.497-.615 1.497-1.6V4.503c0-1.094.39-1.538 1.354-1.538h.273V2h-.376C3.25 2 2.49 2.759 2.49 4.352v1.524c0 1.094-.376 1.456-1.49 1.456v1.299c1.114 0 1.49.362 1.49 1.456v1.524c0 1.593.759 2.352 2.372 2.352h.376v-.964h-.273c-.964 0-1.354-.444-1.354-1.538V9.663c0-.984-.492-1.497-1.497-1.6zM13.886 7.9v.163c-1.005.103-1.497.616-1.497 1.6v1.798c0 1.094-.39 1.538-1.354 1.538h-.273v.964h.376c1.613 0 2.372-.759 2.372-2.352v-1.524c0-1.094.376-1.456 1.49-1.456V7.332c-1.114 0-1.49-.362-1.49-1.456V4.352C13.51 2.759 12.75 2 11.138 2h-.376v.964h.273c.964 0 1.354.444 1.354 1.538V6.3c0 .984.492 1.497 1.497 1.6z"/></svg>custom code</button>
                </div>
              </div>
              <div id="event-properties">
                <div class="row">
                  <datalist id="field-names">
                    <option value="one-time"></option>
                    <option value="solid"></option>
                    <option value="ending"></option>
                    <option value="title"></option>
                    <option value="graphic"></option>
                    <option value="say"></option>
                    <option value="exit"></option>
                    <option value="touch"></option>
                  </datalist>
                  <div class="event-sheet column">
                    <div class="event-line" id="event-field-template" hidden="hidden">
                      <input type="text" name="field-name" list="field-names" autocomplete="off"/>
                      <select name="field-type">
                        <option>tag</option>
                        <option>tile</option>
                        <option>dialogue</option>
                        <option>location</option>
                        <option>javascript</option>
                        <option>text</option>
                        <option>json</option>
                        <option>file</option>
                      </select>
                    </div>
                  </div>
                  <div class="event-lines-toolbar">
                    <button name="add-event-field"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z"/></svg></button>
                    <button name="duplicate-event-field" hidden="hidden"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M13 0H6a2 2 0 0 0-2 2 2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h7a2 2 0 0 0 2-2 2 2 0 0 0 2-2V2a2 2 0 0 0-2-2zm0 13V4a2 2 0 0 0-2-2H5a1 1 0 0 1 1-1h7a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1zM3 4a1 1 0 0 1 1-1h7a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V4z"/></svg></button>
                    <button name="shift-up-event-field"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 15a.5.5 0 0 0 .5-.5V2.707l3.146 3.147a.5.5 0 0 0 .708-.708l-4-4a.5.5 0 0 0-.708 0l-4 4a.5.5 0 1 0 .708.708L7.5 2.707V14.5a.5.5 0 0 0 .5.5z"/></svg></button>
                    <button name="shift-down-event-field"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 1a.5.5 0 0 1 .5.5v11.793l3.146-3.147a.5.5 0 0 1 .708.708l-4 4a.5.5 0 0 1-.708 0l-4-4a.5.5 0 0 1 .708-.708L7.5 13.293V1.5A.5.5 0 0 1 8 1z"/></svg></button>
                    <button name="remove-event-field"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/><path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/></svg></button>
                  </div>
                </div>
                <div id="field-json-editor" hidden="hidden">
                  <textarea spellcheck="false"></textarea>
                </div>
                <div id="field-dialogue-editor" hidden="hidden">
                  <div class="row">
                    <div id="dialogue-editor-toolbar">
                      <label class="toggle">
                        <input type="checkbox" name="show-dialogue-preview" title="toggle dialogue preview"/><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M16 8s-3-5.5-8-5.5S0 8 0 8s3 5.5 8 5.5S16 8 16 8zM1.173 8a13.133 13.133 0 0 1 1.66-2.043C4.12 4.668 5.88 3.5 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.133 13.133 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755C11.879 11.332 10.119 12.5 8 12.5c-2.12 0-3.879-1.168-5.168-2.457A13.134 13.134 0 0 1 1.172 8z"/><path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/></svg>
                      </label>
                      <label class="toggle" hidden="hidden">
                        <input type="checkbox" name="show-dialogue-help" title="toggle dialogue help"/><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/><path d="M5.255 5.786a.237.237 0 0 0 .241.247h.825c.138 0 .248-.113.266-.25.09-.656.54-1.134 1.342-1.134.686 0 1.314.343 1.314 1.168 0 .635-.374.927-.965 1.371-.673.489-1.206 1.06-1.168 1.987l.003.217a.25.25 0 0 0 .25.246h.811a.25.25 0 0 0 .25-.25v-.105c0-.718.273-.927 1.01-1.486.609-.463 1.244-.977 1.244-2.056 0-1.511-1.276-2.241-2.673-2.241-1.267 0-2.655.59-2.75 2.286zm1.557 5.763c0 .533.425.927 1.01.927.609 0 1.028-.394 1.028-.927 0-.552-.42-.94-1.029-.94-.584 0-1.009.388-1.009.94z"/></svg>
                      </label>
                    </div>
                    <textarea></textarea>
                  </div>
                </div>
                <div id="field-tile-editor" hidden="hidden">
                  <div class="radio-select" id="field-tile-select" title="select tile">
                    <template id="field-tile-select-template">
                      <label>
                        <input type="radio" name="field-tile-select"/>
                      </label>
                    </template>
                  </div>
                </div>
                <div id="field-location-editor" hidden="hidden">
                  <div class="room-select radio-select" id="field-room-select" title="select room">
                    <template id="field-room-select-template">
                      <label>
                        <input type="radio" name="field-room-select" value="0" title="select room 0"/>
                        <canvas width="16" height="16"></canvas>
                      </label>
                    </template>
                  </div>
                  <canvas id="field-position-select" width="128" height="128" title="select position"></canvas>
                </div>
                <div id="field-file-editor" hidden="hidden">
                  <button name="field-file-select">select file</button>
                  <input id="field-file-info" type="text" readonly="readonly" value="test"/>
                </div>
              </div>
            </div>
            <div id="play-tab-body" hidden="hidden">
              <p>
                <div class="button-row">
                  <h3>Import</h3>
                  <button name="import_html" title="import from webpage" data-original-only="data-original-only">html</button>
                  <button name="import_bipsi" title="import a bipsi" data-original-only="data-original-only">bipsi bundle</button>
                  <button name="import_story" title="import an ink story" data-original-only="data-original-only">ink story</button>
                </div>
              </p>
              <p>
                <div class="button-row">
                  <h3>Export </h3>
                  <button name="export" title="export as webpage">release as html</button>
                  <button name="export_json" title="export as json">bipsi bundle</button>
                </div>
              </p>
              <p>
                <div class="button-row">
                  <h3>Extra </h3>
                  <button name="update" title="open this flickgame study in the latest version" data-remix-only="data-remix-only">update</button>
                  <button name="reset" title="reset project to default">reset to default</button>
                </div>
              </p>
              <h2>binksi -- 0.1 (2021/12/21)</h2>
              <p>propulse your <a href="https://kool.tools/bipsi/user-guide.pdf">bipsi</a> games with narration engine <a href="https://www.inklestudios.com/ink/">ink</a></p>
              <p>quick links to : <a href="https://kool.tools/bipsi/user-guide.pdf">bipsi user guide</a>,  <a href="https://kool.tools/bipsi/scripting-guide.pdf">bipsi scripting guide</a> and <a href="https://github.com/inkle/ink/blob/master/Documentation/WritingWithInk.md">writing with Ink</a></p>
              <p>to get started, use <a href="https://github.com/smwhr/binksi">the binksi repo</a> as a template</p>
              <p>many thanks and kudos to <a href="https://kool.tools/">candle</a> creator of bipsi !</p>
            </div>
          </div>
        </div>
      </div>
    </div>
    <script id="preload">(async function() {
    const splash = await loadImage("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEABAMAAACuXLVVAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAGUExURQAAAP/YAFIewjUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAACXSURBVHja7dJBCgMhDEDReIN4/8sOkba4mEULogN9DxcusvhEAwAAAAAAAAAAAAAAAABmfRMBAgQ8PCA/czndDwX0QwHRxonaQdT85oCx+szXra1/iW8CIs4G5LSBeoJ6iHF2BLw/QP2BVgG1kI0BN/Otr/VrwHICBAgQIECAAAECBAh4bgAAAAAAAAAAAAAAAAAAfyjiAkM9EgGHYOwCAAAAAElFTkSuQmCC"); 
    const canvas = ONE("#player-canvas");
    const rendering = canvas.getContext("2d");
    rendering.drawImage(splash, 0, 0);
    fitCanvasToParent(canvas);
})();

    </script>
    <script id="bundle-embed" type="application/json"></script>
    <script id="editor-embed" type="application/json" data-editor-only="data-editor-only">{
  "project": {
    "rooms": [{
      "id": 0,
      "palette": 0,
      "tilemap": [
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
        [0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 0],
        [0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0],
        [0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0],
        [0, 1, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 1, 0],
        [0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0],
        [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
        [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
        [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
        [0, 2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
      ],
      "highmap": [
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
      ],
      "wallmap": [
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
        [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
        [0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0],
        [0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0],
        [0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0],
        [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
        [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
        [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
        [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
        [0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
      ],
      "events": [{
        "id": 8,
        "position": [7, 14],
        "fields": [{
          "key": "is-player",
          "type": "tag",
          "data": true
        }, {
          "key": "graphic",
          "type": "tile",
          "data": 6
        }, {
          "key": "page-color",
          "type": "text",
          "data": "black"
        }]
      }, {
        "id": 9,
        "position": [9, 7],
        "fields": [{
          "key": "graphic",
          "type": "tile",
          "data": 9
        }, {
          "key": "solid",
          "type": "tag",
          "data": true
        }, {
          "key": "say",
          "type": "dialogue",
          "data": "hello"
        }]
      }, {
        "id": 10,
        "position": [7, 13],
        "fields": [{
          "key": "exit",
          "type": "location",
          "data": {
            "room": 0,
            "position": [7, 11]
          }
        }]
      }, {
        "id": 11,
        "position": [7, 12],
        "fields": [{
          "key": "exit",
          "type": "location",
          "data": {
            "room": 0,
            "position": [7, 14]
          }
        }]
      }, {
        "id": 12,
        "position": [9, 8],
        "fields": [{
          "key": "reception_talk",
          "type": "tag",
          "data": true
        }]
      }, {
        "id": 13,
        "position": [14, 9],
        "fields": [{
          "key": "exit-east",
          "type": "tag",
          "data": true
        }]
      }, {
        "id": 14,
        "position": [1, 9],
        "fields": [{
          "key": "exit-west",
          "type": "tag",
          "data": true
        }]
      }],
      "backmap": [
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
      ],
      "foremap": [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
      ]
    }],
    "palettes": [
      ["#3c6fad", "#d8d4dd", "#ff8e9e"],
      ["#192b33", "#201f7f", "#958fbf"],
      ["#2f1933", "#7f1f24", "#bf908f"],
      ["#251933", "#5f1f7f", "#bf8fac"],
      ["#193233", "#451f7f", "#bf8faf"],
      ["#331920", "#6b7f1f", "#8fbfb0"],
      ["#332219", "#7f651f", "#bfba8f"],
      ["#332719", "#547f1f", "#8fbfae"]
    ],
    "tileset": "19",
    "tiles": [
      { "id": 1, "frames": [1] },
      { "id": 2, "frames": [5] },
      { "id": 8, "frames": [8] },
      { "id": 3, "frames": [4] },
      { "id": 4, "frames": [6] },
      { "id": 5, "frames": [7] },
      { "id": 6, "frames": [0] },
      { "id": 9, "frames": [9] },
      { "id": 7, "frames": [2, 3] }
    ]
  },
  "resources": {
    "19": {
      "type": "canvas-datauri",
      "data": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAAAICAYAAAAx3fd+AAAAAXNSR0IArs4c6QAAASxJREFUWEfdVlsOwzAIW+5/6FSZROVZgGlVomr7WZsmPGJsGB/4zTnneh1jDFu2NdyHz7g32qPWIx/LtvLP8XI+Kj5l387zPmVX5fyW7yfQK6CoAKJk1/7uizAfCAAWRhUgjDV6ZlDunHkLsNU4ygXgMQDBMVDwH1VErXsBVxTAs2vFnCkZFo7nh+3+vQJECXoMNNmN2MkAMHu5MLJqjZiP0u8pEa/dYTOfebr1VVnaue+rAKoHK4Z4AEeXx8yr+M8u4IoCXPFtPjMV6m5/ncCf+SmGI9uZAdFZHsy8AqteXmUGeEIBlNJkLXAHUF0+fqb9iCGVIVD1yOy7UqBdCsBs5xnCu58uYHbZLRWAAsDr+Vw01cnbm8QjOc4A8WYAr4dHxYc+K/ntAuxpPwfos+gYDcxDZwAAAABJRU5ErkJggg=="
    }
  }
}
    </script>
    <script id="story-embed" type="application/json">{"inkVersion":20,"root":[["^demo ==binksi== game ",{"#":"TITLE"},"\n",{"->":"init"},["done",{"#n":"g-0"}],null],"done",{"init":[["ev","str","^auto: start game","/str","/ev",{"*":".^.c-0","flg":4},{"c-0":["\n",{"->":"front_desk"},null]}],null],"front_desk":[[["ev","str","^tag: reception_talk","/str","/ev",{"*":".^.c-0","flg":4},"ev","str","^tag: exit-east","/str","/ev",{"*":".^.c-1","flg":4},"ev","str","^tag: exit-west","/str","/ev",{"*":".^.c-2","flg":4},{"c-0":["\n",{"->t->":"talk_to_receptionist"},{"->":".^.^.^.g-0"},null],"c-1":["\n","^You cannot leave east yet","\n",{"->":".^.^.^.g-0"},null],"c-2":["\n","^You cannot leave west yet","\n",{"->":".^.^.^.g-0"},null],"#n":"opts"}],{"g-0":[{"->":".^.^.opts"},null]}],null],"talk_to_receptionist":[["^Welcome to Binksi Hotel.","\n","^Do you have a room here ?","\n","ev","str","^yes","/str","/ev",{"*":".^.c-0","flg":4},"ev","str","^no","/str","/ev",{"*":".^.c-1","flg":4},{"c-0":["\n",{"->":".^.^.g-0"},null],"c-1":["\n",{"->":".^.^.g-0"},null],"g-0":["^Then why bother me ?","\n","ev","void","/ev","->->",null]}],null]}],"listDefs":{}}</script>
    <script id="font-embed" type="text" data-char-width="6" data-char-height="8" data-runs="0,9786-9787,9829-9830,9827,9824,8226,9688,9675,9689,9794,9792,9834-9835,9788,9658,9668,8597,8252,182,167,9644,8616,8593,8595,8594,8592,8735,8596,9650,9660,32-126,8962,199,252,233,226,228,224,229,231,234,235,232,239,238,236,196-197,201,230,198,244,246,242,251,249,255,214,220,162-163,165,8359,402,225,237,243,250,241,209,170,186,191,8976,172,189,188,161,171,187,9617-9619,9474,9508,9569-9570,9558,9557,9571,9553,9559,9565,9564,9563,9488,9492,9524,9516,9500,9472,9532,9566-9567,9562,9556,9577,9574,9568,9552,9580,9575-9576,9572-9573,9561,9560,9554-9555,9579,9578,9496,9484,9608,9604,9612,9616,9600,945,223,915,960,931,963,181,964,934,920,937,948,8734,966,949,8745,8801,177,8805,8804,8992,8993,247,8776,176,8729,183,8730,8319,178,9632,160">data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAACACAMAAADDApyIAAAABlBMVEUAAAD///+l2Z/dAAAAAXRSTlMAQObYZgAABWtJREFUaN7tWkuW2zAMI+5/6S5qSwQIUnYy01XdNi91LEGk+IUVcV0A1iddcgPAeih/X2PXb3UaxDUAaVYe1gAAuGa4Zgbi/rPGpZsZRiW7JsU95/WRAOLvWLA+sgQ3wF77urP+XQu4vl2fAvh30QvgFogBBNICIFiWOElg1l72IKsIsZWJtQWyB6xrqBWVPaDv1/+xBSi2+PzqzbQfQktdUgepKz8K5x9m0m3E2zNuhYO3vVdjAUvGm72EbCYDZHWSRQUtSwF4KcsqVEUhXl1WnSGRFlEAnAQJhyQw+s2GfPucSkl7QM53+0eor8pODACNFcUOAJg3luT75vpuhu3i7MKxYk322MBHq7sAkGPL3ovgjCJWP3vxPV3sLcqS0DyoMQrn+Y03dgpBWD9wW42YAJL1cfJ7LAGmgLnC0vJoC1BSTUr5aOFywMo5rDiMrMt//7ELB/dBrY7AMccFss4mc3jfithlxzIjyFDIM5NN3jPLloCMHzo/A0AdEIC6I+etFLqXiiTYLRUxAHzo2YqAqgJ7K7awOTRj2mTQB8pAWIXor1yl2DrKZzQeQfaQaqtSBnln/E0PsBLw91oOL/tBNdxiY2r7/jPc4GTWkpM4qVz20kwKk4UdQDaQ/Ce0ggMAWW9WV9TC667Ui5RQCcByxCMVwUhQwkn3wxuAaR6yjdaKdiYSC+GxcFb06xcGP8DJiGtuqFm6Gyxabp6xcVI67WZjHQAoT8jc0JxBKuqqaANAtb0JbT7RpfVFtCqClHkwXV4LUKI/59XStRkAX9BsdkTtt9RuRfu9Ff0r+9ceEUPxbdvqyFVlX4qeATClrxNA0rV2zijZGJSwuQNKvS/g9uMUEnLs1MoqKHijult0+SBJ0AIgzgBzPiAVHSSIUYJ5D1gCJPfMd4Si+q5P/ldeBcPZPeOUXlV2ZVeyqu8NLDm5BEFSPYA+XK8KjEsMSBs5AVQzzfuCrkAPtn2oheeBGBJOD8A5AMwCQYqdSUUSfyAxpLbaUSKPadJOvecbw3zMHAgnlMjNqHHR/CodmXCPT9aOB64Pk04gST8Kk1prUPOrYXsQ2tlJ/HOfQ/1cpg5URxOLqp+mJWnYSFu+49grhPQ/vuIyTBgM5+wkMIwMarsMOFLlc+N/OZCzWHq5QS86NAKmaZDaQlsHfSYNxUXK0tTLhxCwRNUMf6NkBYShRJEbubd/Q6kHazKQxPMOQCQAbHRqAZByA1oVsQ6YZVs5GY4LojqsMkW6akm+n9r08xdonemgePjchL1LW7WpRTNad3tmfsM+WrYO+3LECWRBujnEh9WSVjP5Ci3QYoVaRW+g/F7TNMPaRQMiAYwEEA8wb/+HLqylW9jq1ZUstyJ1PeLnuNI3rOo+jWBfN40VCZo78Cj+HWTw+QhkThH9HaY9C9s5RJUzK/lEAlCIjFIEKEPaFgqHPcgSYCxrDi8auz0AEN8BnPcgfleCnwDA9OK0mbT6h/v+BgDE0QfSGRfsdIt6/wMJZlqqJdcypr0jLwJkvZMEfX71XhpjFDqUoP8BDAC+KeKTjVCJRTTAquHxFkBNbQB4KwHq1QGYJ8djMOiuVoKxHHk09fcAeHJ9BoDn11sAvL3GTZYibzYm1JNpOBmc1NI4EUPhmLtSpkaWQPpFaUKZflA+tbJcRBEZDhx85EyLF32jwLQn8q84SKA0LJTjo1VzZXIEoDMvMJQTLDECd7bEq4jCX7eBAThixFjRDxHxH5zAgDAlfPK2nH+Atrd68qYHPQHY52HaLC1YVt01A5S3Qq0E+UivvBg9AxBF1LAO+YD1a4BE3qHQ+2yLeqzkDAACwERJiBYf7UHmTeZoWYL8OyuSuP8H7ZUOIucBHAwAAAAASUVORK5CYII=</script>
  </body>
</html>